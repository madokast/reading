程序員的自我修養——鏈接、裝載與庫
第一部分
第1章 溫故而知新
硬件
	硬件三大關鍵CPU、内存和I/O控制芯片。
	早期CPU速度和内存一致，同一總綫連接。後來CPU快，使用北橋連接内存，更慢的I/O設備連接南橋，再連上北橋。
	對稱多處理器SMAP和多核處理器——摩爾定律失效，編程來到了多核時代。

操作系統
	CPU的多任務系統，搶占式。每個進程運行分配的時間，時間到了操作系統暫停，讓另一個進程繼續。

	内存的分段。
	進程1用的200b内存，是實際内存地址的0-199，進程2用的300b，是實際内存的200-499 。程序看來自己是獨享整個内存。
	内存的分頁。
	進程1用的200b内存，可能分到0-99、500-599兩頁。目的：防止程序都是占用連續内存區域，造成需要不斷大塊的移動，以容納新的程序。（現在一頁一般是4Kb）

	綫程。
	一個進程有多個綫程，綫程獨占寄存器和一段棧，和其他綫程共享代碼、數據等其他資源。綫程在操作系統中有内存訪問權限、執行的優先級之分。

	綫程安全。
	目的：保證并發時數據的一致性。
	原子操作（操作系統保證這種操作不會被打斷，例如交換兩個值）。
	同步與鎖，同步（一個綫程訪問數據時，另一個綫程不能訪問），鎖（同步的實現方法）。鎖有很多種，二元信號量、互斥量、臨界區、讀寫鎖、條件變量。
	編譯器的過度優化，以及CPU的亂序執行是多綫程安全中需要考慮的。

	綫程的實現。三個概念。
	多核CPU，一個綫程對於一個CPU，才是真的并發。
	操作系統内核綫程。操作系統通過調度不同CPU和CPU的分時復用構建出的綫程。（大概也許是虛擬CPU？）
	用戶態綫程。應用程序的綫程是在内核綫程基礎上實現的，它和内核綫程有一對一、多對一、多對多關係。多對多能保證不會被阻塞，又有較高性能。
第二部分 靜態鏈接 
第2章 編譯和鏈接
2.1 被隱藏了的過程
IDE：構建（build）=編譯+鏈接  e.g.  gcc hello.c
實際上有4個過程
預處理（prepressing）：主要是處理#指令。例如，展開宏定義，插入#including中的文件。
編譯（compilation）：得到匯編代碼文件。詞法、語法、語義分析，優化。最複雜的一環。
匯編（assembly）：得到機器指令文件。按照對照表，一條條翻譯匯編指令即可。簡單。
鏈接（linking）：靜態鏈接。涉及多個環節。暫不表。

2.2 編譯器做了什麽
第三部分 裝載與動態鏈接
第四部分 庫與運行庫