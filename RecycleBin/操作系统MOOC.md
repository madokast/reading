操作系統(MOOC西安交通大學)
第一章 操作系統概述
1.概念
爲什麽要有操作系統？——計算機硬件難以使用，因此在硬件上覆蓋一層軟件，方面用戶使用計算機。
操作系統——資源分配、控制程序、内核（全時運行的一個程序）、軟硬件的接口

2.操作系統的發展——OS從無到有，從簡單到複雜的過程
需求：提高資源利用
歷史：
	真空管時代，無操作系統，手工操作
	晶體管時代，批處理系統
	集成電路時代，多道程序
	大規模超大規模集成電路時代，分時系統等

無操作系統（手工操作）：
	用戶獨占主機，設備利用率低；CPU等待用戶裝入/卸載卡片
	矛盾：人機矛盾（人工操作，利用率低），CPU和I/O速度不匹配

批處理系統：
	先輸入到外圍機，再給CPU，同樣CPU的輸出先到外圍機，再輸出。解決“CPU和I/O速度不匹配”
	特點：	順序性（先執行完一個程序，再執行下一個）
			單道性（内存中僅有一個程序在運行）
			自動性
	優點：減少了CPU空閑
	缺點：CPU和I/O設備閑忙不均。

多道程序：
	内存中同時放幾個作業，每個作業都在執行的開始和結束之間（CPU切換執行）。作業共享CPU、内存、外設
	通道技術：外設和内存信息傳輸。
	中斷機制：CPU可以中斷當前任務，轉去執行另一個任務。
	特點：	無序性（作業的完成和放入順序無關）
			調度性（需要對作業進行調度）
	缺點：無交互能力（因爲輸入先到磁盤，再到CPU）
	對OS的要求：内存管理、CPU調度、資源的共享和競爭、設備分配、OS提供I/O手段、文件管理

分時系統：
	多個用戶共用一臺計算機/前臺後臺分時。
	實現方式：	作業直接進入内存。
				作業一次只運行很短的時間（時間片，如100ms）		
	特點：人機交互/多用戶共享一臺主機/“獨占性”/及時性
第二章 操作系統結構
1.計算機硬件（CPU和設備并行/中斷/同步異步IO）
CPU——（總綫）——（設備驅動）——（設備控制器）——（物理設備）
（設備控制器）中包含自己的芯片（緩衝、寄存器），所以能夠和CPU并行執行。
（設備控制器）能發出中斷信號，CPU收到後，停止當前任務處理中斷（如，鍵盤的輸入）

中斷分類：
	硬件中斷（傳統中斷），由（設備控制器）發出
	輭件中斷（兩種），程序異常（如，除0錯誤）/系統調用（system call，如read()/write()）

同步和異步I/O：
	同步I/O，程序發出I/O請求後，就會暫停，直到I/O完成。（陷入内核，如下圖）
		程序	I/O請求—————————處於等待—————————————繼續執行
		内核				收到I/O請求，處理I/O，完成後交還給程序
		時間綫——>——>——>——>——>——>——>——>——>——>——>——>——>——>
		注釋：内核（設備驅動+中斷句柄+硬件）
	異步I/O，程序發出I/O請求後，自身不會暫停。
2.硬件保護（對OS的保護，防止惡意程序破壞其他程序和OS）
兩狀態操作（dual-mode operation）
用戶態（user mode）
管態（特權模式、系統模式 monitor mode、supervisor mode、system mode）

（用戶態）—中斷—>（管態）—設置用戶態—>（用戶態）

特權指令：
	只有管態才能運行的指令。
	用戶態只能以system call來調用指令（此時陷入内核）
	所有I/O指令都是特權指令

内存保護：程序無法直接訪問、修改非本程序的内存空間
CPU保護：OS每次只給程序一個時間片，防止長期占用CPU（依靠Timer計時器實現）
3.操作系統服務（為用戶提供服務/爲了提高系統效率的服務）
操作系統有一系列功能（特權指令），以system call的形式給上層程序和用戶使用。system call也可以包裝成user interface，如GUI、命令行界面。

底層：———————————————硬件———————————————
操作系統：——————————提供的服務services——————————
		程序的執行	I/O操作	文件系統	進程通信	資源分配	
		賬戶（記錄程序對資源的使用）	錯誤error的發現和處理	
		自身保護和安全
使用服務的方法：———————system call———————————
對服務的封裝：————————user interface—————————————
					GUI界面	command line命令行
最上層：————————————用戶和應用程序———————————
4.系統調用（程序和OS的接口/API/過程）
system call
	早期為匯編代碼，現在一般是C/C++

API
	程序一般不直接進行system call，而是使用API（application program interface）
	因爲system call在不同OS上不同，而使用API支持跨平臺
	常見API：win32 API/POSIX API for UNIX/Java API for JVM

系統調用過程
	1.程序進行system call，產生相應指令
	2.CPU收到指令，發生軟中斷——保存現場（PSW、PC、寄存器），然後處理中斷
	3.CPU通過入口地址表，找到system call需要用到的子程序的地址，執行之
	4.執行完畢，恢復現場，返回用戶態

參數傳遞：有時程序進行systen call時需要向OS傳參，有3種方法
	1.存在寄存器中傳遞
	2.存在内存中，然後内存地址存在寄存器中
	3.堆棧中。程序壓入，OS彈出

system call分類：
	進程控制	文件管理	設備管理	I/O		進程間通信



注釋：
PSW
即程序状态字（有些教材也叫程序状态寄存器），Program Status Word。可用于OS在管态（系统态）和目态（用户态）之间的转换。
入口地址表
system call的編號——相關函數的地址
找到地址就可以去執行相關函數了
5.操作系統結構
早期OS
	MS-DOS不劃分模塊。因爲硬件資源不足，希望以最小的空間提供最大功能。
	UNIX有限的結構化。分離為kernel内核+系統程序
		内核kernel：硬件之上，system call之下，包括CPU調度、文件系統等

層次化OS
	分爲若干層，上層只調用下一層，不跨層，不上調用
	優點：層層獨立，可以獨立開發，修改
	缺點：劃分複雜

微内核OS
	將不必要的部件全部移出内核，封裝成一個server用戶程序（運行在用戶態，C\S方式）
	OS只剩一個微内核，只提供進程管理、存儲管理、通信功能
	工作方法：程序進行system call，指令進入内核kernel，内核再調用server程序來完成服務
		————————————————————————————————
			應用程序				server程序（移出内核的程序）
				⬇system call					⬆
			内核kernel———消息機制———>	⬆
		————————————————————————————————
	優點：
		内核精巧。
		可以面嚮多處理機和分佈式系統
		基於客戶/服務器體系結構


注釋
	C/S，客戶機/服務器
第三章 進程
3.1 進程概念
程序->進程process
意義：提高資源的利用率，但是也增加了OS複雜性
特點：
	異步性——程序執行失去時序關係(時序關係破壞)
	失去封閉性——一個程序寫入存儲器的數據可能會被別的程序修改()
	失去可再現性——兩次執行的結果可能不同

進程：一個正在執行的程序
包含：代碼、當前狀態、堆(申請的動態内存)、棧(臨時數據)、數據段(全局變量)

描述進程：
	I處於何種狀(運行，就緒，等待)
	II進程控制塊PCB
	III所屬的執行程序
	IV處於那個隊列
	V占用的資源(内存、文件等)
3.2 進程狀態
五個
	新建new：創建進程
	就緒ready：等待分配處理器
	運行running：執行指令
	等待waiting：等待某些事情發生
	終止terminated：執行完畢

狀態轉換
                new->ready<->running->terminated
                                ↑               ↓
                                   waiting 
	ready和running之間轉換，running到waiting，再到ready
3.3 進程控制塊 PCB
PCB(process control block)
	一個數據結構。存放進程的外部特徵。
	創建進程時，建立PCB，伴隨進程全過程。（操作系統感知進程存在的唯一標志）
	PCB和進程一一對應。

内容
	進程標識符 name (編號)
	進程狀態（上一節）process state
	進程計數器PC program counter
	CPU現場信息：
	CPU寄存器 register
	CPU調度信息 scheduling information (優先級、隊列指針)
	内存管理信息 memory-management information
	記賬信息 accounting information
	I/O狀態 I/O state information

PCB表
	OS管理PCB的方式，存放在内存的一個地方
	PCB表的個數決定系統最多同時存在的進程個數
	組織方式：鏈接、索引
3.4 操作系統調度 scheduling
隊列分類(進程在各個隊列閒遷移)
	作業隊列job queue：所有進程
	就緒隊列ready queue：等待執行的進程
	設備隊列device queue：等待I/O的進程

調度分類
	長程調度：選擇進程進入就緒隊列。速度慢，因爲需要合理的組合I/O進程和CPU進程
	中程調度：緩解内存緊張問題，把處於阻塞狀態的進程swap到外存
	短程調度：即CPU調度，分配CPU

進程分類
	I/O進程
	CPU進程

上下文切換——CPU切換
	當前進程的狀態保存到PCB
	載入下個進程的PCB信息
3.5 進程操作(1)
進程有生命周期：產生、運行、暫停、終止。控制進城的生命周期就是進程操作。

進程操作是CPU管理的一部分（還有進程同步、通訊和調度）

具體的操作分爲：
	創建：創建後的進程進入就緒狀態。
	調度：對處於就緒狀態的進程進行調度，放入相應隊列
	阻塞：運行中的進程停止，進入等待狀態
	喚醒：等待狀態進入就緒狀態
	撤銷：運行狀態進入終止

進程創建幾種情況：
	作業調度——把程序從硬盤讀入内存
	用戶登錄
	提供服務——系統創建進程來提供某服務，如打印
	應用請求——應用自己要求創建子進程

父子進程樹
	資源的共享情況、執行是否需要有順序、地址空間分佈
3.6 進程操作(2)
進程創建——UNIX實例：
	fork()函數：系統調用，創建新進程，這個新(子)進程和父進程的地址空間一樣，也就是複製了父進程的地址空間。fork本意是叉子，所以是進程的分支。
	execlp()函數：在fork()后，用execlp()載入新程序來代替原來子進程的地址。

	圖示：
	　　　　　　　　|－父進程－－－－－－－－－－－－－－－等待子進程結束
	進程－ｆｏｒｋ－|
	　　　　　　　　|－子進程－ｅｘｅｃｌｐ－載入執行新程序

	代碼：
void main()
{
	int pid;pid = fork();
	//子進程創建失敗
	if(pid<0)
		{fprintf(stderr,"Fork Failed"); exit(-1);}
	//子進程創建成功
	else if(pid=0)//在子進程中，pid=0。子進程進入此分支，用execlp載入另一個程序，執行之
		{execlp(/bin/program);}
	else//在父進程中pid=子進程的進程號。父進程進入此條件分支，等待子進程執行結束。
		{wait(NULL); printf("child complete"); exit(0);}
}

進程終止:
進程終止的幾種情況：
	都是發出系統請求，然後操作系統做出相關清理工作。
	1.子進程自己執行完全部代碼。這時向父進程報告，然後操作系統清理
	2.父進程强制終止子進程。
	3.父進程自己終止時，操作系統會先終止其子進程。級聯終止。

進程阻塞:
	1.進程原本處於運行中。
	2.這時他要等待某事件發生。
	3.???調用阻塞原語，進程從運行態變成阻塞態。
	4.把進程加入到某個阻塞隊列。

喚醒進程：
	1.進程原本處於阻塞態。
	2.系統喚醒進程。
	3.或者某個進程來喚醒該進程。
3.7 進程通訊：共享存儲
生產者和消費者問題：一類問題的抽象
	生產者生產產品
	消費者消費產品

	儅緩衝區為滿時，生產者停止生產
	儅緩衝區為空時，消費者停止消費

	循環鏈表和指針實現：
	in==out，則説明緩衝區為空，消費者停止消費
	(in+1)mod(size)==out，衝區為滿，生產者停止生產
3.8 進程通訊：消息傳遞
發送方和接收方問題：
一般而言，PQ兩個進程需要通訊時，需要創建連接，然後利用 send/receive 發收信息

通訊的實現方法：
	物理實現
	邏輯實現：重點

邏輯實現中的問題
	1.如何建立連接
	2.雙方還是多方
	3.每對通訊進程閒可以有多少連接
	4.連接的容量
	5.消息的長度，可變/不可變
	6.連接是無向還是雙向


直接通訊：
	進程雙方需要顯示命名，知道對方的名字，然後send(P,msg) receive(Q,msg)
特點：
	連接自動建立、每對進程存在一個連接

間接通訊：mailbox信箱/port端口
	信箱/端口需要顯示命名，P和Q都使用同一個信箱/端口時才能通訊
	send(mailbox,msg) receieve(mailbox,msg)
特點:
	如果多個進程都共享同一個信箱/端口，可以多方通訊
	需要建立、使用、銷毀信箱/端口，三個過程
	若P Q1 Q2共享一個信箱/端口。P發送消息，如果不指定誰接受，那麽具體是誰收了消息是不確定的。
阻塞和非阻塞、同步和異步問題：
	1.發送方可能發送后需要等待接收方回信在執行，也可能不管，繼續做自己的事
	2.接收方也可能要等待消息，也可能不等
信箱/端口的緩冲大小：
	大小為0——發送方一定要等對方收消息后，才能發新消息
	大小有限——滿了就不發送
	大小無限——一直可以發送
第四章綫程
4.1 綫程的引入
進程的兩個基本屬性：
	擁有資源、獨立調度/分配的基本單位
	因此進程的創建、撤銷、調度，系統開銷較大
	因此進程數目不宜過多，切換頻率不易過高，限制了并發程度

操作系統的設計目標：
	提高并發度、減少系統開銷

因此，把進程的兩個基本屬性分開：
	擁有資源的單位——不頻繁切換（進程）
	不擁有資源——頻換切換（綫程）
引入綫程目的
	小的開銷，提高并發

綫程：
	只擁有必不可少的資源：綫程狀態、程序計數器、寄存器上下文、棧
	擁有就緒、阻塞、執行三種基本狀態
	與同屬於進程的其他綫程共享資源：代碼段、數據段、操作系統資源
	可并發

優點：
	調度開銷小。即，創建、撤銷等工作開銷小。（創建時間快30倍，切換時間快5倍）
	綫程閒可以不通過OS内核就能通訊
	多綫程程序：響應度高、資源共享、經濟、更適合于多核系統MP
4.2 用戶綫程和内核綫程