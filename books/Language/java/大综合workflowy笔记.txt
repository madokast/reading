应用

- Linux
  - yum 源出现问题
    - 删除全部repo文件
      "进入 /etc/yum.repos.d/
      删除全部repo文件"
    - 下载一个repo
      "wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo"
    - 然后更新
      "yum clean all
      yum makecache"
  - 端口监听
    - 查看80端口监听情况 netstat -tunlp | grep 80
  - centos7防火墙
    - 开启 systemctl start firewalld.service
    - 关闭 systemctl stop firewalld.service
    - 重启 systemctl restart firewalld.service
    - 状态 firewall-cmd --state
    - 查看已开放端口(完全暴露) firewall-cmd --list-port
      "80/tcp 8080/tcp"
    - 开放端口(完全暴露) firewall-cmd --permanent --add-port=80/tcp
    - 关闭端口(完全暴露) firewall-cmd --remove-port=80/tcp
    - 开放端口(指定源IP) firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.2.0/24" port protocol="tcp" port="3306" accept"
      "注意 这里指定的是网段"
    - 关闭端口(指定源IP) firewall-cmd --permanent --remove-rich-rule="rule family="ipv4" source address="192.168.2.2" port protocol="tcp" port="6379" accept"
- Docker
  - 尚硅谷教程 基础篇
    - 前提知识等 (1413 1527
      "前提知识
      Linux 知识 命令
      maven和git相关知识
      
      课程时间：1.5天
      
      docker开发者需要：k8s/golang"
      - 是什么？为什么？目的？
        "痛点：开发和运维不在一个平台，经常出问题。环境和配置不同
        
        docker 环境的整体打包
        软件带环境安装
        
        镜像技术
        
        方便集群安装
        
        基于GO语言
        
        打包代码和环境，换到别的机器上一次运行好
        
        俗称：交镜像
        
        DevOps 开发也运维"
      - 三要素
        - 仓库
        - 镜像
        - 容器
      - 和虚拟机的区别
        "虚拟机：在一个OS中运行另一个OS
        缺点：123"
    - 安装 (1744 1835
      "CentOS 6.5 及以上版本
      
      https://docs.docker.com/install/linux/docker-ce/centos/#prerequisites"
      - 阿里云镜像加速
        "https://promotion.aliyun.com/ntms/act/kubernetes.html
        
        支付宝登陆
        
        https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors
        
        镜像加速器
        
        ----------
        1. 安装／升级Docker客户端
        推荐安装1.10.0以上版本的Docker客户端，参考文档 docker-ce
        
        2. 配置镜像加速器
        针对Docker客户端版本大于 1.10.0 的用户
        
        您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器
        
        sudo mkdir -p /etc/docker
        sudo tee /etc/docker/daemon.json <<-'EOF'
        {
          "registry-mirrors": ["https://qi028bt3.mirror.aliyuncs.com"]
        }
        EOF
        sudo systemctl daemon-reload
        sudo systemctl restart docker"
      - 启动 service docker start
      - hello world 测试
        "docker run hello-world
        ------------------
        本地没有hello-world镜像，会自动下载，并生成容器然后运行
        这个hello-world会自动运行结束，推出
        
        输出
        ----------
        [root@test23 docker]# docker run hello-world
        Unable to find image 'hello-world:latest' locally
        latest: Pulling from library/hello-world
        1b930d010525: Pull complete 
        Digest: sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2f
        Status: Downloaded newer image for hello-world:latest
        
        Hello from Docker!
        This message shows that your installation appears to be working correctly."
    - 底层原理
      - 工作原理
        "C/S结构
        docker是一个守护进程，外部通过它访问docker容器"
      - 为什么比VM快
        "docker的抽象层更少
        	不需要hypervisor实现硬件虚拟化
        	docker使用的是宿主机的硬件资源
        	所以在内存、CPU上更有优势
        dockaer使用宿主机的内核，所起启动时不需要加载OS内核"
    - 常用命令 (1901 1909) (2022 2116
      "启动服务 service docker start"
      - 帮助
        - docker version
          "[root@test23 docker]# docker version
          Client: Docker Engine - Community
           Version:           19.03.5
           API version:       1.40
           Go version:        go1.12.12
           Git commit:        633a0ea
           Built:             Wed Nov 13 07:25:41 2019
           OS/Arch:           linux/amd64
           Experimental:      false
          
          Server: Docker Engine - Community
           Engine:
            Version:          19.03.5
            API version:      1.40 (minimum version 1.12)
            Go version:       go1.12.12
            Git commit:       633a0ea
            Built:            Wed Nov 13 07:24:18 2019
            OS/Arch:          linux/amd64
            Experimental:     false
           containerd:
            Version:          1.2.10
            GitCommit:        b34a5c8af56e510852c35414db4c1f4fa6172339
           runc:
            Version:          1.0.0-rc8+dev
            GitCommit:        3e425f80a8c931f88e6d94a8c831b9d5aa481657
           docker-init:
            Version:          0.18.0
            GitCommit:        fec3683"
        - docker info
          "[root@test23 docker]# docker info
          Client:
           Debug Mode: false
          
          Server:
           Containers: 2
            Running: 0
            Paused: 0
            Stopped: 2
           Images: 1
           Server Version: 19.03.5
           Storage Driver: devicemapper
            Pool Name: docker-253:1-270273-pool
            Pool Blocksize: 65.54kB
            Base Device Size: 10.74GB
            Backing Filesystem: xfs
            Udev Sync Supported: true
            Data file: /dev/loop0
            Metadata file: /dev/loop1
            Data loop file: /var/lib/docker/devicemapper/devicemapper/data
            Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata
            Data Space Used: 22.54MB
            Data Space Total: 107.4GB
            Data Space Available: 34.6GB
            Metadata Space Used: 602.1kB
            Metadata Space Total: 2.147GB
            Metadata Space Available: 2.147GB
            Thin Pool Minimum Free Space: 10.74GB
            Deferred Removal Enabled: true
            Deferred Deletion Enabled: true
            Deferred Deleted Device Count: 0
            Library Version: 1.02.158-RHEL7 (2019-05-13)
           Logging Driver: json-file
           Cgroup Driver: cgroupfs
           Plugins:
            Volume: local
            Network: bridge host ipvlan macvlan null overlay
            Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
           Swarm: inactive
           Runtimes: runc
           Default Runtime: runc
           Init Binary: docker-init
           containerd version: b34a5c8af56e510852c35414db4c1f4fa6172339
           runc version: 3e425f80a8c931f88e6d94a8c831b9d5aa481657
           init version: fec3683
           Security Options:
            seccomp
             Profile: default
           Kernel Version: 3.10.0-123.el7.x86_64
           Operating System: CentOS Linux 7 (Core)
           OSType: linux
           Architecture: x86_64
           CPUs: 4
           Total Memory: 979.9MiB
           Name: test23
           ID: DUHJ:V7G4:5I5V:44PP:3UUB:GAST:OQDV:KJIY:47TB:Y5HN:4ZIX:2KRG
           Docker Root Dir: /var/lib/docker
           Debug Mode: false
           Registry: https://index.docker.io/v1/
           Labels:
           Experimental: false
           Insecure Registries:
            127.0.0.0/8
           Registry Mirrors:
            https://qi028bt3.mirror.aliyuncs.com/
           Live Restore Enabled: false
          
          WARNING: bridge-nf-call-iptables is disabled
          WARNING: bridge-nf-call-ip6tables is disabled
          WARNING: the devicemapper storage-driver is deprecated, and will be removed in a future release.
          WARNING: devicemapper: usage of loopback devices is strongly discouraged for production use.
                   Use `--storage-opt dm.thinpooldev` to specify a custom block storage device."
        - docker --help 帮助
          "[root@test23 docker]# docker --help
          
          Usage:  docker [OPTIONS] COMMAND
          
          A self-sufficient runtime for containers
          
          Options:
                --config string      
                          Location of client
                          config files
                          (default
                          "/root/.docker")
            -c, --context string     
                          Name of the context
                          to use to connect
                          to the daemon
                          (overrides
                          DOCKER_HOST env var
                          and default context
                          set with "docker
                          context use")
            -D, --debug              
                          Enable debug mode
            -H, --host list          
                          Daemon socket(s) to
                          connect to
            -l, --log-level string   
                          Set the logging
                          level
                          ("debug"|"info"|"warn"|"error"|"fatal") (default "info")
                --tls                
                          Use TLS; implied by
                          --tlsverify
                --tlscacert string   
                          Trust certs signed
                          only by this CA
                          (default
                          "/root/.docker/ca.pem")
                --tlscert string     
                          Path to TLS
                          certificate file
                          (default
                          "/root/.docker/cert.pem")
                --tlskey string      
                          Path to TLS key
                          file (default
                          "/root/.docker/key.pem")
                --tlsverify          
                          Use TLS and verify
                          the remote
            -v, --version            
                          Print version
                          information and quit
          
          Management Commands:
            builder     Manage builds
            config      Manage Docker configs
            container   Manage containers
            context     Manage contexts
            engine      Manage the docker engine
            image       Manage images
            network     Manage networks
            node        Manage Swarm nodes
            plugin      Manage plugins
            secret      Manage Docker secrets
            service     Manage services
            stack       Manage Docker stacks
            swarm       Manage Swarm
            system      Manage Docker
            trust       Manage trust on Docker images
            volume      Manage volumes
          
          Commands:
            attach      Attach local standard input, output, and error streams to a running container
            build       Build an image from a Dockerfile
            commit      Create a new image from a container's changes
            cp          Copy files/folders between a container and the local filesystem
            create      Create a new container
            diff        Inspect changes to files or directories on a container's filesystem
            events      Get real time events from the server
            exec        Run a command in a running container
            export      Export a container's filesystem as a tar archive
            history     Show the history of an image
            images      List images
            import      Import the contents from a tarball to create a filesystem image
            info        Display system-wide information
            inspect     Return low-level information on Docker objects
            kill        Kill one or more running containers
            load        Load an image from a tar archive or STDIN
            login       Log in to a Docker registry
            logout      Log out from a Docker registry
            logs        Fetch the logs of a container
            pause       Pause all processes within one or more containers
            port        List port mappings or a specific mapping for the container
            ps          List containers
            pull        Pull an image or a repository from a registry
            push        Push an image or a repository to a registry
            rename      Rename a container
            restart     Restart one or more containers
            rm          Remove one or more containers
            rmi         Remove one or more images
            run         Run a command in a new container
            save        Save one or more images to a tar archive (streamed to STDOUT by default)
            search      Search the Docker Hub for images
            start       Start one or more stopped containers
            stats       Display a live stream of container(s) resource usage statistics
            stop        Stop one or more running containers
            tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
            top         Display the running processes of a container
            unpause     Unpause all processes within one or more containers
            update      Update configuration of one or more containers
            version     Show the Docker version information
            wait        Block until one or more containers stop, then print their exit codes
          
          Run 'docker COMMAND --help' for more information on a command."
      - 镜像 读
        - docker images
          "列出本机所有镜像
          [root@test23 docker]# docker images
          REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
          hello-world         latest              fce289e99eb9        13 months ago       1.84kB
          
          镜像仓库源  标签  镜像ID  创建时间 大小
          
          标签代表镜像版本"
          - -a 所有镜像 //镜像可以层层嵌套
          - -q 只列出镜像ID
          - --digests 显示摘要
          - --no-trunc 完整信息
        - docker search XX 找镜像
          "https://www.docker.com/products/docker-hub
          在这里找"
          - -s 30 //点赞数大于30的
        - docker pull XX:tap 下载镜像
          - 没有写:tap 下载最新版
        - docker rmi XX 删除镜像
          - -f 强制删除
          - 空格可以删除多个
          - docker rmi -f $(docker images -q) 全部删除
      - 容器
        - 新建并启动容器 docker run [opt-说明] XXX [cmd] [arg]
          - --name="指定容器名字"
          - -d 后台运行
          - -i 交互模式运行
          - -t 分配伪终端
          - -p 端口映射 XX:YY
            "XX 暴露给宿主机的端口
            YY 容器内开发的端口"
        - 查看当前运行的容器(主要看容器ID) docker ps
          "[root@test23 ~]# docker ps
          CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
          630a4c4cc019        centos              "/bin/bash"         4 minutes ago       Up 4 minutes                            mycentos01"
          - -l 查看停止的容器
          - -n 数组 查看最近运行、停止的容器
        - 启动容器(不是新建) docker start 容器ID
        - 重启容器 docker restart 容器ID
        - 停止容器 docker stop 容器ID
        - 强制停止的容器 docker kill 容器ID
        - 删除已停止的容器 docker rm 容器ID
          "rmi删除镜像
          rm删除容器"
          - 删除全部已停止的容器
            " docker rm $(docker ps -n 1000 -q)"
        - 容器日志 docker logs -f -t --tail 数字 容器ID
          - -t 加入时间戳
          - -f 跟随最近的日志打印
          - --tail 数字 显示最后num条
        - 查看容器内进程 docker top 容器ID
        - 容器内部细节 docker inspect 容器ID
        - 进入正在运行的容器并以命令行交互 docker attach 容器ID
          "docker exec -it 917622e19e8a /bin/bash"
        - 外部执行容器内命令 docker exec -t 容器ID + 命令
          "docker exec -t 576b96b53cb4 pwd
          docker exec -t 576b96b53cb4 ls -lrt
          
          docker exec -it 917622e19e8a /bin/bash"
        - 容器内文件->主机 docker cp 容器ID:容器内路径 主机路径
        - (交互容器)以centos镜像为例
          - 安装 docker pull centos
          - 启动 docker run -it --name="mycentos01" centos
            "这就进入了centos容器内
            就是一个轻量级的Linux"
          - 关闭容器 exit
          - 暂时离开容器 crtl p q
        - (后台运行) -d
          - 容器后台运行，必须有前台进程
          - tomcat可以
      - 镜像 写
        - docker commit 提交容器副本 成为一个新的镜像
          "docker commit -m="描述" -a="作者" 容器ID 镜像名:tag
          
          ------------------------------
          [root@test23 ~]# docker commit -m="my tomcat" -a="zrx" 917622e19e8a zrx/tomcat:0.1
          sha256:1ae468678cc77ec8a995ad19fb69aeb985d3ed62070812a48797cf1ec8fc64b4
          [root@test23 ~]# docker images
          REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
          zrx/tomcat          0.1                 1ae468678cc7        5 seconds ago       507MB
          tomcat              latest              d191f894a2c7        4 days ago          507MB
          centos              latest              470671670cac        9 days ago          237MB
          hello-world         latest              fce289e99eb9        13 months ago       1.84kB"
    - docker 镜像 (2699-16-01 1741 1844
      "轻量级的、可执行的独立的软件包
      运行环境+软件+配置文件
      
      tomcat的镜像(500M)为什么这么大？镜像是一层套一层的"
      - UnionFS 联合文件系统
        "分层的文件系统
        对文件系统的修改的提交——一层层的叠加
        基于基础的镜像、可以继承获得应用镜像
        
        一层层文件系统组成
        bootfs == linux 内科 、 引导
        roots = 类似于Linux发行版本"
      - 镜像的加载
      - 分层的镜像 / 分层的原因
        "tomcat = 内核 + centos + jvm + tomcat"
    - 容器数据卷
      - 目的：容器产生的数据->持久化。容器间/容器主机间共享数据。(就相当于硬盘)
      - 容器内添加(挂载 - 数据共享)
        - 容器内拷贝文件到主机 docker cp 容器id:/容器内路径 目的主机路径
        - 命令 docker run -it -v /宿主机目录:/容器内目录 镜像XXX
          "docker run -it -v /root:/rootCon centos
          
          容器退出后，对挂载的读写依然存在
          
          -----------
          docker inspect 可以看到卷的挂载情况"
          - -v /宿主机目录:/容器内目录:ro  只读模式
          - 若出现无法写 --privileged=true
        - 使用 dockerFile 的 VOLUME 指令给镜像添加一个或多个数据卷
          "VOLUME ["path1","path2","path3".....]
          其中path1...表示容器内目录
          这样构建的镜像中，在运行后会有这些文件夹
          会挂载到宿主机中一个随机生成的地址
          利用docker inspect 可以看到
          大概是：/var/lib/docker/volumes/16515646165313546131/_data
          
          示例
          ---------------------------------------
          FROM centos
          VOLUME ["/dataVolumeContainer1","/dataVolumeContainer2"]
          CMD echo "finished,-----success"
          CMD /bin/bash
          ---------------------------------------
          
          宿主机被挂载的文件夹 位置：
          "Source":"/var/lib/docker/volumes/c8f3af15cb0d537ec1dd65ecbc638aee3393bd067ad51746c8f0e9311fb4e37b/_data"
          （来自mysql镜像的容器）
          "
      - 数据卷容器(--volumes-from c_name) - 容器间传递共享
        "命名的容器 挂载数据卷
        其他容器通过挂载这个（父容器）实现数据共享
        挂载数据卷容器 称为数据卷容器
        "
        - --volumes-from
          "第一步：
          	运行一个有VOLUME的镜像，并命名，如dc01
          	这样，这个dc01容器内有挂载文件夹 如 /data01
          	可以在里面读写
          第二步：
          	再运行一个相同镜像，docker run --name dc02 --volumes-from dc01 同镜像名
          	这样dco1 中的目录 /data01 和 dc01 的 /data01 是共享的
          	"
    - dockerFile
      - 用来构建 镜像 的构建文件，是一个脚本（由命令和参数构成）
      - ①编写 dockerfile 文件
        - 保留字 指令
          - FROM 基础镜像
            "要编写的镜像是基于哪个镜像的"
            - FROM scratch
              "相当于Java的 extends Object
              base镜像"
          - MAINTAINER
            "镜像维护者的姓名和Email"
          - RUN
            "容器构建后需要运行的命令"
          - EXPOSE 端口号
          - WORKDIR 默认启动容器后的工作目录（当前目录）
            "没有指定则时 \ 根目录"
          - ENV 环境变量
            "如 ENV MY_PATH /usr/mytest
            使用 WORKDIR $MY_PATH"
          - ADD 将宿主机目录下的文件拷贝进镜像且自动处理URL/解压
          - COPY
            "类似ADD 但是不处理，仅仅拷贝，将从构建上下文中的<源路径>的文件/目录复制到新一层的镜像内的WORKDIR 位置
            COPY src dest"
          - VOLUME 容器数据卷
            "用于数据保存、持久化"
          - CMD 指定容器启动时要运行的命令
            "可以有多个 但只有最后一个生效 而且会被docker run 中的参数替换"
          - ENTRYPOINT 指定容器启动时要运行的命令
            "和CMD一样，但不会被替换，追加"
          - CMD 和 ENTRYPOINT 区别
            "CMD 会被 docker run 最后的参数替换
            ENTRYPOINT  ： docker run 最后的参数会追加到后面"
          - ONBUILD 触发器/被继承时触发
            "当构建一个被继承的dockerfile命令时，父镜像再被子继承后，父镜像的ONBUILD被触发"
          - 保留字指令 大写 必须有一个参数
          - 指令从上到下 顺序执行
          - # 表示注释
        - 例子 centos 6.8 的 dockerfile 文件
          "FROM scratch // 类似于Java的object类，基础镜像
          MAINTAINER The CentOS Project <cloud-ops@centos.org> //作者 + 邮箱
          ADD c68-docker.tar.xz /
          LABEL name="CentOS Base Image" \
              vendor="CentOS" \
              license="GPLv2" \
              build-date="2016-06-02"
          
          # Default command
          CMD ["/bin/bash"] // -it 进入的 bash
          "
        - 例子 修改centos
          - dockerfile 脚本
            "FROM centos
            MAINTAINER zzyy<zzyy167@126.com>
            ENV MYPATH /usr/local
            WORKDIR $MYPATH 
            RUN yum -y install vim
            RUM yum -y install net-tools
            EXPOSE 80
            CMD /bin/bash"
          - 构建 docker build -f dockerfile文件 -t 镜像名:版本 一个点.
            "[root@localhost dockertest]# docker build -f /root/dockertest/dockerfile01 -t mycentos:1.3 .
            Sending build context to Docker daemon  2.048kB
            Step 1/8 : FROM centos
             ---> 470671670cac
            Step 2/8 : MAINTAINER zzyy<zzyy167@126.com>
             ---> Running in 37b33aeee999
            Removing intermediate container 37b33aeee999
             ---> ff098ed2a745
            Step 3/8 : ENV MYPATH /usr/local
             ---> Running in 2163a2d3c4c0
            Removing intermediate container 2163a2d3c4c0
             ---> 7718a17c54f4
            Step 4/8 : WORKDIR $MYPATH
             ---> Running in 9d33e28286f1
            Removing intermediate container 9d33e28286f1
             ---> 3d524dc1353e
            Step 5/8 : RUN yum -y install vim
             ---> Running in 9632a8c1a0a9
            CentOS-8 - AppStream                            4.2 MB/s | 6.5 MB     00:01    
            CentOS-8 - Base                                 1.4 MB/s | 5.0 MB     00:03    
            CentOS-8 - Extras                               1.1 kB/s | 2.1 kB     00:01    
            Dependencies resolved.
            ================================================================================
             Package             Arch        Version                   Repository      Size
            ================================================================================
            Installing:
             vim-enhanced        x86_64      2:8.0.1763-13.el8         AppStream      1.4 M
            Installing dependencies:
             gpm-libs            x86_64      1.20.7-15.el8             AppStream       39 k
             vim-common          x86_64      2:8.0.1763-13.el8         AppStream      6.3 M
             vim-filesystem      noarch      2:8.0.1763-13.el8         AppStream       48 k
             which               x86_64      2.21-10.el8               BaseOS          49 k
            
            Transaction Summary
            ================================================================================
            Install  5 Packages
            
            Total download size: 7.8 M
            Installed size: 31 M
            Downloading Packages:
            (1/5): gpm-libs-1.20.7-15.el8.x86_64.rpm        324 kB/s |  39 kB     00:00    
            (2/5): vim-filesystem-8.0.1763-13.el8.noarch.rp 1.3 MB/s |  48 kB     00:00    
            (3/5): vim-enhanced-8.0.1763-13.el8.x86_64.rpm  2.9 MB/s | 1.4 MB     00:00    
            (4/5): which-2.21-10.el8.x86_64.rpm              77 kB/s |  49 kB     00:00    
            (5/5): vim-common-8.0.1763-13.el8.x86_64.rpm    6.6 MB/s | 6.3 MB     00:00    
            --------------------------------------------------------------------------------
            Total                                           2.7 MB/s | 7.8 MB     00:02     
            warning: /var/cache/dnf/AppStream-02e86d1c976ab532/packages/gpm-libs-1.20.7-15.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEY
            CentOS-8 - AppStream                            1.6 MB/s | 1.6 kB     00:00    
            Importing GPG key 0x8483C65D:
             Userid     : "CentOS (CentOS Official Signing Key) <security@centos.org>"
             Fingerprint: 99DB 70FA E1D7 CE22 7FB6 4882 05B5 55B3 8483 C65D
             From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
            Key imported successfully
            Running transaction check
            Transaction check succeeded.
            Running transaction test
            Transaction test succeeded.
            Running transaction
              Preparing        :                                                        1/1 
              Installing       : which-2.21-10.el8.x86_64                               1/5 
              Installing       : vim-filesystem-2:8.0.1763-13.el8.noarch                2/5 
              Installing       : vim-common-2:8.0.1763-13.el8.x86_64                    3/5 
              Installing       : gpm-libs-1.20.7-15.el8.x86_64                          4/5 
              Running scriptlet: gpm-libs-1.20.7-15.el8.x86_64                          4/5 
              Installing       : vim-enhanced-2:8.0.1763-13.el8.x86_64                  5/5 
              Running scriptlet: vim-enhanced-2:8.0.1763-13.el8.x86_64                  5/5 
              Running scriptlet: vim-common-2:8.0.1763-13.el8.x86_64                    5/5 
              Verifying        : gpm-libs-1.20.7-15.el8.x86_64                          1/5 
              Verifying        : vim-common-2:8.0.1763-13.el8.x86_64                    2/5 
              Verifying        : vim-enhanced-2:8.0.1763-13.el8.x86_64                  3/5 
              Verifying        : vim-filesystem-2:8.0.1763-13.el8.noarch                4/5 
              Verifying        : which-2.21-10.el8.x86_64                               5/5 
            
            Installed:
              vim-enhanced-2:8.0.1763-13.el8.x86_64 gpm-libs-1.20.7-15.el8.x86_64          
              vim-common-2:8.0.1763-13.el8.x86_64   vim-filesystem-2:8.0.1763-13.el8.noarch
              which-2.21-10.el8.x86_64             
            
            Complete!
            Removing intermediate container 9632a8c1a0a9
             ---> 50cccb74238d
            Step 6/8 : RUN yum -y install net-tools
             ---> Running in c5698b24cdf7
            Last metadata expiration check: 0:00:09 ago on Mon Mar  2 13:55:48 2020.
            Dependencies resolved.
            ================================================================================
             Package         Architecture Version                        Repository    Size
            ================================================================================
            Installing:
             net-tools       x86_64       2.0-0.51.20160912git.el8       BaseOS       323 k
            
            Transaction Summary
            ================================================================================
            Install  1 Package
            
            Total download size: 323 k
            Installed size: 1.0 M
            Downloading Packages:
            net-tools-2.0-0.51.20160912git.el8.x86_64.rpm   379 kB/s | 323 kB     00:00    
            --------------------------------------------------------------------------------
            Total                                           233 kB/s | 323 kB     00:01     
            Running transaction check
            Transaction check succeeded.
            Running transaction test
            Transaction test succeeded.
            Running transaction
              Preparing        :                                                        1/1 
              Installing       : net-tools-2.0-0.51.20160912git.el8.x86_64              1/1 
              Running scriptlet: net-tools-2.0-0.51.20160912git.el8.x86_64              1/1 
              Verifying        : net-tools-2.0-0.51.20160912git.el8.x86_64              1/1 
            
            Installed:
              net-tools-2.0-0.51.20160912git.el8.x86_64                                     
            
            Complete!
            Removing intermediate container c5698b24cdf7
             ---> f55734fbda03
            Step 7/8 : EXPOSE 80
             ---> Running in c0ac0ef16ebb
            Removing intermediate container c0ac0ef16ebb
             ---> 859731a574e4
            Step 8/8 : CMD /bin/bash
             ---> Running in e8bd1e5c3de5
            Removing intermediate container e8bd1e5c3de5
             ---> 7678dfa6887f
            Successfully built 7678dfa6887f
            Successfully tagged mycentos:1.3"
          - 查看构建历史
            "[root@localhost dockertest]# docker history 7678dfa6887f
            IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
            7678dfa6887f        3 minutes ago       /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "/binâ€¦   0B                  
            859731a574e4        3 minutes ago       /bin/sh -c #(nop)  EXPOSE 80                    0B                  
            f55734fbda03        3 minutes ago       /bin/sh -c yum -y install net-tools             26.7MB              
            50cccb74238d        3 minutes ago       /bin/sh -c yum -y install vim                   63.4MB              
            3d524dc1353e        3 minutes ago       /bin/sh -c #(nop) WORKDIR /usr/local            0B                  
            7718a17c54f4        3 minutes ago       /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B                  
            ff098ed2a745        3 minutes ago       /bin/sh -c #(nop)  MAINTAINER zzyy<zzyy167@1â€¦   0B                  
            470671670cac        6 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  
            <missing>           6 weeks ago         /bin/sh -c #(nop)  LABEL org.label-schema.scâ€¦   0B                  
            <missing>           6 weeks ago         /bin/sh -c #(nop) ADD file:aa54047c80ba30064â€¦   237MB    "
      - ②docker build -> 镜像
        - 大致过程（每条指令都会构建一个新的镜像层（层层叠加））
          "从基础镜像运行 -> 基础镜像的容器
          执行下一条指令，对这个容器进行修改
          修改后的容器，提交为一个新的镜像（类似docker commit）
          然后再运行修改后的镜像 -> 在一个容器
          
          再读取下一条指令，修改容器，保存为镜像，再运行..."
      - ③docker run 运行构建的镜像 -> 容器
    - 常用镜像的使用
      - 总体步骤
        "search pull 查看 run stop rm"
      - tomcat
        "docker search tomcat
        docker pull tomcat
        docker run -it -p 8080:8080 tomcat"
      - mysql
        "docker pull mysql:5.6
        docker run -p3306:3306 --name mymysql -v /../conf:/etc/mysql/conf.d -v /../logs:/logs -v /../data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6
        
        挂载1 配置
         	
        挂载2 日志
        
        挂载3 数据"
      - redis
        "docker pull redis:3.2
        docker run -p6379:6379 -v /../data:/data -v /../redis.conf:/usr/local/etc/redis/redis.conf -d  reids3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes
        
        然后在宿主机上/../redis.conf 目录在新建redis.conf文件
        即 /../redis.conf/redis.conf"
    - 本地镜像 push 到 阿里云
      "第一步 commit 从容器->镜像
      docker commit -a 作者名 -m "说明" 容器id 原镜像名:新tag
      
      略。看看而已"
    - 总结
      "dockerfile
      	build -> image
      
      image
      	+ tag
      	push -> docker rigistry
      	run -> container
      
      container
      	+ stop
      	+ start
      	+ restart
      	commit -> image
      
      docker rigistry
      	pull -> image"
    - 常见问题/常用命令
      - docker restart和start的区别
        "简单：stop的容器要用start来继续运行
        
        ----------------------------
        
        大概是在2016/10前后，我们部门使用docker一段时间后偶尔会出现docker exec ... 无法进入容器的问题，环境为centos7.2、docker1.12.6，docker存储引擎为devicemapper，经过排查发现容器对应的文件系统已经umount，且发现开发同学用了大量的docker restart ... 操作。于是产生docker restart导致容器文件系统umount的疑问，后面对docker restart、start、stop三个命令与容器文件系统关系做了研究，以下是研究的记录。
        
        docker start ... 包含容器文件系统挂载的操作
        docker stop ... 包含容器文件系统卸载的操作
        docker restart ... 不包含容器文件系统的卸载与挂载操作，本质上docker restart不涉及文件系统的操作，因此restart命令并不是stop与start两个命令的顺序叠加。
        
        分析发现，docker restart命令并不是stop、start两个命令的顺序叠加，docker restart操作并不涉及容器文件系统的处理，开始怀疑的由于docker restart操作导致容器的文件系统处于umount状态此处没有找到证据，但为了保证容器的根文件系统与内存系统mount的正确性，推荐对一个容器的重启使用docker stop xxx 然后 docker start xxx，而非docker restart xxx。
        
        
        作者：汤尼房
        链接：https://www.jianshu.com/p/b7374f4e1e8f
        来源：简书
        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
        
        "
      - 启动 service docker start
      - 停止全部 docker stop $(docker ps -a -q)
      - 开始全部 docker start $(docker ps -a -q)
  - 远程部署docker ideaJ springcloud
    - [本地]ideaj 配置远程登陆 Tools -> SSH
      "连接到 远程 Linux"
    - [本地]ideaj 设置远程部署 Tool->Deployment
      "指定部署地点mapping"
    - [远程]修改docker配置 开启远程访问
      "vi /lib/systemd/system/docker.service
      
      // 注释掉下面的话
      # ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
      
      // 加上这句话
      ExecStart=/usr/bin/dockerd  -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock"
    - [远程]重启 docker 并验证端口
      "#重新加载配置文件
      [root@izwz9eftauv7x69f5jvi96z docker]# systemctl daemon-reload    
      #重启服务
      [root@izwz9eftauv7x69f5jvi96z docker]# systemctl restart docker.service 
      #查看端口是否开启
      [root@izwz9eftauv7x69f5jvi96z docker]# netstat -nlpt
      #直接curl看是否生效
      [root@izwz9eftauv7x69f5jvi96z docker]# curl http://127.0.0.1:2375/info
      ————————————————
      版权声明：本文为CSDN博主「波波仔86」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/bobozai86/java/article/details/88875784"
    - [本地]ideaj 配置 docker 地址 tcp://192.168.2.3:2375
      "显示 连接成功"
    - [本地]在项目新建Dockerfile
      "FROM openjdk:8
      MAINTAINER Madoka <578562554@qq.com>
      
      # ADD target/lib           /root/dockerMicroServer/eurekaServer27002/lib
      
      ADD target/cloud-eureka-server27002-1.0-SNAPSHOT.jar app.jar
      
      EXPOSE 27002
      
      ENTRYPOINT ["java", "-jar", "app.jar"]"
    - [本地]编译项目，并部署到远程
    - [远程]dockers build + run
- JAVA
  - JVM
    - 尚硅谷课程
      - 入门
        "定义：Java 虚拟机
        	Java 二进制字节码的运行环境
        好处：
        	一次编写、到处运行
        	提供自动垃圾回收功能
        	数组下标越界检查功能
        	多态的实现
        比较：
        	jvm 最小
        	jre = jvm + 基础类库 如java.lang
        	jdk = jre + 编译工具（javac）
        
        学习意义：
        	为了面试
        	理解底层实现（如 for-in 语法糖、动态代理）
        	中高级程序员必备技能 —— 定位程序运行中的问题"
        - 常见的JVM
          "jvm 仅仅是一套规范
          实现有很多种
          	oracle hotspot
          
          讲解以 hotspot"
        - 学习路线
          "类加载器
          
          内存结构
          	方法区 堆 虚拟机栈 程序计数器 本地方法栈
          
          执行引擎
          	解释器 JIT GC
          
          本地方法接口"
      - 内存结构
        - 程序计数器
          "class文件 需要解释器 才能执行
          
          class文字中的指令是一条条的
          读一条解释一条
          
          程序计数器：保存下一条JVM指令的地址
          
          物理实现：利用了一个物理寄存器
          
          特点
          	线程私有
          	不存在内存溢出（其他的都有）"
        - 虚拟机栈 栈帧 方法 形参、局部变量、返回值、返回地址
          "线程运行时需要的内存空间
          线程私有
          
          栈 - 由栈帧组成 - 每个栈帧代表一个方法调用
          栈帧 中保存 方法需要的内存（参数、局部变量） - 真简单
          
          栈 stack
          栈帧 frame
          
          活动栈帧 - 正在执行的方法
          
          垃圾回收设计栈内存吗？
          	不会，因为方法调用完后，自动回收（就是不管了而已）
          
          栈内存越大越好吗？
          	在启动jvm 时 -Xss1024k 就是指定栈内存最大1024kb
          	默认就是这么大，win系统则还会根据虚拟内存有所调整
          	回答：不是的，栈越大，会让最大线程数减少
          
          方法内的局部变量线程安全吗？
          	如果变量没有逃离方法的作用范围，则线程安全
          
          return obj
          obj 逃离方法的作用范围
          
          栈内存溢出 stack overflow exception
          	原因 
          	1. 栈帧过多，如递归。典型值2W多次递归，溢出。
          		JSON 套娃 也会出现递归 
          	2.栈帧过大，可能性不大"
        - 本地方法栈 native方法
          "调用本地方法时，需要的内存空间"
        - 堆 heap
          "来自 new 关键字，创建的对象在 堆 中
          
          特点
          	线程共享
          	垃圾回收
          
          堆内存溢出
          	out of memory error: Java heap space
          
          堆空间设置
          	-Xmx 最大堆空间
          	内存设置小一点，这样可以今早暴露出堆内存溢出错误
          
          问题：当一个线程出现OOM时，程序会停止吗？
          答：不会，只有出现OOM的线程崩溃，其他线程都继续运行"
        - 方法区 method area
          "是jvm规范 有不同实现
          
          保存类结构信息+运行时常量池（run-time constant pool）
          	类结构：静态成员、所有方法、构造器、类加载器
          
          逻辑上是 堆 的一部分，但是不强制如何实现
          	oracle hotspot  Java 8 之前，方法区实现为 永久代 (PerGen) (由JVM管理)
          	8以后 换成了 元空间 (metaspace)，用的是OS本地内存 (不由JVM管理)
          	方法区是JVM规范。“永久代”、“元空间”都是具体实现!! //清楚了
          
          	永久代 1.8前 受到JVM管理
          	元空间 1.8 不受JVM管理（自己有一套GC机制）
          
          特点
          	线程共享
          
          内存不足也会抛出 OOM
          	因此方法区也会内存溢出
          	1.8前 永久代溢出 OOM: PermGen space
          	1.8 元空间溢出 OOM: Metaspace
          
          设置方法区大小
          	设置元空间空间 -XX:MaxMetaspaceSize=8m
          	设置永久代空间 -XX:MaxPermSize=8m
          
          实际中方法区溢出的情景：动态代理，运行间动态生成类"
          - 运行期常量池 runtime constant pool
            "方法区的一部分 来自类字节码的常量池
            	包括symbolTable 符号表 （类命、方法名、包名）
            	Java 1.8前 常量值中包括 stringTable 字符串表
            	Java 1.8 不再包括 stringTbale ，stringTable 在堆中 (常量池中其他的东西在元空间、元空间在OS内存中，不受JVM管理) 
            
            何为运行期？
            	先得学习类字节码中的静态常量池
            	类字节码中存在 常量池（这是静态的） 
            	常量池就是一个表：(相对)地址-内容（其实就是数组，利用地址可以访问表中某项）
            	池中内容：类、方法、对象的符号、字面量(i=1)、编译期确定的字符串("hello")
            	符号：一般就是全类名、方法名、方法入参(因为有重载)
            
            	
            !!!当类字节码加载到JVM，那么类中的常量池就进入 方法区 的 运行期常量池
            	同时把其中的地址 改为 真实地址
            "
            - stringTable// intern()
              "运行期常量池的一部分(JDK1.8并不在一起)
              是一个hash map<k,v>因此相同对象只会存在一份
              	map 中的 value 是一个指针，指向堆中的字符串对象
              	这和类常量池不同，后者仅仅是数组
              
              需要区分 类常量池 和 运行期常量池
              	类常量池 只保存 符号
              	运行期常量池 保存 Java对象引用（key->value->"hello, world"）
              	因此加载时，需要创建对象
              
              	懒加载：类加载后，类常量池 中的东西不会立即加入到 运行期常量池，而是执行 ldc 指令时才会加载。//这很正常，因为一个类中，很可能有些方法永远不会被执行
              
              
              注意：类常量池 的字符串仅仅是符号，而不是java对象，在执行相关语句时，才会变成Java对象（基本类型、对象类型）
              
              ---------------------------------------------------
              String s1 = "a" + "b";
              // 这个可以事先知道是 "ab"
              
              
              String s2 = s1 + s1;
              // 这个实际是  new StringBuilder().append(s1).append(s2).toString
              // 不在常量池中
              
              "ab" == new String("ab");
              // false 前者在 运行期常量池 中，后者在 堆 中
              
              "ab" == "a" + "b"
              // true 编译器已经做了拼接，在指令中不再执行
              // 如果只有这个语句，那么实际上 类常量池/运行期常量池 中不存在 "a" 和 "b"
              
              
              "a" == new String("a").intern();
              // string.intern()  将字符串加入到 stringTbale，返回常量池对象
              // true
              
              String s = new String("abc")创建了几个对象？
              答：分别创建了两个对象，第一个对象“abc”存储在常量池中，第二个对象在Java Heap中的String对象。
              
              详解 string.intern();
              // jdk1.6中 先判断 stringTable 中是否存在相同的 string，利用equals方法判断
              		如果有，则返回 stringTable 中的相同的 string（地址）
              		没有，则把 string 复制到stringTable // 注意是复制
              		即在  stringTable 中 String a =  new String(string)
              //jdk 1.7及以后 先判断 stringTable 中是否存在相同的 string，利用equals方法判断（第一步相同）
              		如果有，则返回 stringTable 中的相同的 string （这也一样）
              		没有，则把 string 的地址存入 stringTable 
              		即在  stringTable 中 String a =  string
              //显然 jdk 1.7 及以后，要更节省资源。这也是为什么要把 常量池 放入 堆 中
              //所以在 jdk 1.7 ，s 是new出来的，但是 s.intern()==s 为 true ，这是以内常量池中指向的就是s
              // 在1.6和以前，不会出现
              
              String s = new String("a");
              s.intern() == s ? 
              // 总是返回 false，无论 jdk 1.6/1.7
              // 因为第一行代码，首先在常量池中 存放 "a"，然后new出"a"在堆中
              // a.intern()，会返回常量池中的 "a"
              
              String s = new String("a") + new String("b");
              s.intern() == s ? 
              // jdk 1.6 false 但是 1.7 true
              // 因为第一行代码中，常量池中只有 a 和 b
              // 所以执行intern时，jdk1.7及以后会把s地址放入stringTable，返回s本身，因此为true
              // 在 Java 13 中也是这样的！
              // 总结：1.6复制，1.7后为直接放这个串
              
              // 所以说，1.7后，stringTable没有就复制，这可以减小开销
              
              常量池/stringTable的具体位置
              	JDK1.6 stringTable 在常量池里面。常量池在永久代中
              	JDK1.8 stringTable 不在常量池中，在堆中。常量池在元空间中
              
              为什么呢？
              	JKD1.6的永久代 fullGC 时才会清理其中的内容，而老年代满了，才会触发fullGC，时机很晚，导致string Table难以及时得到清理，其中的hashMap冲突厉害，性能下降
              	所以在1.8后，stringTable移到了堆中，普通GC就会回收其中垃圾
              
              stringTable垃圾回收机制
              	stringTable 会发生垃圾回收吗？答：会的
              
              小tip
              	当JVM花费98%的时间用于垃圾回收，但只回收2%的空间，JVM就会放弃GC，抛出GC overhead limit"
              - 什么时候使用intern()
                "轶事
                	twitter公司：想把所用用户的基本信息都存入内存，其中最耗空间的是地址信息，如果不合并相同地址，则最终会要30G空间
                所以他们采用intern()，将地址信息存入StringTable，这样可以去重。据说这样内存30G减少到几百MB
                
                总结
                	当你需要大量的字符串数据，同时需要长期存留在内存，同时数据中重复度很大，就可以考虑存储前先入池
                
                // 一般使用手段
                list.add(str.intern())"
        - 直接内存[不属于JVM范畴，不受JVM管理]
          "特点
          	回收成本高(因为涉及访管)，但是读写性能高
          	不受JVM内存管理，需要手动释放
          
          使用方法
          	底层是Unsafe中的 private native long allocateMemory0(long bytes);
          	返回指针
          	setMemory(pointer,offset...)
          	freeMemory(pointer)
          
          常见使用场景
          	用于NIO操作时的数据缓冲
          	这是因为传统IO中，数据先进入JVM外内存，在复制进JVM内部，有一个复制的过程
          	但是NIO的直接内存，OS和JVM都可以访问，少了复制环节
          
          小tip——Java中的析构函数
          	Cleaner对象 这是一个 虚引用（我终于知道虚引用意义了）
          	首先我创造一个对象，把他的析构函数(runnable实现)放在Cleaner中
          	当没人再使用这个对象了，这个时候只有一个虚引用指向它
          	就会有一个referenceHandler线程执行 虚构函数"
      - 垃圾回收
        - 如何判断可回收
          "垃圾回收 是对 堆 中的对象回收"
          - 引用计数法 ×
            "隐患：循环引用
            
            早期python使用这个方法，Java 使用的是 可达性分析"
          - 可达性分析 √
            "第一步：确定根对象
            
            	什么是根对象？——当前不会被垃圾回收
            	在Java中，可作为GC Root的对象包括以下几种：
            	虚拟机栈（栈帧中的本地变量表）中引用的对象
            	方法区中类静态属性引用的对象
            	方法区中常量引用的对象
            	本地方法栈中JNI（即一般说的Native方法）引用的对象
            	// 总结：根对象其实不止一个。如核心类对象String、活动线程对象、活动线程所在方法中的对象
            
            
            第二步：扫描所有对象，查看对象是不是直接/间接被根对象引用"
          - 四大引用
            - 强引用
              "GC ROOT对象 强引用的对象，不会被回收"
            - 软引用 内存不够回收
              "是一个对象容器，里面放一个对象
              A --->  softR ---> Obj <--- B
              称为 A 软引用 Obj
              但此时 B 对象 强引用 Obj
              所以不会被回收
              
              对象 Obj 没有被 B 强引用时，会被回收
              
              使用场景：图片资源"
            - 弱引用 只要发生垃圾回收，就会被回收
            - 虚引用
              "1. 必须配合引用队列
              
              使用实例：
              nio 的 buffer 对象，内部会 请求直接内存
              但是JVM不会管理直接内存，需要手动释放
              怎么才能在 buffer 对象被回收的时候，一并释放掉直接内存呢？
              那就建立一个 buffer 的虚引用对象 cleaner
              	是的，cleaner是一个虚引用
              	代码：cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
              	cleaner 对象建立时，传入 buffer 本身，即this，以及一个回调函数，用于释放 直接内存
              那么当 buffer 对象失去强引用后，buffer对象会被立即回收，cleaner对象会被加入到 引用队列
              
              referenceHandler线程会不断扫描引用队列，如果发现有cleaner，就会由他调用cleaner的clean方法
              
              测试代码
              ------------------
                      LOGGER.info("创建强引用对象");
                      Object obj = new Object();
                      LOGGER.info("obj = {}", obj);
              
                      LOGGER.info("加入到cleaner中");
                      /**
                       * 注意运行Java时虚拟机参数加上 --add-opens java.base/jdk.internal.ref=ALL-UNNAMED
                       */
                      jdk.internal.ref.Cleaner.create(obj,()->LOGGER.info("执行clean方法"));
              
                      LOGGER.info("丢弃强引用");
                      obj = null;
              
                      LOGGER.info("手动GC");
                      System.gc();
              
                      LOGGER.info("等待一段时间再停止运行");
                      ThreadUtils.sleep(1000);
              
                      LOGGER.info("停止运行"); 
              
              测试输出
              --------------------
              2020-04-04 11:53:11.470  INFO 480 --- [           main] com.zrx.fragment.jvm.CleanerTest         : 创建强引用对象
              2020-04-04 11:53:11.470  INFO 480 --- [           main] com.zrx.fragment.jvm.CleanerTest         : obj = java.lang.Object@42ed89da
              2020-04-04 11:53:11.470  INFO 480 --- [           main] com.zrx.fragment.jvm.CleanerTest         : 加入到cleaner中
              2020-04-04 11:53:11.471  INFO 480 --- [           main] com.zrx.fragment.jvm.CleanerTest         : 丢弃强引用
              2020-04-04 11:53:11.471  INFO 480 --- [           main] com.zrx.fragment.jvm.CleanerTest         : 手动GC
              2020-04-04 11:53:11.504  INFO 480 --- [           main] com.zrx.fragment.jvm.CleanerTest         : 等待一段时间再停止运行
              2020-04-04 11:53:11.504  INFO 480 --- [ference Handler] com.zrx.fragment.jvm.CleanerTest         : 执行clean方法
              2020-04-04 11:53:12.507  INFO 480 --- [           main] com.zrx.fragment.jvm.CleanerTest         : 停止运行"
            - 终结器引用 @Deprecated 
              "object::finalize()方法
              这个方法可以重写
              
              当对象Obj要被回收时，Java虚拟机会创建一个 “终结器引用”，去引用这个Obj
              终结器Ref ---> Obj
              然后 终结器Ref本身 会被加入到 引用队列
              
              这是一个优先级很低的 finalize handler 线程，会搜索队列中的 终结器Ref
              利用 终结器Ref 找到 Obj，执行finalize()方法
              
              finalize()方法执行完后，才会被回收
              
              @Deprecated
              -----------------------------------
              object::finalize() 已经过时 @Since(9)
              因为 finalize handler 线程 优先级低，所以无法及时地执行
              另外，finalize handler 是单线程，所以效率低
              代理方法：实现 autoCloseable 接口、使用cleaner类等
              
              
              代码
              ------------------
                      LOGGER.info("创建对象");
                      Object obj = new Object(){
                          @Override
                          protected void finalize() throws Throwable {
                              LOGGER.info("调用finalize方法");
                              super.finalize();
                          }
                      };
              
                      LOGGER.info("失去强引用");
                      obj = null;
              
                      LOGGER.info("手动GC");
                      System.gc();
              
                      LOGGER.info("等待1S");
                      ThreadUtils.sleep(1000);
              
                      LOGGER.info("退出");
              
              
              输出
              ----------------------------
              2020-04-04 12:12:27.400  INFO 4576 --- [           main] com.zrx.fragment.jvm.终结器引用               : 创建对象
              2020-04-04 12:12:27.400  INFO 4576 --- [           main] com.zrx.fragment.jvm.终结器引用               : 失去强引用
              2020-04-04 12:12:27.401  INFO 4576 --- [           main] com.zrx.fragment.jvm.终结器引用               : 手动GC
              2020-04-04 12:12:27.440  INFO 4576 --- [           main] com.zrx.fragment.jvm.终结器引用               : 等待1S
              2020-04-04 12:12:27.440  INFO 4576 --- [      Finalizer] com.zrx.fragment.jvm.终结器引用               : 调用finalize方法
              2020-04-04 12:12:28.443  INFO 4576 --- [           main] com.zrx.fragment.jvm.终结器引用               : 退出"
            - 引用队列
              "一句话：如果 软/弱/虚引用 的对象被回收了，那么 软/弱/虚引用本身 会被加入到引用队列
              
              A ---> ref ---> Obj
              此时 A 强引用 ref 对象
              ref 引用 Obj对象
              当Obj被回收，则 ref-->null
              此时 ref 自己被加入到 引用队列
              "
              - 目的：处理集合中的引用本身
                "例子：软引用队列用于清理集合中的 软引用本身
                ---------------------------------------------------------
                我有个list，里面存放 softR<Obj>，这样Obj没有强引用时，会被回收
                此时 list中的 softR 里的对象已经是null，但是 softR本身还在list中，这不好！
                怎么清除呢？
                代码：
                -----------------------
                        List<WeakReference<Object>> list = new ArrayList<>();
                
                        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
                
                        for (int i = 0; i < 10; i++) {
                            WeakReference<Object> objR = new WeakReference<>(new Byte[4*1024*1024],referenceQueue);
                            list.add(objR);
                        }
                
                        System.gc();
                
                        LOGGER.info("list.size = {}", list.size());
                
                        // 可以看到 list 中的弱引用都空了，但是list中还有 objR，怎么清除呢？
                        LOGGER.info("清除list中的引用");
                        for(;;){
                            WeakReference<Object> poll = (WeakReference<Object>)referenceQueue.poll();
                            if(poll==null){
                                break;
                            }else {
                                list.remove(poll);
                            }
                        }
                
                        LOGGER.info("list.size = {}", list.size());
                        
                        //2020-04-04 15:26:21.576  INFO 14120 --- [           main] com.zrx.fragment.jvm.用引用队列清除引用本身         : list.size = 10
                        //2020-04-04 15:26:21.576  INFO 14120 --- [           main] com.zrx.fragment.jvm.用引用队列清除引用本身         : 清除list中的引用
                        //2020-04-04 15:26:21.577  INFO 14120 --- [           main] com.zrx.fragment.jvm.用引用队列清除引用本身         : list.size = 0"
        - 回收算法
          - 标记清除
            "第一步：可达性分析，标记可以回收的对象
            |OOO|XX|O|XX|
            |OOO|XX|O|XX|
            
            第二步：清除有标记的对象
            |OOO|      |O|      |
            |OOO|      |O|      |
            
            优点：清除速度快
            缺点：【堆内存碎片】因为只是清理对象，不会移动有用的对象，堆中出现内存碎片，导致空间利用率不高"
          - 标记整理
            "第一步：标记可回收的垃圾
            |OOO|XX|O|XX|
            |OOO|XX|O|XX|
            
            第二步：把有用对象移到一起
            |OOO|O|             |
            |OOO|O|             |
            
            优点：没有内存碎片
            缺点：存在对象移动，所以效率低"
          - 复制
            "第零步：堆区域划为内存相等两部分FROM & TO。对象永远在 FROM 区域中运行
            |     FROM               |                    |     TO                     |
            |                                |                    |                                |
            
            第一步：标记
            |OO|XX|O|XXX    |                    |                                |
            |OO|XX|O|XXX    |                    |                                |
            
            第二步：复制有用对象。FROM区域自动全清空
            |OO|XX|O|XXX    |                    |OO|O                     |
            |OO|XX|O|XXX    |                    |OO|O                     |
            
            第三步：FROM / TO 区域换名字
            |OO|O                     |                    |                                |
            |OO|O                     |                    |                                |
            
            优点：没有内存碎片
            缺点：需要双倍内存区域"
          - 以上三种算法，在JVM中都会用到
          - 分代垃圾回收
            "目的：提高GC性能。因为对象有的寿命很短，有的长期存活，所以分开存放，使用不同的回收算法
            堆分为新生代、老年代两个区域
            
            Eden -> To = From -> To = From ..... -> OldG
            
            Eden和From中的对象，没有回收且年轻，就到To区域，清理完后，To改名为From"
            - 新生代 Young Generation
              "新生代特点：
              	new 操作内存分配廉价——因为 TLAB thread local allocation buffer每个线程有私有的一个内存空区域，主要是考虑到线程并发时，内存分配的冲突问题。有了 TLAB ，内存分配就可以直接快速进行
              	死亡对象 回收代价很小
              	新生代中，大部分对象寿命很小
              	新生代满了，触发 minor gc，用时短"
              - Eden
                "新建的对象都在Eden区域
                当此区域满时，出发minor gc
                存活的对象放入To区"
              - S幸存区 From
                "eden->To = From
                每次minor gc，Eden和From区域的对象都会进入To区，寿命++
                然后交换From/To"
              - S幸存区 To
                "Eden中幸存对象，进入To区，寿命从0到1，然后交换From/To"
            - O老年代 Old Generation/或 晋升代 tenured generation
              "【晋升】对象进入老年代的行为
              1. 新生代minor gc后，还是满了，就最大寿命对象晋升
              2.新生代中，对象寿命>15，一定会晋升
              
              (小tip，age在mark word中只有4位，所以寿命只能是0-15)
              
              老年代空间不足，先尝试minor gc，若空间还是不足，触发FULL GC"
              - 问题：new的对象可以直接进入老年代吗
                "可以。
                设置新生代空间很小，老年代空间很大
                这是new 一个大对象
                新生代根本放不下
                就会直接放入老年代"
            - minor/full gc 触发 stop the world
              "原因：设计对象移动，所以必须停止所有其他线程
              FULL GC 暂停时间更长"
        - 垃圾回收器
          - 串行
            "特点：
            	单线程
            	发生垃圾回收时，暂停其他线程。（因为垃圾回收时，对象的地址会发生变化）
            适用场景
            	1. 堆较小
            	2. 无法利用多核性能，适合个人PC
            
            -XX:+UseSerialGC=Serial+SerialOld
            	开始串行垃圾回收器
            	Serial 用于新生代 使用 复制 算法
            	SerialOld 用于老年代 使用 标记整理 算法
            
            所以说：新生代和老年代各有自己独立的垃圾回收器"
          - 吞吐量优先
            "特点：
            	多线程。回收时，也会暂停用户线程。
            	单位时间内，STW占比尽可能小
            	即垃圾回收频率尽可能低，每次尽可能回收多的垃圾
            适用场景
            	堆内存较大
            	多核优势
            
            JVM设置方法
            	详见 JVM参数
            	可以调整 线程数目、每次垃圾回收最大暂停时间、垃圾回收占总时间比"
          - 响应时间优先 仅仅是老年代垃圾回收器 CMS
            "特点：
            	1. 多线程
            	2 单词垃圾回收的时间尽可能较短（程序暂停时间尽可能短）
            	    即每次只回收一点点垃圾，这样每次回收用时短，不影响程序
            	    很可能垃圾回收总时间占比会有点大
            	3. 不是堆内存不足才回收垃圾，到达一个阈值就开始垃圾回收（下文解释）
            	4. 标记清除 算法（下文解释）
            	5. 内存碎片多时，换成串行垃圾回收器（下文解释）
            适用场景
            	堆内存较大
            	多核优势
            
            运行流程
            	1. 堆内存不足<--错误，到达阈值
            	2. 暂停用户线程，【初始标记】，只标记 GC ROOT 对象，用时很短
            	3. 恢复用户线程，【并发标记】，标记所有对象
            	4. 暂停用户线程，【重新标记】，因为 并发标记 时，用户线程有可能改变了对象
            	5. 恢复用户线程，【并发清理】
            
            归纳：
            	一次GC，两次STW，【初始标记】【重新标记】
            	并发两次，【并发标记】【并发清理】
            
            不等到堆内存不足就开始GC
            	因为垃圾清理是并发的，所以如果等到内存不足再垃圾回收，很多用户线程会无法new对象了，更谈不上并发了
            
            标记清除 算法
            	因为清理垃圾时，是并发的，用户线程没有停止，所以不可能移动对象，
            
            内存碎片多时，换成串行垃圾回收器
            	因为采用标记清除算法，所以会造成内存碎片，所以需要一个其他的垃圾回收器 采用清除整理 算法来处理老年代垃圾。
            	这会导致垃圾回收突然占用时间很长
            
            注意：因为每次垃圾回收时间较长，所以对用户线程还是有影响的，也就是说用户线程可能只能占用3/4的CPU"
            - 问题：并发标记安全吗？
              "回答：不安全，可能存在错误，所以需要重新标记
              具体：略"
          - G1
            "garbage 1 垃圾回收器
            2004年 论文发布
            2017年 JDK9的默认垃圾回收器
            
            特点
            	1. 同时注重 吞吐量 和 低延迟
            	2. 堆内存划分为大小相同的 region（适合超大内存）
            	3. 整理上 标记整理算法， 两个区域之间则采用 复制 算法
            	4. 并发执行。
            
            原理
            	三个阶段循环：新生代GC --> 新生代GC+并发标记 --> 总体GC -->新生代GC
            
            初始化
            	1.堆被分为了若干区域，每个区域可用于Eden区、幸存区、老年代
            	   当然初始时，都是空的。
            
            新生代GC
            	1. 堆中若干区域被用于Eden、幸存区、老年代
            -------------------------------------------
            |E |    |    |    |老|    |    |    |    |    |幸|    |
            |    |    |幸|    |    |E |    |    |    |    |    |    |
            |    |    |    |    |    |    |    |    |E |    |    |    |
            -------------------------------------------
            	2. 这时 三个 Eden 都满了，就触发 新生代GC
            	如图，可以看到 Eden 区都清理了，幸存对象放入新的幸存区，原先的幸存区也清理后，搬家了
            	老年区多了一个，这是来自 幸存区 中的老年人
            -------------------------------------------
            |    |    |    |    |老|    |    |老|    |    |    |    |
            |    |    |    |    |    |    |    |    |    |    |    |    |
            |    |    |    |    |幸|    |    |    |    |幸|    |    |
            -------------------------------------------
            
            新生代GC+标记
            	1. 默认下，老年代占用45%的区域时，就会发生【新生代GC+标记】
            -------------------------------------------
            |老|老|老|老|老|老|老|老|老|老|老|老|
            |    |E |    |    |    |    |E  |老|老|老|老|老|
            |    |    |E |    |幸|    |    |    |    |幸|    |    |
            -------------------------------------------
            
            FULL GC
            	并发标记时，如果此时堆内存不足，就会触发 FULL GC
            
            
            总体GC
            	发生新生代GC和老年代GC
            	回收一部分的老年代区域，以免垃圾回收暂停时间太长
            	回收了堆顶的 4 个老年代，其中还存活的对象 放到了 左下角
            -------------------------------------------
            |    |    |    |    |老|老|老|老|老|老|老|老|
            |    |E |    |    |    |    |E  |老|老|老|老|老|
            |老|    |E |    |幸|    |    |    |    |幸|    |    |
            -------------------------------------------
            
            注：只要是垃圾回收涉及的区域，都是搬家，即把其中的幸存对象，复制到其他区域"
            - 字符串自动去除
              "因为字符串时不可变对象，所以如果堆中有相同字符串，那就可以集中引用，删除重复的
              
              优点：节约内存
              缺点：占用CPU"
            - 类卸载技术
              "当某个类加载器加载的所有类的所有对象都GC了，那么这些类会集中GC掉"
            - 处理巨型对象
              "占用一个区域以上的对象，称为巨型对象
              因为巨型对象太大，所以不做复制"
          - 关于 minor gc 和 full gc
            "新生代不足时，触发 minor gc
            
            FULL GC
            	串行垃圾回收器、吞吐量优先垃圾回收器，在老年代出现内存不足时，触发FULL GC
            	但是 CMS 和 G1，会提前一个阈值就开始并发标记、回收老年代，所以一般不会出现 FULL GC
            	CMS 和 G1。只有在【并发失败】时。（ 并发标记、并发清除时，如果此时堆内存不足，就会触发 FULL GC——此时会STW
            	因为并发标记 、并发清除时，工作线程还在运行，还会new对象"
      - 类加载和字节码
        - 类文件结构
          "一个 HelloWorld.class 文件
          ClassFile {
              u4             		magic; // 魔数
          		// u4 表示4字节长(32位)
          		// 魔数 0-3 共四个字节。 0xCAFEBABE
          		// 表示这是个 class 文件
          
              u2             		minor_version; // 小版本号
          		// 0x0000 没有使用
          
              u2             		major_version; // 主版本号
          		// 0x0034 -> 52 表示 Java 8
          
              u2             		constant_pool_count; // 常量池大小
          		// 0x0023 -> 35 表示 常量池大小
          		// 但是#0 不计入，直接从 #1 开始到 #34，所以只有34项(35-1)
          
              cp_info        	constant_pool[constant_pool_count-1]; // 常量池
          		// 注意 常量池 是一个不定长表，即其中每一项的大小不定
          		// 每项前 1 字节 是tag，通过 tag 知道这一项是什么（符号引用？字面量？），同时也就知道了这一项的长度
          		// 举例说明：
          		// 0x 0a 0006 0015 从 0a 这个 tag 就知道这是个方法引用，后面会有两个2字节的数据，分别是【方法所属类的符号】【方法名符号】。即 #6 表示类符号引用， #21 表示方法名引用。
          		// 因此 这里出现了 符号表内的跳转。
          		// 0x 09 00 16 00 17 这里 tag=09 ，表示这是个字段引用，后接两个2字节的数据，分别是【字段所属类的符号】【字段名字】。这里也是表内跳转。
          		// 0x 01 0010 。。。。这里 tag=1，表示这是个UTF8编码的字符串，后接2字节表示字符串长度，再往后就是这个串信息。注意tag=1的串一般是类名、方法名...，tag=8的字符串，才是代码中的字符串。
          
          		// 要确定一个方法，需要跳转很多次。首先跳转【方法所在类】，然后跳转【方法】，【方法】再跳转【方法名】和【方法入参/返回值】，最后才知道方法是null java.lang.Object.<init>(null)
          		
          		
          
              u2             		access_flags; // 类访问修饰
          		// 2 字节 16位
          		// 每位表示一个信息
          		// 如 0x0001 ACC_PUBLIC
          		// 如 0x0010 ACC_FINAL
          
              u2             		this_class; // 此类
              u2             		super_class; // 父类
              u2             		interfaces_count; //接口数目
              u2             		interfaces[interfaces_count]; //接口
          		// 以上类信息，都引用到 常量池地址
          
          
              u2             		fields_count; // 字段数目
              field_info     	fields[fields_count]; //字段
          		// 字段也引用到 常量池地址
          
              u2             		methods_count; //方法数目
              method_info    methods[methods_count];  方法
          		// 方法信息除了 引用到 常量池 外，还需要 访问修饰符、方法属性(即方法体)
          		// 方法属性 包括 方法需要栈大小、局部变量信息、字节码、对应的源码行号(用于dubug、异常)
          
              u2             		attributes_count; //附加信息数目
              attribute_info 	attributes[attributes_count]; //附加信息
          		// 一般只有一项：表示这个class文件对应的 Java 源文件的名称 HelloWorld.java
          }
          
          
          简洁版
          ---------------------------------------------
          ClassFile {
              u4             		magic; // 魔数
              u2             		minor_version; // 小版本号
              u2             		major_version; // 主版本号
              u2             		constant_pool_count; // 常量池大小
              cp_info        	constant_pool[constant_pool_count-1]; // 常量池表
              u2             		access_flags; // 类访问修饰
              u2             		this_class; // 此类
              u2             		super_class; // 父类
              u2             		interfaces_count; //接口数目
              u2             		interfaces[interfaces_count]; //接口表
              u2             		fields_count; // 字段数目
              field_info     	fields[fields_count]; //字段表
              u2             		methods_count; //方法数目
              method_info    methods[methods_count];  方法表
              u2             		attributes_count; //附加信息数目
              attribute_info 	attributes[attributes_count]; //附加信息表
          }"
          - 常量池数据结构？
            "不定长表，根据每项的tag才知道这一项的长度"
          - 常量池 确定一个方法需要什么信息
            "方法->类符号位置、方法符号位置
            类符号->全限定类名
            方法符号->方法名位置、方法入参返回值信息位置
            方法名->UTF8串的方法名
            方法入参返回值-> ()V
            
            
            方法所在类的全限定名 ： java.lang.Object
            方法的名字 <init>
            方法的入参、返回值 ()V  —— 表示无参数，void返回值"
          - 常量池 确定一个字段需要什么信息
            "所在类的全限定名
            名字
            类型信息"
          - a/B 和 La/B; 区别
            "a/B 表示类全限定名，即 a.B 这个类
            La/B; 表示对象引用(指针)，是 a.B 的实例对象"
          - a/B.<init>()V 表示？
            "a.B 类的午餐构造器
            V表示 返回值为 void"
        - 字节码指令
          - 实例1 空构造器
            "查看一个空构造器的字节码，是 0x 2a b7 00 01 b1，翻译为
            	2a --> aload_0  加载slot_0到栈顶
            	b7 --> invokespecial 准备方法调用，下文说明具体是哪个
            	00 01 --> 常量池#1 即java/lang/Object.<init>()V 调用Object类的无参构造器
            	b1 --> return 返回"
          - 实例2 sout("Hello, world")
            "查看 sout("Hello, world"); 的字节码  0x b2 00 02 12 03 b6 00 04 b1
            	b2 --> getstatic 加载一个静态变量，下文说明具体是哪个
            	00 02 --> 加载#2表示的静态变量，查表可知为 类型=java/io/PrintStream 名字=java/lang/System.out
            	12 --> ldc 加载一个参数，下文说明具体是哪个
            	03 --> 表示加载#3参数，即"Hello, world"
            	b6 --> invokevirtual 准备调用成员方法（虚函数），下文说明具体是哪个
            	00 04 --> 调用#4的方法，即 java/io/PrintStream.println(Ljava/lang/String;)V
            	b1 --> return"
          - 实例3 变量 运行过程
            "代码
            -------------
            int a = 10;
            int b = Short.MAX_VALUE + 1;  // 编译器优化为 32768
            int c = a + b;
            sout(c);
            
            // short 范围内的整数，直接放在字节码的操作数中
            
            运行过程
            1. 类字节码加载到内存
            2. 类中常量池加载到 运行期常量池 (方法区一分部)
            	#3 Integer 32768
            	#4 Fieldref java/lang/System.out =; Ljava/io/PrintStream;
            	#5 Methodref java/io/PrintStream.printlb()V
            	... ...
            3. 方法区中存放字节码
            	bipush 10 // byte数入栈 10
            	istore 1
            4. 方法运行时，开启栈。栈分为两部分，局部变量表和操作栈(栈每一帧4字节int)"
          - 实例4 i++和i++
            "++ 指令由 iinc 完成，这个在局部变量表完成
            
            i++  先复制到栈，再局部变量表的值+1
            ++i  先 iinc 后复制到栈"
          - 实例5 奇怪的0
            "int i = 0;
            int x = 0;
            while(i<10){
            	i++;
            	x = x++;
            }
            // x=?
            
            -----------------------------
            答：x=0
            因为 x = x++ 执行为
            	1. 0入栈，再进入局部变量表
            	2. 局部变量表0先入栈，然后表中0+1=1
            	3. 栈中0再回到局部变量表
            	4. 所以是 0
            ---------------------------------
            可以看懂的解释
            	int x = 0;
            	int temp = x++;
            	x = temp;
            	//当然x = 0"
          - 实例6 静态变量显示赋值和静态代码块 ==> cinit()V类构造方法
            "static int i = 10;
            static{
            	i = 20;
            }
            
            以上代码会从上到下收集起来，变成一个方法cinit()V
            "
          - 实例7 成员变量显示赋值和代码块 ==> 加入到init()V构造方法中
            "int i = 10;
            {
            	i = 20;
            }
            
            会加入到init()V构造方法中"
          - 实例8 多态实现的原理 ⭐
            "【一句话】类加载阶段生产虚方法表
            
            1. 有对象的klass word找到真实的类（位于方法区）
            2. 这个类中，存在一个虚方法表
            3. 直接调用里面对应的方法就行了
            
            虚方法表
            	在类加载阶段，会动态生成
            	如toString方法，在类中没有重写，但是这个类肯定有toString方法
            	那就沿着继承链往上寻找，找到父类中的toString方法
            	把他的地址放入虚方法表中
            
            	这样动态绑定只发生在类加载阶段，每次方法调用时，不会再发生绑定
            
            	同时说明，一个类加载，必须先要把他的全部父类都加载"
          - 实例9 异常处理原理 catch
            "【一句话】异常表
            
            from    to   target    type
               2       5        8          java/lang/ArithmeticException
               2       5        15        java/lang/Exception
            
            意义：在执行2-5行指令时，若出现异常，且异常是java/lang/ArithmeticException的对象，那么goto 8"
          - 实例9 异常处理原理 finally
            "try{
            
            }catch(){
            
            }
            finall{
            
            }
            
            直接放在代码后面就行了，不管进步进入catch内部，都goto到finally
            "
          - 实例10 i=10; return i;finally{i=20;} 
            "将返回10
            
            原因：会先把10存到另一个slot中，最后再返回10
            相当于
            	i = 10;
            	temp = i;
            	i = 20;
            	return temp;"
          - 实例11 synchronized 如何保证出现异常也解锁？
            "会改造成 try-finally 形式
            出现异常，也会goto到解锁"
          - 具体指令
            - 操作数是数字且short范围内，则和指令一起在方法区，否则需要去常量池取
            - 常数->操作数栈
              - bipush 10 // byte数字10推送至栈顶，宽度补齐4字节
              - sipush n // short数字推送至栈顶，宽度补齐4字节
              - ldc #3 // int数字推送至栈顶，数字来自常量池
              - ldc2_w//long推送至栈顶，占两个栈帧8字节
            - 对象->操作数栈
              - getstatic #4 // 访问#4表示的静态对象，入栈顶
            - 局部变量表->操作数栈 注意这个是复制
              - iload_1 // 将局部变量表1号位置的值推送至栈顶
            - 栈->局部变量表
              - istore 1 //将栈顶int型数值存入局部变量表1号位置
            - 栈->类变量
              - putstatic #1 //为#1表示的类变量复制
                "如 static int i = 10;"
            - 条件跳转
              - ifeq 5 // 如果相等，跳到5
              - goto 5 //无条件跳转到5
            - 计算
              - iadd // 栈顶两个int弹出并相加，结果入栈顶
              - iinc 1,1 // 表示局部变量表1号位以int形式加1
            - 方法调用
              - invokevirtual 动态绑定的方法。调用可重载的方法。
              - invokespecial 静态绑定的方法调用构造方法、私有方法、final方法。
            - 其他
              - return // 方法返回void
              - ireturn // 返回栈顶对象，以int形式
              - checkcast #7 //类型转换为#7的类型
          - 易错点
            - 局部变量表 load 到操作数栈，是复制!!
            - 小问题：静态方法可以被重写吗？
              "答：不可以。但是可以被隐藏
              Father 和 Son 可以都有 静态方法fun
              
              (Son)son.fun() //指行Son中的fun
              (Father)son.fun() // 执行Father的fun"
            - 小问题：try-finally语句 会抛出异常吗？
              "答：会的。只不过try中出现异常后，先执行finally，然后 throw异常"
        - 编译期处理（处理语法糖）
          - 没有构造器时，会自动生产无参构造器 内部是 super()
          - 自动拆装箱
            "Integer x = 1;
            ====>>>
            Integer x = Integer.valueOf(x);
            
            
            int y = x;
            ======>>>
            int y = x.intValue();"
          - 指令中泛型擦除 + 类型转换 （但是局部变量表中还是保留了泛型信息
            "字节码中，不存在泛型，都是Object
            
            String s = stringList.get(0)
            ====>>
            Object temp = stringList.get(0);
            String s = (String)temp;
            
            局部变量类型表
            Ljava/util/list<Ljava/lang/String;>;"
          - 可变参数->数组
            "注意不传参数，则传入一个空数组[]"
          - 数组={1,2,3}
            "new int[]{1,2,3}"
          - foreach
            "如果是 数组，则改成fori循环
            如果实现了 iterable 接口。则改成iterator循环"
          - switch(字符串) 利用hashCode
            "switch(str){
            	case:"abc":
            		sout(str);
            		break;
            }
            
            ===>>>利用hashCode。两个整数的switch
            
            int temp = -1;
            switch(str.hashCode()){
            	case: "abc".hashCode():
            		if(str.equal("abc)){// 在编译器可以知道"abc"的具体的hashCode具体是什么
            			temp = 0;
            		}
            		break;
            }
            
            switch(temp){
            	case:0
            		sout(str);
            		break;
            }"
          - switch(枚举类) 生成临时map<枚举对象,Integer>
          - 枚举类 枚举类的对象即枚举类new的对象
            "emus Sex{MALE, FEMALE}
            
            -------->
            
            public final class Sex extends Enum<Sex>{
            	public static final Sex MALE = new Sex("MALE", 0);
            	public static final Sex FEMALE= new Sex("FEMALE", 0);
            	private static final Sex[] $VALUES$ = {MALE,FEMALE};
            }"
          - try-with-resources
            "try(autocloseable 接口的对象)
            自动转为finally快"
            - 小知识：try-with-resources 中的资源必须是____
              "AutoCloseable 对象"
          - 匿名内部类 会自动产生一个类：外部类名$1
            - 为什么匿名内部类/λ中引用外部对象，必须是final的？ 2020年4月6日我终于懂了
              "因为实际上，生成的类对象，会有一个构造器，构造器包含全部的外部对象，他们被传入构造器中。
              
              int x = 1;
              new Thread(){
              pubilc void run(){sout(i);}
              }
              
              -------------->
              
              class A$1 extends Thread{
              	int x;
              	A$1(int x){this.x = x};
              
              	pubilc void run(){sout(x)};
              }"
        - 类加载阶段 1+1(3)+1
          - 加载
            "类字节码进入内存（元空间）的过程。
            
            会有一个 C++ instanceKlass 对象表示这个 Java 类，这个对象的成员如下
            	_java_mirror // -> 是Java class 和 C++ 的桥梁，双向指针，如String.class 对象可以通过它访问到这里
            	_super // 父类
            	_fields // 成员变量
            	_methods // 方法
            	_constants // 常量池
            	_class_loader // 类加载器
            	_vtable // 虚方法表
            	_itable // 接口方法表
            
            
            关于 _java_mirror
            
            instanceKlass  <--> String.class  <-- “字符串实例”
            位于元空间			位于堆			位于堆
            
            
            如果这个类的父类还没有加载，先加载父类
            
            加载和链接需要交替进行"
            - 知识点 有 虚方法表 和 接口方法表
          - 连接 三个小阶段
            - 验证 验证字节码是不是符合JVM规范
            - 准备 类成员变量开辟空间，设为0 （final可推测的值除外）
              "static变量，存储在 class 对象中，String.class 
              早期 static变量 存储在 永久代
              现在 static变量 存储在 堆中（不是元空间）
              
              注意 准备阶段 还不会给 类成员变量 赋值
              等到了 初始化阶段 ，才会调用 <cinit> 方法，进行复赋值"
              - 知识点：所以访问类的final成员时，不会涉及这个类的初始化
            - 解析 将符号引用解析为指针
          - 初始化 <cinit>方法调用
            "一句话
            	调用<cinit>方法
            	主要是 1. 类对象的显示赋值
            		     2. 执行 static{} 代码块
            
            面试问题：初始化的时机
            	一句话：懒初始化，只有需要用到这个类时才会初始化
            
            不会进行初始化的情况
            	访问 static fianl 基本对象+可推测字符串。
            		只有 static final + 8个基本对象，和 字符串。且编译期可推测值
            	访问 A.class 不会初始化，因为类中符号已经解析了，所以反射过程不需要这个类初始化。
            	创建数组 new A[10] 不会初始化 A
            
            初始化的情况
            	访问 static fianl 引用对象时，会初始化。如 static fianl Integer I = 10; 会初始化，因为底层是 Integer.of(10)
            	访问 非 final 的类对象
            	子类要初始化了，先初始化父类
            	new 对象
            
            关于 Class.forName 
            	这个方法有个参数，可以设置是否初始化这个类
            public static Class<?> forName(String name, boolean initialize, ClassLoader loader)"
            - 问题：初始化线程安全吗？安全的
            - 单例模式 利用类初始化+内部类实现 懒惰
              "class Singleton{
              	privaye Singleton(){}
              
              	private static class LazyHolder{
              		static final Singleton INSTANCE = new Singletion();
              	}
              
              	public staic Singleton get(){
              		return LazyHolder.INSTANCE;
              	}
              
              }
              
              注： 因为类初始化是线程安全的，所以线程安全
              
              因此：关于 懒加载的单例模式，现在有两种方法
              	1. volatile 双重检查锁
              	2. 利用类初始化和内部类"
        - 类加载器 2020年4月11日
          - 类加载器 四等级
            - Bootstrap ClassLoader 无法直接访问
              "负责加载 JAVA_HOME/jre/lib 下的类
              
              String 类由这个类加载器加载
              
              可以自己添加参数，指定类加载器
              -Xbootclasspath/a: ./
              表示把当前目录设为 启动类加载器的加载的类路径，/a表示追加"
            - Extension ClassLoader
              "负责加载 JAVA_HOME/jre/lib/ext 下的类
              
              把jar包放到这个文件夹中，就会由这个类加载器加载"
            - Application ClassLoader
              "负责加载 classpath 下的类"
            - 自定义 ClassLoader
              "想加载那里的东西就加载哪里，只要有byte[]字节码就行"
            - 问题：问什么分级
              "这样如果有不法分子自己造了个java.lang.Object,里面嵌了不好的代码，如果我们是按照双亲委派模型来实现的话，最终加载到JVM中的只会是我们rt.jar里面的东西，也就是这些核心的基础类代码得到了保护。因为这个机制使得系统中只会出现一个java.lang.Object。不会乱套了。你想想如果我们JVM里面有两个Object,那岂不是天下大乱了。"
            - 问题 如果我在自己类中写了java.lang.String 类能默认下使用吗？
              "答：不能。因为这个类的符号是java/lang/String，类加载时，双亲委派，最终bootstrap 类加载器会在 /jre 中加载到自己的 java/lang/String"
          - 双亲委派
            "【双亲委派】
            首先查看类是否被加载。没有则委派上级。（递归）
            因为每个类加载器都有其搜索范围，所以自己不一定能加载。
            当 类加载器要加载某个类时，会委托给上一级，上级不打算加载它，上级再往上委托，当所有上级都不加载这个类时，才会加载
            
            当父加载器无法完成这个请求时，子类才会尝试去加载
            
            因为父类加载器有自己的加载范围，所以有的类不会加载。
            
            1. 子类先委托父类加载
            2. 父类加载器有自己的加载范围，范围内没有找到，则不加载，并返回给子类
            3. 子类在收到父类无法加载的时候，才会自己去加载"
          - 关于JDBC驱动的加载 破坏双亲委派-->下级委派（而不是委派给上级）
            "问题：
            	我们使用的MySQL提供的JDBC实现，可以通过Class.forName("com.mysql.jdbc.Driver");加载，但是不写这条语句，还是可以使用。
            	这是因为Java内部的类 DriverManager 驱动管理器，帮我们加载了 com.mysql.jdbc.Driver
            	问题来了，“DriverManager ” 这个类是 Bootstrap ClassLoader加载的，因此在这个类的内部进行类加载，默认也会使用Bootstrap ClassLoader，但是它找不到com.mysql.jdbc.Driver，只有application classloader才能找到 com.mysql.jdbc.Driver
            	（这里说明一下，在类A中，或类A的对象中进行类B加载时，默认谁加载的类A，就委托给谁加载类B）
            	因此，现在的问题时，我要在Bootstrap ClassLoader加载的DriverManager中，去加载只有application classloader才能找到的类，所以在这类打破双亲委派模式，使用System.getClassLoader() 拿到application classloader 加载。
            "
          - 线程上下文类加载器
            "currentThread.getContextClassLoader
            
            可以手动设置，默认是application classloader"
          - System.getClassLoader() 返回的是？
            "application classloader"
          - 自定义类加载器
            - 使用场景
              "	1. 我想加载不在 classpath下的类
              	2. 我希望同时运行一个类的新旧版本。【钻石依赖】
              	3. 希望单例对象不同。我有个单例C，希望一个模块使用一个C，另一个模块使用不同的C，这样C可以分别有两个状态，或者一个C奔溃后，另一个还可以用。一个tomcat可以同时运行两个web，哪怕里面有同名的类，也不互相干扰。
              
              
              【钻石依赖】
              	一个项目，依赖A和B，但是A依赖 1.0版本的C，B依赖 2.0版本的C，且两个C差别很大，这就麻烦大了。"
            - 热部署原理
              "1. 使用自定义的类加载器加载需要更新的类
              2. 当需要热部署时，先清除JVM中这个类的所有实例对象，然后摧毁这个类加载器，这是它加载的所有类也会卸载
              3. new 新的类加载，加载更新后的类"
            - 问题：自己写类加载器 去除双亲委派 会发生什么
              "会导致，想加载的类，如果其中依赖 /jre 基本类，又还没有被加载，就无法加载他们了。所以不能破坏。"
        - 运行期优化
          - 分层的即时编译 JIT
            "5层次执行
            	0层 解释执行
            	1层 使用C1即时编译器编译执行 不带 profiling
            	2层 使用C1即时编译器编译执行 基本的 profiling
            	3层 使用C1即时编译器编译执行 完全的 profiling
            	4层 使用C2即时编译器编译执行
            
            profiling 指在运行时收集状态数据，如方法调用次数，循环次数
            
            代码执行次数越多，就会升级层次
            
            理论基础：
            	代码中，有些执行次数很少，有的执行次数很多，优化热点代码"
            - JIT 和 解释器区别
              "解释器 读一行字节码，解释为机器码，下次读到，重复解释一遍
              JIT 首先将字节码编译为机器码，存入cache，下次遇到就直接执行
              
              解释器：一般解释成平台通用的机器码
              JIT：平台特定的机器码"
          - 逃逸分析
            "查看代码块{}中new的对象是不是生命周期只在{}内部，如果是的那就出{}就delete
            "
          - 方法内联
          - 字段优化 -->优化成员变量的读写操作
          - 反射的优化
            "前15此反射，由方法访问器实现，性能低
            16次后，动态生产一个对象，包装这个方法，因此性能提升"
      - 内存模型 (注意和内存结构相区别) 2020年4月19日
        "定义一套多线程下读写共享数据时，数据可见性、有序性、原子性的规律和保证"
        - 原子性 -> 锁
        - 可见性 -> volatile
        - 有序性 -> 指令重排
          - happen - before
            "1. 临界区内的写操作，下一个进入临界区的线程一定能读到
            2. 对volatile的写，之后其他线程能读到
            3. 线程启动前的写，这个线程启动后一定能读到
            4. 线程结束了，其他线程知道它结束后，一定能读到这个结束的线程的写。
            	如 t.join()
            5. 线程A打断前的写，线程B得知打断发生了，那么就能读到A线程打断前的读
            6. 对默认值的写，其他线程之后一定能读
            7 happen-before的传递性"
        - CAS 与 原子类
          - CAS 适应场所
            "1. 竞争不激烈
            2. 多核环境"
          - 原子类原理： CAS+volatile
        - synchronized 优化
          "Markword 平时存储 对象的 hashcode 年龄 ...
          加锁后，替换为 标记位、tid、重量级锁指针..."
          - 注意名词：锁升级 × --> 锁膨胀 √
        - 并发的优化
          - 减少锁粒度 --> 把一个锁，分成前后两个锁
          - 锁粗化 -> 循环中加锁 × --> 循环外加锁
            "JVM 对连续的多个 stringbuffer.append(); 会加一个大锁，没必要反复进出
            
            "
          - 锁消除 方法局部对象的锁，不会有竞争，那就消除这个锁
          - 读写分离 copy on write
            "读锁 写锁"
      - JVM参数
        - 空间参数
          - -Xss1024k 栈空间最大大小
          - -Xms5m 堆初始大小
          - -Xmx10m 堆空间最大大小
          - -XX:MaxMetaspaceSize=8m 元空间大小 JDK1.8
          - -XX:MaxPermSize=8m 永久代大小 JDK1.6
          - -XX:StringTableSize=200000 StringTable中hashmap的数组长度20w
            "默认长度6W"
        - GC参数
          - -Xmn 新生代大小
          - -XX:SurvivorRatio=8 幸存区比例（8表示 8份Eden 2份幸存区）
            "可以动态调整"
          - -XX:MaxTenuringThreshold=threshold 晋升阈值(新生代最大年龄)
          - -XX:+ScavengeBeforeFullGC 在FULL GC前进行minor gc
          - -XX:+PrintTenuringDistribution 打印晋升详情（打印每个年龄的对象大小）
          - -XX:PrintGCDetails -verbose:gc 打印GC详细信息
          - -XX:+DisableExplicitGC 禁止显示的调用GC
            "即让System.gc()方法无效
            
            注：System.gc() 若起效，触发的是FULL GC"
          - 垃圾回收器
            - 串行
              - -XX:+UseSerialGC=Serial+SerialOld 串行垃圾回收器
            - 吞吐量优先
              - -XX:+UseParallelGC 新生代并行垃圾回收器
              - -XX:+UseParallelOldGC 老年代并行垃圾回收器
              - -XX:ParallelGCThreads=n 并行垃圾收集器线程数（默认 CPU线程数）
              - -XX:+UseAdaptiveSizePolicy 开启自适应大小调整策略（调整新生代大小、Eden/幸存区比例）
              - -XX:GCTimeRatio=ratio 垃圾回收实际和总时间占比 默认0.01
                "如果垃圾回收占时过多，就会自动增大堆，这样回收频率降低"
              - -XX:MaxGCPauseMillis=ms 最大垃圾回收暂停时长 默认200ms
                "如果暂停时间过长，就会减小堆大小，才能更短时间回收完毕"
            - 响应时间优先 CMS
              - -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
                "这里concurrent表示垃圾回收器标记时，用户线程也同时运行
                响应时间垃圾回收器 仅工作于老年代
                需要配合一个ParNewGC 新生代垃圾回收器"
              - -XX:ParallelThreads=n  -XX:ConcGCThreads=n
                "第一个是重新标记时，线程数目
                第二个是并发标记、并发清理时，线程数目"
              - -XX:CMSInitiatingOccupancyFraction=80
                "老年代内存占用80%时，就会开始GC"
              - -XX:+CMSScavengeBeforeRemark
                "老年代垃圾回收前，先进行一次新生代垃圾回收
                原因：
                	因为新生代的对象可能会引用老年代的对象，所以清理老年代垃圾时，也需要扫描新生代。但是新生代小对象很对，所以扫描时间长，很可能有些新生代对象虽然引用了老年代对象，但是自己已经无用了，所以先进行一次新生代垃圾回收，这样新生代数目少了，老年代GC时，就不用扫描太对的对象了"
            - G1
              - -XX:+UseG1GC
              - -XX:G1HeapRegionSize=size
              - -XX:MaxGCPauseMillis=time
              - -XX:+UseStringDeduplication 字符串自动去除
        - -XX:PrintStringTableStatistics 打印StringTable统计信息 个数/大小
      - 诊断/调优
        - 相关工具
          - javap -v xxx.class 反编译
          - jps 显示当前系统中所有Java进程
          - jmap 查看堆内存占用(快照)
            "实际命令是：jhsdb jmap --heap --pid 6136
            
            -------------------------------------
            Attaching to process ID 6136, please wait...
            Debugger attached successfully.
            Server compiler detected.
            JVM version is 13.0.2+8
            
            using thread-local object allocation.
            Garbage-First (G1) GC with 13 thread(s)
            
            Heap Configuration: // 堆配置信息
               MinHeapFreeRatio         = 40
               MaxHeapFreeRatio         = 70
               MaxHeapSize              = 6442450944 (6144.0MB)
               NewSize                  = 1363144 (1.2999954223632812MB)
               MaxNewSize               = 3865051136 (3686.0MB) //新生代
               OldSize                  = 5452592 (5.1999969482421875MB) //老年代
               NewRatio                 = 2
               SurvivorRatio            = 8
               MetaspaceSize            = 21807104 (20.796875MB)
               CompressedClassSpaceSize = 1073741824 (1024.0MB)
               MaxMetaspaceSize         = 17592186044415 MB
               G1HeapRegionSize         = 1048576 (1.0MB)
            
            Heap Usage:
            G1 Heap:
               regions  = 6144
               capacity = 6442450944 (6144.0MB)
               used     = 31930256 (30.451065063476562MB)
               free     = 6410520688 (6113.548934936523MB)
               0.49562280376752216% used
            G1 Young Generation:
            Eden Space: // 新创建的对象所在空间
               regions  = 3
               capacity = 31457280 (30.0MB)
               used     = 3145728 (3.0MB)
               free     = 28311552 (27.0MB)
               10.0% used
            Survivor Space:
               regions  = 1
               capacity = 2097152 (2.0MB)
               used     = 1134992 (1.0824127197265625MB)
               free     = 962160 (0.9175872802734375MB)
               54.120635986328125% used
            G1 Old Generation:
               regions  = 27
               capacity = 44040192 (42.0MB)
               used     = 27649536 (26.36865234375MB)
               free     = 16390656 (15.63134765625MB)
               62.782505580357146% used"
          - jstack pid 查看所有线程及trace
          - jconsole 图形化多功能测试工具
            - 可以立即执行GC
          - jvisualvm 图像化
          - Memory Analyzer (MAT) 堆分析
            "先 jmap 抓取内存快照，然后 MAT 利用快照分析
            
            jmap -dump:format=b,live,file=1.bin pid"
          - javap 反编译class文件为可读的治疗 (不是反编译到Java文件)
          - HSDB 内存中对象信息
          - arthas-boot 
            "https://gitee.com/arthas/arthas"
        - 线程运行诊断
          - 案例1 CPU占用过多
            - Linux下执行 某个Java程序，发现CPU占用99
            - 利用 TOP 定位到这个Java程序的 PID
            - ps H -eo pid,tid,%cpu | grep PID 定位到TID
              "可以查看进程PID下的线程信息，定位到占用CPU的线程tid"
            - jstack PID 找到有问题的线程以及它正在干嘛
              "可以列出Java程序PID下的所有线程
              包括每个线程的状态（runnable、waiting）、方法栈
              
              ---------------------------------------------
              "http-nio-2234-exec-10" #80 daemon prio=5 os_prio=0 cpu=0.00ms elapsed=18275.15s tid=0x000001e806a15000 nid=0x4440 waiting on condition  [0x000000832fafe000]
                 java.lang.Thread.State: WAITING (parking)
                      at jdk.internal.misc.Unsafe.park(java.base@13.0.2/Native Method)
                      - parking to wait for  <0x0000000680de30a8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
                      at java.util.concurrent.locks.LockSupport.park(java.base@13.0.2/LockSupport.java:194)
                      at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(java.base@13.0.2/AbstractQueuedSynchronizer.java:2081)
                      at java.util.concurrent.LinkedBlockingQueue.take(java.base@13.0.2/LinkedBlockingQueue.java:433)
                      at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:107)
                      at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33)
                      at java.util.concurrent.ThreadPoolExecutor.getTask(java.base@13.0.2/ThreadPoolExecutor.java:1054)
                      at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@13.0.2/ThreadPoolExecutor.java:1114)
                      at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@13.0.2/ThreadPoolExecutor.java:628)
                      at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
                      at java.lang.Thread.run(java.base@13.0.2/Thread.java:830)
              ----------------------------------------
              
              可惜线程的tid显示为十六进制，和ps命令的十进制不同"
          - 案例2 死锁问题 deadlock
            - jstack PID 可以显示java-level deadlock
        - 堆空间诊断 2020年4月27日
          - 案例1 多次GC 后内存占用仍然很高
            - 查看jmsp 老年代空间占用很大
            - jconsole 执行GC 老年代内存占用仍然很高
            - jvisualvm 堆转储 dump 即堆快照 然后可以分析其中的对象
        - StringTable调优
          - 基本思路：增大hashMap桶的个数，较少hash冲突
            "桶就是hashmap中数组长度"
          - 即修改 -XX:StringTableSize=200000
            "stringTable 中hashmap的数组长度20w"
        - 垃圾回收调优
          - 知识点
            - 官方手册 https://docs.oracle.com/en/java/javase/11/gctuning/index.html
            - 预备知识
              "1. 掌握 VM 参数，会基本的空间调整
              2. 相关工具
              3. 明白具体应用，具体参数，没有绝对正确的法则"
            - 调优领域
              "内存
              锁竞争
              CPU
              IO"
            - 确定目标
              "低延迟？
              	互联网项目 CMS G1 ZGC
              高吞吐量？
              	科研项目 parallelGC
              
              "
            - 最快的GC是不发生GC
              "最先考虑的是 Java 代码是不是写得不好
              
              数据太多？
              对象太臃肿？
              	需要什么，就查SQL
              内存泄漏？
              	缓存不过期？"
            - 新生代调优
              - 新生代过小 频繁 minor gc
              - 新生代过大 每次 minor gc 花费时间会增长
              - 新生代占堆内存多少为宜？ 25%-50%
              - minor gc 中最占时间的是复制过程。标记过程不占多少时间
              - 新生代内存设置——能容纳 并发量*请求响应所需数据
                "例如 一次请求响应需要512k内存
                并发量1000
                则新生代设置为 512Mb"
              - 幸存区内存设置——能保留当前活跃对象+需要晋升的对象
                "幸存区一般有两类对象
                	短命的，可能下次GC就会被回收
                	长寿的，等着去老年代
                
                幸存区应该要容量 这两个对象"
              - 幸存区过小？——【晋升阈值降低】会导致短命对象进入了老年代
              - 晋升阈值过大？——导致长寿对象在幸存区中复制来复制去，耗时长
            - 老年代调优 以CMS为例
              - 优先调新生代，不行再调老年代
              - 若发生FULL GC，看看是不是老年代内存不足引起的
                "因为 CMS 并发标记时，若出现内存不足，就会强行 FULL GC，不一定是老年代内存不足"
              - CMS 可以调整发生 老年代垃圾回收 阈值，以免并发标记时内存不足，导致FULL GC
                "-XX:CMSInitiatingOccupancyFraction=0？"
              - FULL GC 可以避免吗？——使用 CMS G1 作为回收器，是可以避免 FULL GC 的
              - 老年代的对象只有FULL GC才会被回收吗？——以前是的，使用CMS G1的话，会提前标记回收
          - 案例1 FULL GC 和 MINOR GC 频繁
            - 先增大新生代内存
            - 增大晋升阈值，让对象尽可能留在新生代
          - 案例2 请求高峰期出现 FULL GC 且暂停时间长（使用的是CMS垃圾回收器）
            - 查看【初始标记】【并发标记】【重新标记】【并发收集】每个阶段耗时
            - 发现【重新标记】耗时2s以上
              "注意：重新标记时，会扫描整个堆内存"
            - 设定在重新标记前，先进行minor gc，这样【重新标记】耗时300ms
              "-XX:+CMSScavengeBeforeRemark"
          - 案例3 老年代充裕情况下，发生FULL GC（使用的是CSM JDK1.7）
            - 没有发生并发失败
            - 发现是永久代空间不足，导致的FULL GC
  - Java 1.8 新特性
    - lambda 表达式
      - 定义 lambda 匿名函数
        "函数象数据一样传递"
      - 新的操作符 ->
    - 函数式接口
      - consumer
      - supplier
      - function
      - predicate
    - 方法引用 构造器引用
      - 对象::实例方法
      - 类::静态方法
      - 类::实例方法!!!
        "当lambda表达式是 (a,b)->a.fun(b)时
        或者是 a->a.fun()
        可以写成 A:fun
        
        其中 a 时 类A的实例
        fun(B b)方法是 类A 的成员方法
        
        这样执行时，第一个参数，即a，即fun方法的调用者，第二个参数是实例方法fun的入参。
        
        相当于A.fun(this)//A.fun(this,b)"
    - Stream
      - 特点：不存储对象、不改变对象，除非调用终止方法
      - 创建无限流
        - Stream.iterate(seed, function)
        - Stream.generate(suppiler)
      - 流操作
        - 中间操作
          - 选择
            - 过滤 filter
            - 截断 limit
            - 跳过 skip
            - 去重 distinct
          - 隐射
            - map
            - flatMap 每个元素转成流，然后拼接流
          - 排序 sorted
        - 终止操作
          - 匹配
            - allMatch
            - anyMatch
            - noneMatch
          - 查找
            - findFirst
            - findAny
            - min
            - max
          - 计数 count
          - 规约 reduce(起始值, (ret, next)->fun(r,n))
            "ret 反复计算的值
            e 下一个元素
            
            reduce(0, (x,y)->x+y);
            
            "
          - 收集 collect(收集器)
            "collectors 提供了很多收集器
            
            Collectors.toList
            Collectors.toSet
            Collectors.toCollention(HashSet::new)  //学到了，我还写完整的收集器干嘛呢"
          - 分组 collect(收集器) ->map
            "collect(Collectors.groupBy(A:x))"
          - 多级分组 ->map
            "collect(Collectors.groupBy(A:x, Collectors.groupBy(A:y)))"
          - 分区 ->map<boolean,obj>
            "collect(Collectors.partitioningBy(Predictor))"
          - 连接
            "collect(Collectors.join(", ","[","]")) //太牛逼了"
      - 平行流
        - Fork/Join 框架
          "有必要的情况下，把大任务拆分成小任务，完成后再汇总
          
          fork 分解任务
          压入线程队列，有几个核心就有几个线程队列
          join 合并结果
          
          工作窃取
          	某个线程队列空了，就回去其他的队列中“偷”任务
          目的：更好的提高效率
          
          recursive 递归的"
        - 开启并行流 parallel()
        - 关闭并行流 sequential()
    - 接口中 默认(成员)方法 静态方法
      - 方法冲突问题 -- 多重继承
        "1. 类优先
        接口I中有默认方法fun
        类A中也有方法fun
        
        则 class B extend A implement I{}
        B中的fun方法会使用类A的fun方法
        
        2. 没有类时，需要手动指定"
    - 新的日期时间API
      - 回顾 Date类 Clender类 TimeZone类 线程不安全
      - LocalDate LocalTime LocalDateTime 人可读的时间类
        "不可变类 不包含时区信息"
      - Instant 时间戳 1970.1.1过的毫秒数
      - Duration 计算时间间隔
      - Period 计算日期间隔
      - OffsetTime 日期偏移计算
      - java.time.chrono 包 时间格式包
        "日语时间格式 年号
        台湾时间格式
        伊斯兰时间格式"
      - java.time.format 格式化包
      - java.time.temporal 时间运算包
        "下个周日是哪天？下一年还有几天？..."
      - java.time.zone 时区
    - others
      - HashMap
        "数组中的是什么？
        	Entry
        
        默认数组长度？
        	16
        
        hash冲突
        	1.8前 使用链表
        	1.8后 当前链表个数>8时，map容量>64时，采用红黑树代替链表
        	红黑树内容：按key-hashcode值排列
        	坏处：添加效率降低（其他效率提高）
        
        加载因子 0.75
        	元素个数达到数组长度0.75时，扩容 rehash"
      - concurrentHashMap
        "JDK 1.7 分段加锁
        	默认并发级别 16
        
        JDK 1.8 改成 CAS 无锁算法
        	无锁添加技术"
      - 方法区 永久代->元空间
        "方法区内容：核心类库、...
        
        其实JDK1.7的时候，除了hotspotJVM，其他JVM早就没有永久代了"
      - 减少空指针异常的 Optional<T>类
      - 注解的改进
        - 可重复注解
          "一个地方可以使用相同的注解
          如
          
          @Anno(1)
          @Anno(2)
          public class A{}"
        - 类型注解
          "可以用在 field 上，如 方法入参
          e.g. spring restFUL 方法"
  - 多线程/并发
    - Java高并发程序设计 葛一鸣
      - 第一章 走入并行世界 ANKIED
        - 基本概念
          - 同步 & 异步
            "背景：一个线程进行一次方法调用
            
            同步：调用后，线程需要等待，只到返回
            
            异步：调用后立即返回void，自己可以做其他的事，方法结束后通知自己"
          - 并发 & 并行
          - 阻塞 & 非阻塞
            "背景：线程间相互影响
            
            阻塞：线程行为会导致另一个线程被挂起
            
            非阻塞：线程间相互影响但是大家都不会被挂起"
          - 临界区：公共资源/线程独占
          - 死锁 & 饥饿 & 活锁
            "死锁： 一组相关线程，循环等待
            
            饥饿：线程无法获得资源，导致一直阻塞。
            	原因：1.优先级过低，2.别人不释放资源
            
            活锁：线程相互影响而无法顺利执行
            	和死锁的区别：
            		1. 线程没有阻塞，因此活锁消耗CPU。
            		2. 一段时间后活锁可能被解开
            	比喻：出入电梯，我让左边，对方也让左边，我让右边，对方也让右边。
            	举例：线程执行需要a、b资源，两个线程轮流释放、占用资源，导致两者都无法执行。"
          - Amdahl 定律：加速比=单线程耗时/多线程耗时
        - Java 基本概念
          - 原子性
            "所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 
            
            注意：和数据库的原子性不同。"
          - 可见性
            "当一个线程需改了某个共享变量的值后，另一个变量是否能立即知道这个修改"
          - 有序性
            "指令重排保证__（串行语义的一致性）
            
            乱序原因：不想让流水线中断"
      - 第二章 Java并行程序基础界 ANKIED
        - 并发操作HashMap可能造成死循环？
          "使得，链表成环了"
      - 第三章 Java并发包界 ANKIED
        - Semaphore类
          "信号量 可以让一个临界区最多几个线程进入"
        - CountDownLatch类
          "倒计时器
          
          countDownLatch.countDown(); 让值减一
          
          countDownLatch.await(); 等待，只到值为0"
        - LockSupport 线程阻塞工具类
          - ⭐ park/unpark与suspend/resume 区别
            - 相同点 都是阻塞/启动
            - 不同点 resume必须在suspend之后调用才能重启线程，而unpark不必，即unpark给线程一个许可：它可以park时查看许可，若有则不挂起
            - 知识点 线程suspend 后状态是 —— RUNNABLE
            - 姿势点 线程park后状态是 —— WAITING
            - park() 可以被中断唤醒吗？——可以。不抛出异常，直接返回（返回==继续运行），可以查看中断标记
        - 线程池
          - 创建线程池时，workQueue可以是？——无界、有界、优先队列
          - 线程池多大为好？CPU核心*等待时间/计算时间
          - 默认线程池的隐秘弊端——异常追踪
            - 问题：线程池中任务出现异常时，1可能不会抛出异常，2.无法追踪到任务是在哪里放入线程的
            - 解决办法：对放入线程池的任务包装一下，包装时记录当前栈信息，再用try块包裹任务，出现异常就抛出、并打印栈信息
        - fork/join 框架 任务-拆分成子任务-结果归并
        - 并发容器
          - 并发容器有三大类
            - 早期的Vector hashtable
            - 集合框架中 collections 工具类可以把集合包装成线程安全的
            - 并发包下的并发容器 —— 性能最好
          - ConcurrentHashMap 线程安全map
          - CopyOnWriteArrayList 优于Vector
            "适用于读多写少"
            - 原理：读不加锁、写时加锁并复制array，写完后再设回去
          - ConcurrentLinkedQueue 并发的链表队列
            "没有锁、链表每个节点都是CAS操作"
            - t != (t=tail) // 已知 tail 是共享变量
              "首先 t 放入寄存器1号位
              然后 tail 放入 2号位
              比较
              然后2号位作为 t 地址
              
              中途第1步后可能会被打断，tail被改写"
            - t != t 字节码
              "t入操作栈、t再入栈、对栈顶两元素ne判断"
          - BlockingQueue 阻塞队列接口（有数组、链表的实现）
            - 线程间消息传递，最希望什么？—— 解耦。线程间不直接通讯，而是使用消息队列
            - offer方法加入元素 满了会直接返回false
            - put方法加入元素，满了会等待
            - poll方法取元素，空返回null
            - take方法取元素，空会等待
            - 以上等待的实现原理：加入元素成功就发信号
          - ConcurrentSkipLiskMap 跳表map
            - redis和jdk中都有跳表呢
            - 和hashmap不同：遍历元素是有序的
        - 附录：性能测试工具 JMH
      - 第四章 锁的优化及注意事项
    - JDK 锁 源码阅读
      - AbstractOwnableSynchronizer
        "可以由线程以独占方式拥有的同步器。本身不提供功能，仅仅有线程的getter/setter方法，用于监控一些信息，提供诊断"
        - transient Thread exclusiveOwnerThread 字段，注意无volatile
          "独占模式的同步器 的所有者"
        - init() 空构造器
        - void setExclusiveOwnerThread(Thread thread) setter方法
        - Thread getExclusiveOwnerThread() getter方法
      - AbstractQueuedSynchronizer extn AbstractOwnableSynchronizer
        "维持一个先入先出等待队列，是阻塞锁、同步器的框架。
        使用单个 int 值表示状态，提供相关的 getter/setter/cas 方法
        子类：定义更改状态的方法，同时定义哪种状态对应获取、还是释放即可。
        子类应该是一个私密内部类。
        
        支持独占模式和共享模式。"
        - 最简单的使用方法
          "class Mutex implements Lock, java.io.Serializable {
          
              // Our internal helper class
              private static class Sync extends AbstractQueuedSynchronizer {
                // Report whether in locked state
                protected boolean isHeldExclusively() { 
                  return getState() == 1; 
                }
          
                // Acquire the lock if state is zero
                public boolean tryAcquire(int acquires) {
                  assert acquires == 1; // Otherwise unused
                 if (compareAndSetState(0, 1)) {
                   setExclusiveOwnerThread(Thread.currentThread());
                   return true;
                 }
                 return false;
                }
          
                // Release the lock by setting state to zero
                protected boolean tryRelease(int releases) {
                  assert releases == 1; // Otherwise unused
                  if (getState() == 0) throw new IllegalMonitorStateException();
                  setExclusiveOwnerThread(null);
                  setState(0);
                  return true;
                }
                 
                // Provide a Condition
                Condition newCondition() { return new ConditionObject(); }
          
                // Deserialize properly
                private void readObject(ObjectInputStream s) 
                  throws IOException, ClassNotFoundException {
                  s.defaultReadObject();
                  setState(0); // reset to unlocked state
                }
              }
          
              // The sync object does all the hard work. We just forward to it.
              private final Sync sync = new Sync();
          
              public void lock()                { sync.acquire(1); }
              public boolean tryLock()          { return sync.tryAcquire(1); }
              public void unlock()              { sync.release(1); }
              public Condition newCondition()   { return sync.newCondition(); }
              public boolean isLocked()         { return sync.isHeldExclusively(); }
              public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
              public void lockInterruptibly() throws InterruptedException { 
                sync.acquireInterruptibly(1);
              }
              public boolean tryLock(long timeout, TimeUnit unit) 
                  throws InterruptedException {
                return sync.tryAcquireNanos(1, unit.toNanos(timeout));
              }
           }"
        - init() 空构造器，protected
        - 内部类 Node
          - 成员字段
            - volatile int waitStatus; // 简称 ws
            - volatile Node prev;
            - volatile Node next;
            - volatile Thread thread;
            - Node nextWaiter; // 没有volatile，用于条件等待队列
          - 类字段
            - Node SHARED = new Node()
              "标记之暗示节点等待于分享模式者"
            - Node EXCLUSIVE = null
            - 四个ws状态
              - int CANCELLED = 1; //暗示线程被取消了
              - int SIGNAL = -1; //暗示线程需要唤醒
              - int CONDITION = -2; //暗示线程等待于条件上
              - int PROPAGATE = -3; //暗示下次共享模式的获取需要无条件传播
              - ws < 0 说明节点需要信号
          - 成员方法
            - init() // 空构造器
            - init(Node nextWaiter) //设置nextWaiter的构造器，同时thread=cur
            - init(int waitStatus) // 设置waitStatus的构造器，同时thread=cur
            - isShared() = nextWaiter == SHARED; // 是否处于共享模式
            - Node predecessor() = prev; // 获取前驱
              "就是 return this.prev 只不过判空，会抛出空指针异常"
            - compareAndSetWaitStatus(int expect, int update) //cas waitStatus
            - compareAndSetNext(expect,next) //cas next
            - setPrevRelaxed(prev) // 直接设置prev
        - 类字段
          - SPIN_FOR_TIMEOUT_THRESHOLD = 1000L
            "1ms内使用自旋，大于1ms用 timed park"
        - 成员字段
          - transient volatile Node head //头
            "大概是假头，队列初始化时 head = new Node()"
          - transient volatile Node tail // 尾
            "tail 是存信息的，不是假的。因此有时判断 tail.ws 状态
            队列为空时，tail = head
            队列的遍历一般从尾巴开始，即利用 "
          - volatile int state // 同步器的状态
        - 工具方法（简答方法、不涉及队列操作）
          - boolean parkAndCheckInterrupt() //返回true表示线程是被打断唤醒的，否则是被unpark唤醒的
            "park(); // park 自己
            return Thread.interrupted();"
          - static void selfInterrupt() == Thread.currentThread().interrupt();
        - 成员方法
          - setter/getter/cas
            - getState() = state // volatile 读
            - setState(int newState) // volatile 写
            - compareAndSetState(int expect, int update) // cas state
            - compareAndSetTail(Node expect, Node update)// cas tail
            - setHead(Node node) // 设置头
              "head = node; //volatile 写，不cas
              node.thread = null
              node.prev = null"
          - 队列操作
            - initializeSyncQueue() //初始化队列
              "head = new Node(); tail = head;
              
              调用此方法的方法：
              Node enq(Node node)
              Node addWaiter(Node mode)"
            - Node enq(Node node) = oldTail //入队
              "返回旧尾巴，node.prev = tail; tail.next = node; tail = node;
              若队列没有初始化，先initializeSyncQueue()
              入队使用 CAS 实现
              "
            - Node addWaiter(Node mode) = new Node(mode); // 新建一个node，然后入队
              "Node node = new Node(mode); enq(node); return node;
              
              这个 node 属性：
              next = prev = null;
              nextWaiter = mode;
              thread = invoker;
              "
            - unparkSuccessor(Node node) // 唤醒 unpark(node.next.thread)
              "if(node.ws<0) node.ws = 0; // 看不懂。ws 是负数，说明需要信号，那就把 node.ws 设为 0 ，表示他不需要信号
              // 我大概懂了，当要唤醒node的后继时，说明 node 已经被唤醒了，他自己没有必要被别人唤醒，如果看到 node.ws <0 ，很可能是别人乱改的
              
              // 下面的算法是找到 node 的后继
              没有出问题，那就是 node.next
              但是如果 node.next ==null || node.next.ws>0，即 next 为空，或者不需要信号
              那就从尾巴 tail 往前找，利用 prev 字段往前遍历队列
              寻找 ws<=0 的元素，即需要信号的元素
              找到了不 break，继续查找，直到找到自己为止，这样的目的明显是想找到离自己最近的、需要信号的后继
              为什么不从自己往后寻找，而是从 tail 往前寻找，网友：因为 node.next 可能是 null，这样就无法往后搜索
              
              找到之后 unpark(需要信号的最近的后继.thread)
              
              调用此方法的方法：
              doReleaseShared()"
            - doReleaseShared() // 共享模式下的释放
              "无并发流程：head.ws=0;unparkSuccessor(head);
              
              在这个函数中，需要对头进行多次操作(整体没有原子性的)，为了防止两次操作中 head 被别人修改了，首先用局部变量 h 缓存 head，等多个操作完成后，再检查 h==head?，如果不成立，则重来（有点像乐观锁）（同时也减少访问volatile变量的次数）
              
              流程一：
              	如果 head.ws == SIGNAL，说明 head 的后继需要被唤醒
              	那么首先 CAS head.ws->0
              	成功后 unparkSuccessor(head)
              	结束
              流程二：
              	如果 head.ws == 0，CAS head.cas->PROPAGATE
              	成功后结束
              
              for(;;) // 死循环 ，内有两个 CAS
              〇 h = head // 拿到头
              ① if(h.ws == SIGNAL) CAS(h.ws->0)
              ② unparkSuccessor(h) // 唤醒 head 的后继
              ③ else if(h.ws == 0) CAS(h.ws->PROPAGATE)
              ④ if(h==head) break;
              
              调用方法：
              unparkSuccessor(h);
              调用此方法的方法
              setHeadAndPropagate(Node node, int propagate)"
            - setHeadAndPropagate(Node node, int propagate) //设置头节点，并进行传播
              "无并发：head=node; if(propagate>0) doReleaseShared();
              
              1  h = head; // 缓存旧头（有可能为空）
              2 setHead(node); // 无条件把 node 设为头
              3. 如有需要**，调用 doReleaseShared();
              
              ** 何谓需要？
              以下4种情况满足1种
              propagate > 0 // 调用者明确指出需要传播
              h == null // 旧头为空，这是什么情况才会出现的呢？
              h.ws < 0 //doReleaseShared() 方法中，如果头.ws==0，就会CAS为PROPAGATE(-3)，但是在哪个方法中没有进行唤醒动作，看来在这里唤醒了
              (h=head) == null // 新头为空？
              h.ws < 0 // 新头ws<0，大概情况和 旧头.ws<0 相同
              以下2种情况满足1种
              node.next == null // 没有并发下，node就是新头。新头无后继，毕竟 next 不可靠
              node.next.isShared() // s 等待于共享模式。s.nextWaiter == SHARED;
              
              
              调用方法
              doReleaseShared();"
            - cancelAcquire(Node node)  // 取消一个正在 acquire 的尝试
              "即把node踢出队列（我看了下，好像踢人的操作都是尝试性的，有人干扰就不踢）
              
              注意：shouldParkAfterFailedAcquire 这个方法也会尝试把ws>0的踢出队列
              
              0  node.ws = CANCELLED; // 无条件把自己的ws设为取消(1)
              	其实这么做就够了，因为在唤醒的时候，后继不需要信号，就会从尾巴遍历
              	下面旨在尝试性的把队列种不需要信号的人踢出去，CAS没成功就算了
              
              1  从 node 往前搜索（利用 prev 字段，这个字段是可靠的），如果前面人的ws>0，说明不需要信号，那就也把他踢了，直到找到一个ws<=0的，这个人缓存为pred。
              
              2  node.prev = pred; // 让node前驱为pred，这样踢掉了一些在node前面、且不需要信号的人
              
              3 if(node=tail) // 如果 node 就是尾巴，那就简单了
              	3.1 tryCAS  tail->pred // pred 就变成了尾巴
              	3.2 if(3.1) tryCAS pred.next->null // pred 后继设为 null
              	方法结束
              	注意：3.1 和 3.2 都是tryCAS，失败就算了，烂摊子交给后人解决
              	注意：3.2 需要在 3.1 的 tryCAS 后进行
              	很明显，是为了减少竞争 
              
              4 esle // node 不是尾巴，说明node有后继
              	如果前面有人需要信号，且没有人在动 pred*，那node只试试**踢人 tryCAS pred.next = node.next
              	否则这个方法有义务唤醒node后面的人 unparkSuccessor(node);
              	
              
              * 如果前面有人需要信号，且没有人在动 pred，需要满足以下三个条件
              	1. pred 不是头节点
              	2. pred 需要信号
              	3. 没有人在操作pred，因为如果有人在动 pred，那么 pred 有可能出队列了（情况一：变成旧头了，情况二：被提出去了），这时 pred.next = node.next ，会导致队伍排到一个错误的地方，引发巨大问题!!
              
              	pred != head // pred 不是头，因为头是假的，所以pred是头，那就完了，说明node前面没人需要被唤醒了，node自己有义务唤醒后面的人
              	pred.ws==SIGNAL 或 pred.ws<0 && tryCAS pred.ws-> SIGNAL // pred需要信号SIGNAL，或者pred需要广义的信号，且可以 tryCAS 为SIGNAL（如果 try CAS失败，说明有人在操作pred）
              	pred.thread != null // pred 线程空，说明有人动了手脚？
              
              ** 只试试踢人，指的是
              	node.next != null && node.next.ws<=0 才会 try 踢人
              	也就是说如果 node 后继无人，说明遇到了竞争，很可能 node 被人设为 tail了
              	如果 node 后继不需要信号，那踢人工作也不进行，这是遇到了竞争呢？还是把踢人的工作委托给后人呢？不得而知
              	最后，踢人也是一个 tryCAS，失败则表示有人在操作 pred，那就不管理，减少竞争
              
              
              
              "
          - acquire 系列（看到这里开始爽起来）
            - acquireQueued(node, arg) // 在队列中等待，是一个阻塞方法
              "一般是不公平的 tryAcquire(arg) 失败后，就会把当前线程入队，addWaiter(Node.EXCLUSIVE)成为队列尾巴，然后调用此方法。
              
              这个方法返回值是“在此方法过程中（即等待过程中），是否发生了中断”
              方法的工作流程如下
              
              	1.  判断自己的前驱是不是 head 头，如果是的，则说明自己是排第一的了
              	2. 但是此时不能直接拿到 this 对象，还需要 tryAcquire(arg) 一次，因为可能会和非公平抢锁的人竞争。总之，当自己是第一名是，自旋抢锁 tryAcquire(arg)，相信自己一定能抢成功
              	3.  抢成功后，自己变成头 head = node
              	4. 返回等待中是否被打断
              
              	5. 如果自己前驱不是头，那就 park 休息吧
              	6. 调用 shouldParkAfterFailedAcquire 方法，他会判断我是不是需要休息，同时会踢出一些在队伍中不需要信号的人
              	7. 如果我需要休息，调用 parkAndCheckInterrupt 进入睡眠，这个方法返回值为我是否有中断标记（本身 park 也可能被意外中断唤醒）
              
              	8 最后，以上步骤中如果有异常，调用 cancelAcquire(node)，把自己踢出去
              
              
              final boolean acquireQueued(final Node node, int arg) {
                  // node 一般来自 addWaiter(Node.EXCLUSIVE)
                  // 所以执行方法的线程 ，就是 node.thread (assert node.thread == Thread.currentThread();)
              
                  boolean interrupted = false;
                  try {
                      for (; ; ) {
              
                          // 即等于 p = node.prev ，但是判空
                          final Node p = node.predecessor(); // throw new NullPointerException();
              
                          if (p == head && // p 是头
                                  // 为什么需要是头？ 因为只有自己的前驱是头的时候，才说明下一个执行的人是我
              
              
                                  // 需要重写的方法，一般核心是 return compareAndSetState(0, acquires)
                                  // 最简单的实现：
                                  //                tryAcquire(arg)  ：
                                  //        // *       if (compareAndSetState(0, 1)) {
                                  //        // *         setExclusiveOwnerThread(Thread.currentThread());
                                  //        // *         return true;
                                  //        // *       }
                                  //        // *       return false;
                                  tryAcquire(arg) // 自己是排第一个了，还是得竞争啊，可怜啊，还有插队的
                          ) {
                              // 自己变成头
                              setHead(node);
                              p.next = null; // help GC
              
              
                              return interrupted; // 这里的 interrupted 仅仅是给别人看排队中有没有被打断过，因为 parkAndCheckInterrupt 会移除中断标记
                          }
                          if (shouldParkAfterFailedAcquire(p, node)) // 是否需要 park ，这里面会踢人!!!!
                              interrupted |= parkAndCheckInterrupt(); // 需要则 park
                          // ········  注意 parkAndCheckInterrupt() ，这个方法内部是 park(); return Thread.interrupted();
                          // 即 park 被唤醒后，会检查中断位，内部调用的是 interrupted，因此会去除中断标记
                      }
              
                      // 问题：这里能 catch 到哪些异常？
                      // 第一个 node.predecessor(); 抛出 NullPointerException ，表示这个节点没有前驱。这简直是不可能的事情
                      // 第二个 tryAcquire(arg) 被写后，可以抛出任何运行期异常，在哪个方法注释中，一般推荐是 IllegalMonitorStateException
                      // 最后 tryAcquire 没有被重写，抛出 UnsupportedOperationException
                  } catch (Throwable t) {
                      // node 踢出队列
                      // 等等，需要踢出队列，潜台词是，node已经在队伍中了
                      cancelAcquire(node);
                      if (interrupted)
                          // 又打断？
                          // 答：是的，因为 interrupted == true ，意味着 parkAndCheckInterrupt() 返回了 true
                          // 而 parkAndCheckInterrupt 方法检查中断位用的是 interrupted，会移除中断标记
                          // 重新打标记
                          selfInterrupt();
              
                      // 异常抛出去
                      throw t; // NullPointerException  IllegalMonitorStateException  UnsupportedOperationException
                  }
              "
            - 其他的 doAcquireInterruptibly / doAcquireNanos 类似，核心方法是自己排第一后抢锁tryAcquire(arg) 然后 setHead(node);
            - 共享模式的 doAcquireShared / doAcquireSharedInterruptibly / doAcquireSharedNanos ，核心流程是“自己排第一后，tryAcquireShared(arg)抢锁，成功后setHeadAndPropagate(node, r)”
        - 静态方法
          - boolean shouldParkAfterFailedAcquire(Node pred, Node node) // acquire失败后应该park node吗?
            "核心代码 return pred.ws==SIGNAL
            
            如果没有竞争，pred 就是 node.prev，有竞争则 pred -> .. -> node，总之 pred 肯定排在 node 前面
            
            1  if(pred.ws==SINGAL) return true;
            2  else
            	2.1  if(pred.ws>0) 把 pred 踢出队列，循环操作（找pred的prev，ws>0 继续踢）
            	2.2 tryCAS pred.ws->SIGNAL // 有时这样的代码，ws<0 总是有人改成 SIGNAL
            3 return false;
            
            总结：
            我看了看。应该必有 node.thread == Thread.currentThread()，即执行此方法的线程，就是 node.thread
            
            首先 node 尝试 acquire 获取，但是失败了
            照道理来说，自己 node 当然要 park 了，以免浪费资源
            但是 node 需要先判断自己前面的人 pred 是不是 ws == SIGNAL，如果是的，那么说明 pred 有义务唤醒后继，后继是谁？就是 node
            所以此时 node 可以安心的 park，所以返回 true
            
            但是，只要不是 pred.ws==SIGNAL，则一定返回 false
            返回 false 之前，node 还要做一点事
            第一件事 如果 pred.ws>0 那你给我滚吧，还呆在队伍里面干嘛？？
            第二件事 如果 pred.ws 是其他的负数，那就尝试一次 CAS 变成 SIGNAL
            //第二件事 我还没有弄懂，为什么动不动就可以把其他的人的 ws 变成 SIGNAL（前提是 ws是负数）
            //那么 其他的负数 ws 没有意义了吗？
            
            "
    - hashMap & concurrentHashMap ankied
      - jdk7 hashMap
        - 数组 + 链表
        - k-v 对存储为 Entry 对象
        - 链表插入节点时，尾插还是头插？——神奇的问题
          "时间局部原理  尽可能线程安全"
        - modCount
        - 扩容 循环链表 死循环
      - jdk7 concurrentHashMap —— 两级数组，第一级并发，第二级别加锁
        - 分段锁
        - hashMap 数组类型 -- entry[]，但是 concurrentHashMap 数组类型是 segment[]
        - segment 内部再有一个 hashEntry[] 数组 (这个 hashEntry 和 hashMap 的entry 是一样的 字段 hash/key/value/next，前两个是final，后两个 volatile) 
        - 构造器：数组大小16、负载因子0.75f，并发等级16
          - 数组大小16，指的是一共16个桶，即一共16个node
          - 并发级别 segment 的数组
          - 举个例子：并发等级4，数组大小8，则segment[].len = 4 ，每个segment内部的 hashEntry[].len = 8/4=2
          - 具体 segment[].len 是 大于等于 并发级别 且2的幂次（若并发级别 = 16 ，则 len = 16 ，若 并发级别= 17，则len =32）
          - segment 内部的  entry[] 数组的大小，同样必须是 2 的幂次
          - 懒初始化：每个segment内部的entry[]数组，需要时才会new出来
        - segmentShift
        - segmentMask 就是 segment[].len - 1 用于计算k-v放在哪个segment中
        - 扩容：segment数组不会扩容（即并发级别不会增加），而是segment内部的数组扩容（这样会导致不同的segment内部的数组大小不一）
        - put 过程
          "先 hash 到是放在哪个 segment（一级数组） 之中，然后再 hash 是放在那个 entry 二级数组中（这时加锁 lock 锁）。"
        - rehash 扩容过程
          "仅仅 segment 内部的 entry[] 需要扩容。这个过程在 put 中完成，加了锁，索然无味"
        - size 方法
          "首先是不加锁统计，失败了再全部segment加上锁统计
          
          何谓失败？ 统计两次，两次的总 modify 数相同，那就说明统计成功。
          
          
          看来 modify 是一中集合设计方法。可以用 modify 表示集合是否变化。
          在 并发容器中， modify 还是用到了"
      - jdk8 hashMap
        - 红黑树
        - 红黑树中需要比较大小，那么这个比较具体是比较什么呢？
          "当 key 是 Comparable 时，按照 compare 比较，不是时，则按照key.hash比较
          如果上面返回相等，则按照 System.identityHashCode 比较 —— 最终还是可能比较不出来，还是两个key 相等，但是实际上 key!=key"
        - 如果hashcode相同的key插入红黑树，则插左边还是右边？——左边
        - rehash/remove 时 红黑树会不会变回链表？——会的
          "rehash时，红黑树变成两个链表，然后如果链表还是很长，就会再次转为树"
        - hashMap 中的红黑树节点，既是树节点，也是双向链表节点
          "root 节点即使 红黑树的根，也是双向链表的头节点"
      - jdk8 concurrentHashMap
        - 键值对中，value 不能为空？——是的。因为null无法表示是存了key-null，还是没有存
        - 在本chm中，正常key的entry.hash值强制不为负数，因为负数的hash值，有特殊意义
        - 如果 entry.hash == -1，表示正在扩容，这个节点的桶已经被移走了
        - put 操作时，如果桶中有元素，怎么办？——加锁。谁的锁？——元素头节点为锁
        - 并发map的红黑树和hashMap的区别？——因为树在插删时，根节点可能会变化，所以不能用root作为锁，而是用一个装载root的treeBin作为桶
        - sizeCtl 属性
          - 默认值 0
          - -1 表示正在初始化tab[] 数组，或正在扩容
          - >0 表示扩容阈值（即 capacity * 0.75f）
        - addCount() 方法——size++，有必要则开始扩容
        - CAS 实现简单的锁
          "for(;;){
          	if(cas(i, 0, 1)){
          		//临界区
          		i = 0; // 释放锁
          		beak;
          	}
          }"
        - jdk8 chm 的 size 是怎么计算的？ —— 和 LongAdder 一样，分段计数器
          "问题：要设计一个高并发的计数器，怎么做？答：像  LongAdder 一样设计，分段"
        - ：volatile的数组，数组内部元素是可见的吗？——是的
        - 为什么判断是否需要扩容，是while而不是if——因为扩容是一个滞后操作，很可能扩容完成后，新tab又超过阈值了，又需要扩容
        - rehash转移元素时，每转移完一个桶，就把桶赋值为forwardingNode（其他线程看到这个fn，就会知道我所在的tab正在被转移，就会加入扩容大军）
        - 扩容大军，怎么知道自己是最后一个线程呢？如果是最后一个线程，需要清场，tab=newTab
          "回答：用一个变量k，记录参与扩容的线程数目，线程加入时k++，线程退出时k--，当k==0时，表示自己是最后一个，需要做清场"
        - jdk8的chm，那些地方会加锁呢？—— 单个桶内部进行修改时，还是会加锁的
        - hashMap 会缩容吗？——不会
      - 其他问题
        - jdk8中 hm 和 chm 都使用了 红黑树
        - 红黑树效率一定比链表高吗？——不是的，元素少时，链表更好
        - 何时转红黑树？——链表长度>8，数组.len>=64
        - 红黑树会变回链表吗？——会，size<6时
  - NIO
    - 简单入门 ANKIED
      - 简介
        "名字 new io jdk1.4出现 代替bio"
      - 与IO区别
        - BIO——面向流、阻塞
        - NIO——面向缓冲区、非阻塞、独特的selector
          "通道 - 铁路 、缓冲区 - 火车 双向"
      - 两大核心
        - 缓冲区 buffer
          "容纳io数据 特定基本类型的容器"
          - 目的：用于存储数据
          - 底层：数组。根据数据类型不同，有相应的缓存区，boolean 除外
            - 数据 1 单位的大小，根据数据类型不同而不同
          - 最常用的 byte buffer
          - 核心字段
            - mark 标记，用于记录pos位置
              - 初始 -1
              - filp/rewind/clear mark = -1
              - mark()，mark = pos
              - reset()，pos = mark
            - position 位置，正在操作数据的位置（pos之前的数据已使用）
              - 初始 pos = 0
              - 写模式，写n单位，则pos+=n
              - 读模式，读n单位，则pos+=n
              - flip()，pos = 0
              - rewind()，pos = 0
              - clear()，pos = 0
            - limit 界限，可以操作数据的大小，limit后的数据不可读写
              - 初始 lim = cap
              - 读写时，不变
              - flip()，lim = pos
              - rewind()，lim不变
              - clear()，lim = cap
            - capacity 容量，最大存储数据大小
            - 其他规律
              - mark <= position <= limit <= capacity
              - ByteBuffer.allocate(1024)之后
                "c=l=1024 p=0
                
                
                长度5缓冲区
                [ _ _ _ _ _ ]
                c = 5
                lim = 5
                pos = 0"
              - flip() 切换后
                "lim = pos
                pos = 0
                cap 不变
                
                说明 lim 可以读取的数据量"
              - 空byte缓冲区，存入 3 字节数据
                "pos = 3 cap、lim不变
                
                [ a b c _ _ ]
                            |
                          pos
                "
              - 读模式，读n单位，则pos+=n
          - 常用方法
            - allocate() 分配指定大小的缓冲器区
            - put() 存储数据
              - 存在pos指针往右位置，存好后，pos右移
            - get() 获取数据
              - 从pos处读数据，读多少，pos右移多少
            - flip() 写模式切换到读模式
            - rewind() 倒带。读了一些数据后，倒带，可以重新度
            - clear() 情况缓冲区，回到初始状态（只是改变指针）
            - mark / reset 标记位置/回到标记位置
          - ⭐ 直接缓冲区 & 非直接缓冲区
            - 非直接缓冲区 allocate() 位置：JVM-堆
              - 缺点：文件 -> os空间 -> 用户空间 -> app
            - 直接缓冲区 allocateDirect() 位置：堆外
              "文件->内存->app"
              - 优点：读写效率高
              - 缺点：分配、释放效率低
            - 内存映射文件 fileChannel.map
        - 通道 channel
          - 定义：源节点和目标节点的连接，负责传输数据（借助buffer）
          - 主要实现类：FileC、SocketC、ServerScocketC、DatagramC
            "DatagramChannel 数据报通道，UDP相关"
          - 获取通道的方法
            - BIO的流getChannel() 方法
            - socket.getChannel()
            - NIO2 中 通道可以直接 open() 打开
            - Files.newByteChannel() // 文件工具类
          - 数据传输
            - 显式方法 读->翻转->写->清空
              - read(buffer)
              - buffer.filp()
              - write(buffer)
              - buffer.clear()
            - 直接传输 指定in/out两个通道，自动完成传输
              "底层原理：直接缓冲区"
          - 分散和聚集
            - 分散 scatter 通道中数据到多个缓冲区（依次填满）
            - 聚集 gather 多个缓冲区数据到一个通道
        - 字符集 编码和解码
          - Charset
          - charset.newEncoder / new Decoder
          - encoder.encode(buf)
      - 非阻塞网络通信
        - 可以被选择的通道 SelectableChannel
          - SocketChannel
          - ServerSocketChannel
          - DatagramChannel  UDP
          - Pipe.SinkChannel / Pipe.SourceChannel 线程管道
        - 选择器 selector
          - 一句话：通道注册到选择器上，选择器监控通道，当通道上数据就绪后，才会把通道分配到线程上
          - 先写一个阻塞式NIO
            - 服务端
              "public void server() throws IOException {
                  ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
              
                  serverSocketChannel.bind(new InetSocketAddress(9898));
              
                  SocketChannel socketChannel = serverSocketChannel.accept();
              
                  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);
              
                  byteBuffer.put("abcdef".getBytes());
              
                  byteBuffer.flip();
              
                  socketChannel.write(byteBuffer);
              
                  socketChannel.close();
              
                  serverSocketChannel.close();
              }"
            - 客户端
              "public void client() throws IOException {
                  SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 9898));
              
                  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);
              
                  byte[] data = new byte[1024];
              
                  int len;
                  while ((len = socketChannel.read(byteBuffer)) != -1) {
                      LOGGER.info("len = {}", len);
                      byteBuffer.flip();
                      byteBuffer.get(data, 0, len);
                      String s = new String(data, 0, len);
                      LOGGER.info("s = {}", s);
                      byteBuffer.clear();
                  }
              
                  socketChannel.close();
              }"
          - 非阻塞
            - socketChannel.configureBlocking(false);
            - Selector selector = Selector.open();
            - serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); 注册到选择器
            - while (selector.select() > 0)
            - selector.selectedKeys()
        - socket channel
      - 管道 pipe 线程通讯
      - NIO 2
  - Spring
    - spring framework 5
      - spring 5 最新完整教程 IDEA 版通俗易懂
        - 简介
          - 作者 Rod Johnson 音乐学博士
          - 是什么？——轻量级 Java EE 框架
          - 目的 简化 JavaEE 开发复杂性
          - SSM 是什么？ —— springMVC + spring + mybatis
          - IoC 是什么？—— 控制反转
        - 简单使用
          - xml
            "<?xml version="1.0" encoding="UTF-8" ?>
            <beans
                    xmlns="http://www.springframework.org/schema/beans"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">
            
                <bean id="user1" class="com.atguigu.spring5.bean.User"/>
            
            </beans>"
          - main
            "ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
            User bean1 =(User) context.getBean("user1");
            bean1.add();"
        - IoC 容器
          - 概念
            - inversion of control 控制反转
            - 目的：解耦。降低代码耦合度
          - 底层原理
            - xml解析
            - 工厂模式
            - 反射
          - IoC 接口 BeanFactory
          - 基于 xml 操作
          - 基于 注解 操作
      - spring 4 雷丰阳
        "https://www.bilibili.com/video/BV1uE411C7CW?from=search&seid=16547058447831094894"
        - IoC
          - 
        - AOP
      - spring 源码
        - org.springframework.util
          - #StringValueResolver [接口] 字符串重解释器 函数式接口 str->str
        - org.springframework.core
          - #AliasRegistry interface 别名登记处
            "void registerAlias(String name, String alias); // 注册别名 alias 到正规名字 name
            void removeAlias(String alias); //移除别名
            boolean isAlias(String name); // 是否是注册了的别名
            String[] getAliases(String name); // 获取正规名字 name 的所有别名"
          - #SimpleAliasRegistry impl #AliasRegistry 简单别名登记处 别名传递性
            "使用 ConcurrentHashMap<String, String> 实现别名登记 key = alias
            别名传递性 如果 正式名a 的别名是b，正式名b 的别名是c，则c 同时是 a 和 b 的别名
            protected boolean allowAliasOverriding() // 是否允许别名覆盖。即已经有zrx-赵润晓，又注册zrx-zzz，就视为别名覆盖
            public boolean hasAlias(String name, String alias) // 是否存在此 别名-正式名 对
            public void resolveAliases(#StringValueResolver valueResolver) //  将所有注册的 别名-正式名 str-str 键值对，所有的 str 都 resolve 一边，换成 resolve(alias)-resolve(name)
            protected void checkForAliasCircle(String name, String alias) // 检查别名循环
            public String canonicalName(String name) // 拿到别名对应的最终正式名 如 a->b->c，拿到 c
            
            实现方法--
            void registerAlias(String name, String alias); // 注册别名 alias 到正规名字 name
            void removeAlias(String alias); //移除别名
            boolean isAlias(String name); // 是否是注册了的别名
            String[] getAliases(String name); // 获取正规名字 name 的所有别名"
        - org.springframework.beans.factory
          - #FactoryBean [接口] 工厂bean 生成bean的bean
            "如果一个bean实现了此接口，那么IoC获取bean时，就不会拿到此bean，而是this::getObject 得到的对象
            T getObject();
            Class<?> getObjectType();
            default boolean isSingleton(){true};"
          - #BeanFactory [接口] bean容器根接口
            "通过name拿到bean
            Object getBean(String name)
            <T> T getBean(String name, Class<T> requiredType)
            Object getBean(String name, Object... args)
            <T> T getBean(Class<T> requiredType)
            <T> T getBean(Class<T> requiredType, Object... args)
            <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType)
            
            <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType)
            
            boolean containsBean(String name);
            boolean isSingleton(String name)
            boolean isPrototype(String name)
            boolean isTypeMatch(String name, ResolvableType typeToMatch)
            boolean isTypeMatch(String name, Class<?> typeToMatch)
            
            Class<?> getType(String name)
            Class<?> getType(String name, boolean allowFactoryBeanInit)
            String[] getAliases(String name);"
          - #HierarchicalBeanFactory extn #BeanFactory 层级的BeanFactory
            "父工厂、仅在本地找bean
            BeanFactory getParentBeanFactory(); // 没有父工厂，返回null
            boolean containsLocalBean(String name); // 本地找bean
            
            继承接口方法--
            Object getBean(String name)
            <T> T getBean(String name, Class<T> requiredType)
            Object getBean(String name, Object... args)
            <T> T getBean(Class<T> requiredType)
            <T> T getBean(Class<T> requiredType, Object... args)
            <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType)
            
            <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType)
            
            boolean containsBean(String name);
            boolean isSingleton(String name)
            boolean isPrototype(String name)
            boolean isTypeMatch(String name, ResolvableType typeToMatch)
            boolean isTypeMatch(String name, Class<?> typeToMatch)
            
            Class<?> getType(String name)
            Class<?> getType(String name, boolean allowFactoryBeanInit)
            String[] getAliases(String name);"
          - #ListableBeanFactory extn #BeanFactory 可以遍历bean的BeanFactory
            "仅在本地遍历，不涉及父工厂，同时以其他方式注册的单例bean也看不到
            boolean containsBeanDefinition(String beanName);
            int getBeanDefinitionCount();
            String[] getBeanDefinitionNames();
            String[] getBeanNamesForType(ResolvableType type);
            String[] getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit);
            String[] getBeanNamesForType(@Nullable Class<?> type);
            String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);
            <T> Map<String, T> getBeansOfType(@Nullable Class<T> type)
            <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)
            String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType);
            Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType)
            <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)
            
            
            继承接口方法--
            Object getBean(String name)
            <T> T getBean(String name, Class<T> requiredType)
            Object getBean(String name, Object... args)
            <T> T getBean(Class<T> requiredType)
            <T> T getBean(Class<T> requiredType, Object... args)
            <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType)
            
            <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType)
            
            boolean containsBean(String name);
            boolean isSingleton(String name)
            boolean isPrototype(String name)
            boolean isTypeMatch(String name, ResolvableType typeToMatch)
            boolean isTypeMatch(String name, Class<?> typeToMatch)
            
            Class<?> getType(String name)
            Class<?> getType(String name, boolean allowFactoryBeanInit)
            String[] getAliases(String name);"
        - org.springframework.beans.factory.support
          - #BeanDefinitionRegistry extn #AliasRegistry BeanDefinition登记处 接口 (beanName, beanDefinition)
            "void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) // 注册 beanName 对应的 beanDefinition
            void removeBeanDefinition(String beanName) // 移除 beanName 对应的 beanDefinition
            BeanDefinition getBeanDefinition(String beanName) // 
            boolean containsBeanDefinition(String beanName);
            String[] getBeanDefinitionNames();
            int getBeanDefinitionCount();
            boolean isBeanNameInUse(String beanName);
            
            继承接口方法--
            void registerAlias(String name, String alias); // 注册别名 alias 到正规名字 name
            void removeAlias(String alias); //移除别名
            boolean isAlias(String name); // 是否是注册了的别名
            String[] getAliases(String name); // 获取正规名字 name 的所有别名"
          - #SimpleBeanDefinitionRegistry extn #SimpleAliasRegistry impl #BeanDefinitionRegistry 简单BeanDefinition登记处
            "使用 Map<String, BeanDefinition> 实现 beanName - BeanDefinition 的登记
            
            实现的--BeanDefinitionRegistry
            void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) // 注册 beanName 对应的 beanDefinition
            void removeBeanDefinition(String beanName) // 移除 beanName 对应的 beanDefinition
            BeanDefinition getBeanDefinition(String beanName) // 
            boolean containsBeanDefinition(String beanName);
            String[] getBeanDefinitionNames();
            int getBeanDefinitionCount();
            boolean isBeanNameInUse(String beanName);
            
            继承自--SimpleAliasRegistry
            protected boolean allowAliasOverriding() // 是否允许别名覆盖。即已经有zrx-赵润晓，又注册zrx-zzz，就视为别名覆盖
            public boolean hasAlias(String name, String alias) // 是否存在此 别名-正式名 对
            public void resolveAliases(#StringValueResolver valueResolver) //  将所有注册的 别名-正式名 str-str 键值对，所有的 str 都 resolve 一边，换成 resolve(alias)-resolve(name)
            protected void checkForAliasCircle(String name, String alias) // 检查别名循环
            public String canonicalName(String name) // 拿到别名对应的最终正式名 如 a->b->c，拿到 c
            
            实现方法--AliasRegistry
            void registerAlias(String name, String alias); // 注册别名 alias 到正规名字 name
            void removeAlias(String alias); //移除别名
            boolean isAlias(String name); // 是否是注册了的别名
            String[] getAliases(String name); // 获取正规名字 name 的所有别名"
          - #FactoryBeanRegistrySupport extn #DefaultSingletonBeanRegistry 工厂bean登记支持 扩展了单例登记处
            "Map<String, Object> // 缓存工厂bean创建的bean
            protected Class<?> getTypeForFactoryBean(FactoryBean<?> factoryBean) //factoryBean.getObjectType()
            protected Object getCachedObjectForFactoryBean(String beanName)
            protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess)
            protected Object postProcessObjectFromFactoryBean(Object object, String beanName)
            protected FactoryBean<?> getFactoryBean(String beanName, Object beanInstance)
            protected AccessControlContext getAccessControlContext()
            
            扩展单例登记处--
            实现--SingletonBeanRegistry
            void registerSingleton(String beanName, Object singletonObject);
            Object getSingleton(String beanName);
            boolean containsSingleton(String beanName);
            String[] getSingletonNames();
            int getSingletonCount();
            Object getSingletonMutex();
            
            扩展--SimpleAliasRegistry
            protected boolean allowAliasOverriding() // 是否允许别名覆盖。即已经有zrx-赵润晓，又注册zrx-zzz，就视为别名覆盖
            public boolean hasAlias(String name, String alias) // 是否存在此 别名-正式名 对
            public void resolveAliases(#StringValueResolver valueResolver) //  将所有注册的 别名-正式名 str-str 键值对，所有的 str 都 resolve 一边，换成 resolve(alias)-resolve(name)
            protected void checkForAliasCircle(String name, String alias) // 检查别名循环
            public String canonicalName(String name) // 拿到别名对应的最终正式名 如 a->b->c，拿到 c
            
            实现方法--
            void registerAlias(String name, String alias); // 注册别名 alias 到正规名字 name
            void removeAlias(String alias); //移除别名
            boolean isAlias(String name); // 是否是注册了的别名
            String[] getAliases(String name); // 获取正规名字 name 的所有别名"
          - #AbstractBeanFactory extn #FactoryBeanRegistrySupport impl #ConfigurableBeanFactory 抽象BeanFactory
            "留待子类实现的方法：getBeanDefinition createBean
            
            Abstract methods to be implemented by subclasses // 需要实现的抽象方法
            protected abstract boolean containsBeanDefinition(String beanName);
            protected abstract BeanDefinition getBeanDefinition(String beanName)
            protected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
            
            Implementation of BeanFactory interface
            getBean() 系列方法
            containsBean()
            isSingleton(String name)
            isPrototype(String name)
            getType(String name)
            getAliases(String name)
            ...
            
            Implementation of HierarchicalBeanFactory interface
            getParentBeanFactory()
            containsLocalBean(String name)
            ...
            
            Implementation of ConfigurableBeanFactory interface
            setParentBeanFactory(@Nullable BeanFactory parentBeanFactory)
            setBeanClassLoader(@Nullable ClassLoader beanClassLoader)
            ...
            
            
            "
        - org.springframework.beans.factory.config
          - #BeanDefinition extn #AttributeAccessor, #BeanMetadataElement xml<bean>内部表示
          - #SingletonBeanRegistry [接口] 单例登记处 单例的注册、获取
            "在使用这个登记处时，可能还存在 bean definitions 中定义了的单例，但是还没有初始化的情况，那么 这个登记处里就没有它
            
            void registerSingleton(String beanName, Object singletonObject);
            Object getSingleton(String beanName);
            boolean containsSingleton(String beanName);
            String[] getSingletonNames();
            int getSingletonCount();
            Object getSingletonMutex();"
          - #DefaultSingletonBeanRegistry extn #SimpleAliasRegistry impl #SingletonBeanRegistry 默认的单例登记处
            "实现--SingletonBeanRegistry
            void registerSingleton(String beanName, Object singletonObject);
            Object getSingleton(String beanName);
            boolean containsSingleton(String beanName);
            String[] getSingletonNames();
            int getSingletonCount();
            Object getSingletonMutex();
            
            扩展--SimpleAliasRegistry
            protected boolean allowAliasOverriding() // 是否允许别名覆盖。即已经有zrx-赵润晓，又注册zrx-zzz，就视为别名覆盖
            public boolean hasAlias(String name, String alias) // 是否存在此 别名-正式名 对
            public void resolveAliases(#StringValueResolver valueResolver) //  将所有注册的 别名-正式名 str-str 键值对，所有的 str 都 resolve 一边，换成 resolve(alias)-resolve(name)
            protected void checkForAliasCircle(String name, String alias) // 检查别名循环
            public String canonicalName(String name) // 拿到别名对应的最终正式名 如 a->b->c，拿到 c
            
            实现方法--
            void registerAlias(String name, String alias); // 注册别名 alias 到正规名字 name
            void removeAlias(String alias); //移除别名
            boolean isAlias(String name); // 是否是注册了的别名
            String[] getAliases(String name); // 获取正规名字 name 的所有别名
            "
          - #ConfigurableBeanFactory extends #HierarchicalBeanFactory, #SingletonBeanRegistry 提供配置bean的各种方法（仅仅在框架内使用，以实现即插即用）
            "void setParentBeanFactory(BeanFactory parentBeanFactory)
            void setBeanClassLoader(@Nullable ClassLoader beanClassLoader);
            ClassLoader getBeanClassLoader();
            void setTempClassLoader(@Nullable ClassLoader tempClassLoader);
            ClassLoader getTempClassLoader();
            void setCacheBeanMetadata(boolean cacheBeanMetadata);
            boolean isCacheBeanMetadata();
            void setBeanExpressionResolver(BeanExpressionResolver resolver);
            BeanExpressionResolver getBeanExpressionResolver();
            void setConversionService(ConversionService conversionService);
            ConversionService getConversionService();
            void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar);
            void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass);
            void copyRegisteredEditorsTo(PropertyEditorRegistry registry);
            void setTypeConverter(TypeConverter typeConverter);
            TypeConverter getTypeConverter();
            void addEmbeddedValueResolver(StringValueResolver valueResolver);
            boolean hasEmbeddedValueResolver();
            String resolveEmbeddedValue(String value);
            void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);
            int getBeanPostProcessorCount();
            void registerScope(String scopeName, Scope scope);
            String[] getRegisteredScopeNames();
            Scope getRegisteredScope(String scopeName);
            AccessControlContext getAccessControlContext();
            void copyConfigurationFrom(ConfigurableBeanFactory otherFactory);
            void registerAlias(String beanName, String alias) throws BeanDefinitionStoreException;
            void resolveAliases(StringValueResolver valueResolver);
            BeanDefinition getMergedBeanDefinition(String beanName)
            boolean isFactoryBean(String name)
            void setCurrentlyInCreation(String beanName, boolean inCreation);
            boolean isCurrentlyInCreation(String beanName);
            void registerDependentBean(String beanName, String dependentBeanName);
            String[] getDependentBeans(String beanName);
            String[] getDependenciesForBean(String beanName);
            void destroyBean(String beanName, Object beanInstance);
            void destroyScopedBean(String beanName);
            void destroySingletons();
            
            层级化bean工厂--
            BeanFactory getParentBeanFactory(); // 没有父工厂，返回null
            boolean containsLocalBean(String name); // 本地找bean
            
            继承接口方法--
            Object getBean(String name)
            <T> T getBean(String name, Class<T> requiredType)
            Object getBean(String name, Object... args)
            <T> T getBean(Class<T> requiredType)
            <T> T getBean(Class<T> requiredType, Object... args)
            <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType)
            
            <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType)
            
            boolean containsBean(String name);
            boolean isSingleton(String name)
            boolean isPrototype(String name)
            boolean isTypeMatch(String name, ResolvableType typeToMatch)
            boolean isTypeMatch(String name, Class<?> typeToMatch)
            
            Class<?> getType(String name)
            Class<?> getType(String name, boolean allowFactoryBeanInit)
            String[] getAliases(String name);
            
            单例登记处
            void registerSingleton(String beanName, Object singletonObject);
            Object getSingleton(String beanName);
            boolean containsSingleton(String beanName);
            String[] getSingletonNames();
            int getSingletonCount();
            Object getSingletonMutex();
            
            
            "
          - #AutowireCapableBeanFactory extn #BeanFactory 
            "
            来自 #BeanFactory  的方法
            通过name拿到bean
            Object getBean(String name)
            <T> T getBean(String name, Class<T> requiredType)
            Object getBean(String name, Object... args)
            <T> T getBean(Class<T> requiredType)
            <T> T getBean(Class<T> requiredType, Object... args)
            <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType)
            
            <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType)
            
            boolean containsBean(String name);
            boolean isSingleton(String name)
            boolean isPrototype(String name)
            boolean isTypeMatch(String name, ResolvableType typeToMatch)
            boolean isTypeMatch(String name, Class<?> typeToMatch)
            
            Class<?> getType(String name)
            Class<?> getType(String name, boolean allowFactoryBeanInit)
            String[] getAliases(String name);"
    - springboot 学习笔记
      "https://www.bilibili.com/video/av38657363"
      - 入门 1855 1908/ 2048 2254
        - 简介 / 微服务
          "简化J2EE 入门容易 精通难
          
          微服务 - 架构 - 多个服务一起
          一组小型服务 服务间HTTP沟通"
        - helloeworld
          "hello, world! Mon Jan 27 21:20:15 CST 2020"
          - 使用spring.io生成
          - maven pom.xml
            "<?xml version="1.0" encoding="UTF-8"?>
            <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
                <modelVersion>4.0.0</modelVersion>
                <parent>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-parent</artifactId>
                    <version>2.2.4.RELEASE</version>
                    <relativePath/> <!-- lookup parent from repository -->
                </parent>
                <groupId>com.zrx</groupId>
                <artifactId>demo</artifactId>
                <version>0.0.1-SNAPSHOT</version>
                <name>springbootRelearn</name>
                <description>Demo project for Spring Boot</description>
            
                <properties>
                    <java.version>11</java.version>
                </properties>
            
                <dependencies>
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter</artifactId>
                    </dependency>
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-web</artifactId>
                    </dependency>
            
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-test</artifactId>
                        <scope>test</scope>
                        <exclusions>
                            <exclusion>
                                <groupId>org.junit.vintage</groupId>
                                <artifactId>junit-vintage-engine</artifactId>
                            </exclusion>
                        </exclusions>
                    </dependency>
                </dependencies>
            
                <build>
                    <plugins>
                        <plugin>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-maven-plugin</artifactId>
                        </plugin>
                    </plugins>
                </build>
            
            </project>"
          - 主程序
            "package com.zrx;
            
            import org.springframework.boot.SpringApplication;
            import org.springframework.boot.autoconfigure.SpringBootApplication;
            
            /**
             * 主程序类
             */
            
            @SpringBootApplication
            public class SpringbootRelearnApplication {
                public static void main(String[] args) {
                    //启动
                    SpringApplication.run(SpringbootRelearnApplication.class, args);
                }
            }"
          - helloword controller
            "package com.zrx.controller;
            
            import org.springframework.web.bind.annotation.RequestMapping;
            import org.springframework.web.bind.annotation.RestController;
            
            import java.util.Date;
            
            /**
             * Description
             * hello
             * <p>
             * Data
             * 21:11
             *
             * @author zrx
             * @version 1.0
             */
            
            @RestController
            public class HelloController {
                @RequestMapping("/hello")
                public String hello() {
                    return "hello, world! " + new Date();
                }
            }"
        - 原理
          - 可以完整打包成jar运行
          - spingboot把场景打包为starter 导入即可
          - @SpringBootApplication 核心类 说明这个类是主配置类 
            "@Target(ElementType.TYPE)
            @Retention(RetentionPolicy.RUNTIME)
            @Documented
            @Inherited
            @SpringBootConfiguration // 配置类
            @EnableAutoConfiguration // 开启自动配置 我们就不用配置任何东西了。扫描所在包下的所有组件，扫描到组件中。导入很多自动配置类：配置场景需要的组件 所以可以免去手动配置。在META中有一个配置文件
            @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
                  @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })"
      - 配置——从配置文件注入信息⭐ (->14
        - 从配置文件注入信息⭐
          - 编写Bean类 两个注解
            - @Component 表示这是一个bean
            - @ConfigurationProperties(prefix = "person") 表示在配置文件中，前缀是person
          - map、list、对象的对象 配置方法见示例
          - [或者optional]@value 在每个field上注入
          - 松散语法绑定 即 lastName == last-name
          - 校验，比如某个field必须是邮箱格式
            "@Validated//校验
            public class Person {
            @Email
            private String mail;
            }"
          - 中文乱码
            "配置中加入
            server.tomcat.uri-encoding=UTF-8
            spring.http.encoding.force=true
            spring.http.encoding.charset=UTF-8
            spring.http.encoding.enabled=true
            
            配置idea
            -------------------------
            file encoding 中，配置编码为UTF-8 共三个地方
            然后勾选 transparent native to ascii"
          - 示例
            - Person类(使用Dog)
              "@Component
              @ConfigurationProperties(prefix = "person")
              public class Person {
                  private String name;
                  private Integer age;
                  private Boolean male;
                  private Date birthday;
              
                  private Map<String,Object> map;
                  private List<Object> list;
              
                  private Dog dog;
              
                  @Override
                  public String toString() {
                      return "Person{" +
                              "name='" + name + '\'' +
                              ", age=" + age +
                              ", male=" + male +
                              ", birthday=" + birthday +
                              ", map=" + map +
                              ", list=" + list +
                              ", dog=" + dog +
                              '}';
                  }
              
                  public String getName() {
                      return name;
                  }
              
                  public void setName(String name) {
                      this.name = name;
                  }
              
                  public Integer getAge() {
                      return age;
                  }
              
                  public void setAge(Integer age) {
                      this.age = age;
                  }
              
                  public Boolean getMale() {
                      return male;
                  }
              
                  public void setMale(Boolean male) {
                      this.male = male;
                  }
              
                  public Date getBirthday() {
                      return birthday;
                  }
              
                  public void setBirthday(Date birthday) {
                      this.birthday = birthday;
                  }
              
                  public Map<String, Object> getMap() {
                      return map;
                  }
              
                  public void setMap(Map<String, Object> map) {
                      this.map = map;
                  }
              
                  public List<Object> getList() {
                      return list;
                  }
              
                  public void setList(List<Object> list) {
                      this.list = list;
                  }
              
                  public Dog getDog() {
                      return dog;
                  }
              
                  public void setDog(Dog dog) {
                      this.dog = dog;
                  }
              }"
            - Dog类
              "@Component
              @ConfigurationProperties(prefix = "dog")
              public class Dog {
                  private String name;
                  private Integer age;
              
                  @Override
                  public String toString() {
                      return "Dog{" +
                              "name='" + name + '\'' +
                              ", age=" + age +
                              '}';
                  }
              
                  public String getName() {
                      return name;
                  }
              
                  public void setName(String name) {
                      this.name = name;
                  }
              
                  public Integer getAge() {
                      return age;
                  }
              
                  public void setAge(Integer age) {
                      this.age = age;
                  }
              }"
            - 配置文件 application.properties
              "# bean 注入
              # 注入字符串
              person.name=zrx
              # 注入数字
              person.age=13
              # 注入日期
              person.birthday=2007/11/05
              # 注入Boolean
              person.male=false
              # 注入map
              person.map.k1=v1
              person.map.k2=14
              # 注入list
              person.list=a,b,c,1,2,3
              # 注入对象中的对象
              person.dog.name=myDog
              person.dog.age=2
              # person = Person{name='zrx', age=13, male=false,
              # birthday=Mon Nov 05 00:00:00 CST 2007, map={k1=v1, k2=14},
              # list=[a, b, c, 1, 2, 3], dog=Dog{name='myDog', age=2}}"
            - 注入person 测试
              "@SpringBootTest
              public class BeanValueInjectTest {
                  private final Person person;
              
                  @Autowired
                  public BeanValueInjectTest(Person person) {
                      this.person = person;
                  }
              
                  @Test
                  public void injectTest(){
                      System.out.println("person = " + person);
                  }
              }"
          - 配置文件占位符${}
          - 环境切换 Profile
          - 配置文件位置和加载顺序
          - 可以配置的项目
          - 自动配置原理
            - 启动类注解：@SpringBootApplication
              "这是一个复合注解，其中有 @EnableAutoConfiguration
              启动时自动配置功能
              --------------------------------------
              其中
              @Import(AutoConfigurationImportSelector.class) 选择器给容器导入组件
              ----------------------------------------
              其中selectImports()方法 其中有个List<String> configurations 存有配置信息
              -----------------------------------------
              SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());
              
              从类路径下获得配置信息：
              String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
              
              --->扫码所有jar包类路径下的META-INF/spring.factories
              
              扫描成properties对象，然后加入到(List)configurations
              
              其中有一堆XXXAutoConfiguration类，这就是配置类
              有@Configuration (表示这是一个配置类)和 @EnableConfigurationProperties 后者即有@ConfigurationProperties 制定了前缀
              
              @ConditionalOnXXXX 表是当前是XXXX时，配置才生效
              "
        - 配置文件 application.properties/yml
        - 端口修改 server.port=8079
      - 日志
        - 归档 异步 框架抽离 接口
        - 接口和实现的选择
        - 很多适配器 好东西
          "http://www.slf4j.org/images/concrete-bindings.png"
        - 遗留问题 日志混杂问题
          "本系统的日志、spring的日志、mybatis的日志...都不一样
          怎么统一日志？
          
          http://www.slf4j.org/images/legacy.png
          
          先把其他日志框架排除
          然后用中间包替换原来的日志框架
          
          实例
          -----------------------------
          springboot的日志
          <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
            <version>2.2.4.RELEASE</version>
            <scope>compile</scope>
          </dependency>
          
          其中有大部分的适配器到slf4j
          
          
          排除一个框架的日志
          -------------------------
          maven中
          dependency里
          写exclusion"
      - web开发
        - 静态资源映射规则
          "webjars 垃圾东西"
        - springMVC 自动配置好了
          "垃圾东西 视图解析"
        - RESTful 风格
          "URL:/资源名称/资源标识
          HTTP请求方式
          	GET  查询
          	PSOT  添加
          	PUT  修改
          	DELEDE 删除"
        - 异常处理
        - servlet容器 配置 更改 @Deprecated 
          - springboot默认使用嵌入式tomcat servlet容器
          - 怎么配置修改容器？
            "server.tomcat.xxx 
            或者编写配置类"
          - 注册 servlet listener fliter 
          - 使用其他servlet容器——jetty(长连接) undertow(不支持JSP 效率高)
      - 全局异常
        - 简单使用 @RestControllerAdvice @ExceptionHandler 
          "@RestControllerAdvice
          public class GlobalExceptionHandler {
              private final static Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class);
          
              public GlobalExceptionHandler(){
                  LOGGER.info("GlobalExceptionHandler injected");
              }
          
              @ExceptionHandler(Exception.class)
              public DataWrapper<Exception> badRequest(Exception e) {
                  LOGGER.error("发生未知异常，请分类。{}",e.toString());
                  return DataWrapper.badRequest("未知异常", e);
              }
          
              @ExceptionHandler(org.springframework.web.servlet.NoHandlerFoundException.class)
              public DataWrapper<Exception> noHandlerFound(Exception e){
                  return DataWrapper.badRequest("请求错误",e);
              }
          }"
        - 处理404异常 这个异常就算配置全局异常也无法捕获
          - 第一步 配置文件
            "# catch the 404 not found exception, otherwise it will be handled by springboot itself
            spring.mvc.throw-exception-if-no-handler-found=true
            spring.resources.add-mappings=false"
          - 第二步 在全局异常类中捕获它
            "@ExceptionHandler(org.springframework.web.servlet.NoHandlerFoundException.class)
            public DataWrapper<Exception> noHandlerFound(Exception e){
                return DataWrapper.badRequest("请求错误",e);
            }"
      - docker与springboot
        - 开源的容器引擎 
      - 数据访问 - >见springboot 常见问题
      - 启动配置原理+四大监听器 - >见springboot 常见问题
      - 自定义starters 启动器
      - 缓存-JSR/redis
        "JSR-107缓存规范
        spring缓存
        redis"
        - 意义：临时数据/较少数据库压力
        - JSR 缓存规范 接口规范 用的人不多
          "5个核心接口
          缓存提供者
          管理器 - 类似数据库
          缓存 - 类似连接
          缓存记录 - 类似数据项目
          有效期"
        - spring 缓存抽象
          "两个抽象：cahce manager 和 cache
          cache —— 表示一个缓存组件，用于获取、修改缓存的信息
          注解：
          	@Cacheable 缓存方法的结果
          	@CacheEvict 清空缓存
          	@EnableCaching 开启基于注解的缓存
          缓存的key生成策略"
          - 缓存管理器 cahce manager 是一个map<String,cache>
          - cache 缓存，不是指一个数据，而是一个map<key,value>
        - spring 默认缓存工作原理（底层：concurrent hash map）
          "1. 加载缓存配置类
          2. 配置类给容器注册 缓存管理器(一个map)
          	管理器是一个 并发哈希map <String缓存名字,Cache>
          	管理器 保存了 cache
          	利用@Cacheable 中的 cacheNames 可以设置缓存名字
          3. 当带有 @Cacheable  的方法被调用时，先找到 cache ，然后再里面找是不是缓存了数据
          	使用 key 获取 数据 
          4. 若没有查到，调用方法，存下return数据
          "
        - redis 缓存中间件
      - 消息 rabbitMq
        - 目的：异步处理 应用解耦 削峰
        - 两种形式
          "P2P：点对点
          主题：订阅者模式"
        - JMS - Java message service
          "Java消息规范，只运行于JVM 
          包含p2p和订阅
          activeMQ和H0rnetMQ 基于此"
        - AMOP - advanced message queuing protocol
          "兼容JMS，新增替他的模式
          可以跨平台
          RabbitMQ 基于此"
        - RabbitMQ 原理
          - 组成和运行原理
            - message 消息 = 消息头 + 消息体
            - publisher 生产者
            - exchange 交换器，用于接收生成者的消息，并放入队列
              "类似于 路由器"
            - queue 消息队列 容器
            - binding 绑定 队列 和 交换器
            - connection 网络连接
            - channel 信道 服用TCP连接 避免建立TCP的开销
            - consumer 消费者
            - Virtual Host 虚拟主机 一个rabbitMQ可以运行多个互相隔离的虚拟主机
              "在连接时指定，默认 /
              "
            - broker 服务器、代理，里面包含 虚拟主机
            - 总结
              "publisher 生产 message
              发送到 broker 的 一个虚拟主机 的 exchange
              exchange 转发到 绑定的 queue
              
              consumer 建立 连接
              连接包含多个管道
              通过管道拿到 queue 中的消息"
          - 四种消息
            - direct 即P2P 单播
              "路由键为dog时
              exchange 只会转发给 dog 队列，不会是 dog.puppy"
            - fanout 广播
              "无论消息是什么，会转发到 exchange 下的所有 queue"
            - topic 组播
              "安装路由键匹配转发到某些 queue
              
              设置 exchange 
              绑定到 a.new 的 queue
              key设置为 #.new
              
              
              则发送消息的 key = use.cndkfbino 时，a.new 会收到消息"
            - headers @Deprecated 
      - 检索 elastic search
        - 目的：全文检索
        - elastic search 简单学习
          - ES集群 存有多个索引(index/database)
          - 索引 index 类似于一个数据库
            - 名词 indices 类似于数据库
            - 动词 把数据存入索引 PUT 请求 /索引名/类型名/ 请求体：json格式的文档
              "下文中
              megacorp	索引名
              employee	类型名
              1	这个员工的ID
              --------------------------------
              PUT /megacorp/employee/1
              {
                  "first_name" : "John",
                  "last_name" :  "Smith",
                  "age" :        25,
                  "about" :      "I love to go rock climbing",
                  "interests": [ "sports", "music" ]
              }"
          - 类型 Type 类似于数据库的表
          - 文档 document 类似于数据库表的元组/行 json格式
          - 属性 field
          - 简单搜索 RUSTFUL 风格
            - PUT 存入/更新文档（数据行）
              "PUT请求 http://192.168.2.3:9200/index01/student/1
              内容为json
              ---------------------------------
              {
                  "first_name" : "John",
                  "last_name" :  "Smith",
                  "age" :        25,
                  "about" :      "I love to go rock climbing",
                  "interests": [ "sports", "music" ]
              }
              ---------------------------------
              相应为json
              ---------------------------------
              {
                  "_index": "index01", // 数据库名称
                  "_type": "student", // 表名称
                  "_id": "1", //
                  "_version": 1, //版本
                  "result": "created", // 表面创建了这个数据
                  "_shards": {
                      "total": 2,
                      "successful": 1,
                      "failed": 0
                  },
                  "created": true
              }
              ---------------------------------"
            - GET 检索文档（数据行）
              "GET请求 http://192.168.2.3:9200/index01/student/3
              返回
              ------------------------------------------
              {
                  "_index": "index01",
                  "_type": "student",
                  "_id": "3",
                  "_version": 1,
                  "found": true,
                  "_source": {
                      "first_name": "Douglas",
                      "last_name": "Fir",
                      "age": 35,
                      "about": "I like to build cabinets",
                      "interests": [
                          "forestry"
                      ]
                  }
              }
              ------------------------------------------"
            - DELETE 文档（数据行）
            - HEAD请求 可以查看文档是否存在
              "HEAD http://192.168.2.3:9200/index01/student/4
              返回 200 表示存在
              返回 404 表示不存在"
          - 轻量搜索
            - 全部类型下的文档（相当于 select *）
              "GET ../_search
              GET http://192.168.2.3:9200/index01/student/_search
              --------------------
              {
                  "took": 69,
                  "timed_out": false,
                  "_shards": {
                      "total": 5,
                      "successful": 5,
                      "skipped": 0,
                      "failed": 0
                  },
                  "hits": {
                      "total": 3,
                      "max_score": 1.0,
                      "hits": [
                          {
                              "_index": "index01",
                              "_type": "student",
                              "_id": "2",
                              "_score": 1.0,
                              "_source": {
                                  "first_name": "Jane",
                                  "last_name": "Smith",
                                  "age": 32,
                                  "about": "I like to collect rock albums",
                                  "interests": [
                                      "music"
                                  ]
                              }
                          },
                          {
                              "_index": "index01",
                              "_type": "student",
                              "_id": "1",
                              "_score": 1.0,
                              "_source": {
                                  "first_name": "John",
                                  "last_name": "Smith",
                                  "age": 25,
                                  "about": "I love to go rock climbing",
                                  "interests": [
                                      "sports",
                                      "music"
                                  ]
                              }
                          },
                          {
                              "_index": "index01",
                              "_type": "student",
                              "_id": "3",
                              "_score": 1.0,
                              "_source": {
                                  "first_name": "Douglas",
                                  "last_name": "Fir",
                                  "age": 35,
                                  "about": "I like to build cabinets",
                                  "interests": [
                                      "forestry"
                                  ]
                              }
                          }
                      ]
                  }
              }
              "
            - 条件搜索 _search?q=key:value
              "GET http://192.168.2.3:9200/index01/student/_search?q=last_name:Smith
              ------------------------
              {
                  "took": 23,
                  "timed_out": false,
                  "_shards": {
                      "total": 5,
                      "successful": 5,
                      "skipped": 0,
                      "failed": 0
                  },
                  "hits": {
                      "total": 2,
                      "max_score": 0.2876821,
                      "hits": [
                          {
                              "_index": "index01",
                              "_type": "student",
                              "_id": "2",
                              "_score": 0.2876821,
                              "_source": {
                                  "first_name": "Jane",
                                  "last_name": "Smith",
                                  "age": 32,
                                  "about": "I like to collect rock albums",
                                  "interests": [
                                      "music"
                                  ]
                              }
                          },
                          {
                              "_index": "index01",
                              "_type": "student",
                              "_id": "1",
                              "_score": 0.2876821,
                              "_source": {
                                  "first_name": "John",
                                  "last_name": "Smith",
                                  "age": 25,
                                  "about": "I love to go rock climbing",
                                  "interests": [
                                      "sports",
                                      "music"
                                  ]
                              }
                          }
                      ]
                  }
              }"
            - 条件搜索 json版本 (GET请求可以发送body
              "GET ../_search
              请求体
              -------------------------
              {
                  "query" : {
                      "match" : {
                          "last_name" : "Smith"
                      }
                  }
              }"
            - 多条件搜索 body发json
              "GET ../_search
              请求体
              -------------------------
              {
              	"query":{
              		"bool":{
              			"must":{
              				"match":{
              					"last_name":"smith"
              				}
              			},
              			"filter":{
              				"range":{
              					"age":{"gt":30}
              				}
              			}
              		}
              	}
              }"
            - 模糊查询，单词分开 相关性
              "GET ../_search
              请求体
              -------------------------
              {
                  "query" : {
                      "match" : {
                          "about" : "rock climbing" // rock 和 climbing
                      }
                  }
              }"
            - 短语搜索，单词不分开
              "GET ../_search
              请求体
              -------------------------
              {
                  "query" : {
                      "match_phrase" : {
                          "about" : "rock climbing"
                      }
                  }
              }"
            - 展示命中区域，高亮显示
              "GET ../_search
              请求体
              -------------------------
              {
                  "query" : {
                      "match_phrase" : {
                          "about" : "rock climbing"
                      }
                  },
                  "highlight": {
                      "fields" : {
                          "about" : {}
                      }
                  }
              }"
      - 任务
        - 异步任务
        - 定时任务
        - 邮件任务
      - 安全
        - 认证 - 验证身份，证明你是谁
          "用于发送 用户名+密码
          后台验证这个用户"
        - 授权 - 某操作能否进行
        - 两大安全框架
          - apache shiro
          - spring security
      - 分布式
        - 入门
          - RPC 远程过程调用
            "不同服务是在独立的机子上运行
            相互交互的问题"
          - 注册中心
            "一个服务，有多台一样的机子在运行
            这个时候使用哪一台？
            
            注册中心 知道所有的服务，分别运行在哪些机子上
            因此使用服务前，先去注册中心询问"
        - dubbo zookeeper 国内常用
          - zookeeper 注册中心
            "订单模块 要访问 用户模块
            但是此时 不知道 用户模块在哪里
            它首先去注册中心询问
            知道了 用户模块 的地址后，在通信
            
            因此，大家都知道 注册中心 的位置
            但是不知道另外的服务的位置"
          - dubbo 分布式服务框架
            "启动时 建立 服务容器
            在容器中加载 服务提供者
            每个加载的 服务提供者 会把自己能提供的服务注册到 注册中心
            服务消费者 会在 注册中心 订阅 所需的服务
            
            服务消费者 拿到 注册信息后 就可以访问 服务提供者（负载均衡）
            若失败，则在 注册信息 中找另一个"
            - container 服务容器
            - provider 服务提供者
              "动作：注册 register"
            - registry 注册中心
              "动作：通知服务的消费者 notify 服务的信息、变更"
            - consumer 服务消费者
              "动作：订阅服务 subscribe
              动作：访问服务提供者 invoke，需要先拿到注册名单"
            - monitor 监控中心 可以监控服务提供者和服务消费者
        - springboot + cloud
      - 热部署
      - 监控
    - springboot 简单使用
      - 从配置文件中注入信息
        - 前缀注入模式 @ConfigurationProperties(prefix = "person")
          - 配置application.properties
            "注意person来自bean的注解
            @ConfigurationProperties(prefix = "person")
            dog同上
            -------------------------------------
            # bean 注入
            # 注入字符串
            person.name=张三
            # 注入数字
            person.age=13
            # 注入日期
            person.birthday=2007/11/05
            # 注入Boolean
            person.male=false
            # 注入map
            person.map.k1=v1
            person.map.k2=14
            # 注入list
            person.list=a,b,c,1,2,3
            person.mail=123456@qq.com
            # 注入对象中的对象
            person.dog.name=myDog
            person.dog.age=2"
          - 要输入的对象类(配置类)
            - Person 注意两个注解
              "@Component //表示这是一个组件，可以注入
              @ConfigurationProperties(prefix = "person") //在配置文件中的前缀
              @Validated//校验
              public class Person {
                  private String name;
                  private Integer age;
                  private Boolean male;
                  private Date birthday;
              
                  private Map<String,Object> map;
                  private List<Object> list;
              
                  private Dog dog;
              
                  @Email
                  private String mail;
              
                  public String getMail() {
                      return mail;
                  }
              
                  public void setMail(String mail) {
                      this.mail = mail;
                  }
              
                  @Override
                  public String toString() {
                      return "Person{" +
                              "name='" + name + '\'' +
                              ", age=" + age +
                              ", male=" + male +
                              ", birthday=" + birthday +
                              ", map=" + map +
                              ", list=" + list +
                              ", dog=" + dog +
                              ", mail='" + mail + '\'' +
                              '}';
                  }
              
                  public String getName() {
                      return name;
                  }
              
                  public void setName(String name) {
                      this.name = name;
                  }
              
                  public Integer getAge() {
                      return age;
                  }
              
                  public void setAge(Integer age) {
                      this.age = age;
                  }
              
                  public Boolean getMale() {
                      return male;
                  }
              
                  public void setMale(Boolean male) {
                      this.male = male;
                  }
              
                  public Date getBirthday() {
                      return birthday;
                  }
              
                  public void setBirthday(Date birthday) {
                      this.birthday = birthday;
                  }
              
                  public Map<String, Object> getMap() {
                      return map;
                  }
              
                  public void setMap(Map<String, Object> map) {
                      this.map = map;
                  }
              
                  public List<Object> getList() {
                      return list;
                  }
              
                  public void setList(List<Object> list) {
                      this.list = list;
                  }
              
                  public Dog getDog() {
                      return dog;
                  }
              
                  public void setDog(Dog dog) {
                      this.dog = dog;
                  }
              }"
            - Dog类 同样两个注解类
              "@Component
              @ConfigurationProperties(prefix = "dog")
              public class Dog {
                  private String name;
                  private Integer age;
              
                  @Override
                  public String toString() {
                      return "Dog{" +
                              "name='" + name + '\'' +
                              ", age=" + age +
                              '}';
                  }
              
                  public String getName() {
                      return name;
                  }
              
                  public void setName(String name) {
                      this.name = name;
                  }
              
                  public Integer getAge() {
                      return age;
                  }
              
                  public void setAge(Integer age) {
                      this.age = age;
                  }
              }"
            - 简单的使用示例
              "@RestController
              public class HelloController {
              
                  private final Person person;
              
                  @Autowired
                  public HelloController(Person person) {
                      this.person = person;
                  }
              
                  @RequestMapping("/hello")
                  public String hello() {
                      return "hello, world!中文测试 " + person;
                  }
              }"
        - 单个field注入 @Value(${person.name})
          - 示例
            - bean类 @Value("${miao.name}")
              "@Component
              //@PropertySource("classpath:application.properties")
              public class Miao {
                  @Value("${miao.name}")
                  private String name;
              
                  @Value("${miao.age}")
                  private Integer age;
              
              
                  @Override
                  public String toString() {
                      return "Miao{" +
                              "name='" + name + '\'' +
                              ", age='" + age + '\'' +
                              '}';
                  }
              
                  public String getName() {
                      return name;
                  }
              
                  public void setName(String name) {
                      this.name = name;
                  }
              
                  public Integer getAge() {
                      return age;
                  }
              
                  public void setAge(Integer age) {
                      this.age = age;
                  }
              }"
            - 配置文件
              "# @Value 注入
              miao.name=maiomiao
              miao.age=15"
            - 使用方法@Autowired 
        - map/list的注入方法
          - 配置文件
            "# 注入map
            person.map.k1=v1
            person.map.k2=14
            # 注入list
            person.list=a,b,c,1,2,3
            person.mail=123456@qq.com
            # 注入对象中的对象
            person.dog.name=myDog
            person.dog.age=2"
        - 指定配置文件 @PropertySource("classpath:application.properties")
          "默认从全局配置文件读取值"
        - 校验@Validated->类 @Email->field
        - 配置类写法 @Configuration + @Bean 代替以前的springXML配置文件
          "@Configuration //这是一个配置类，替代之前的spring配置文件
          public class MyConfig {
              //以前在spring配置文件中使用<bean> 配置组件
              //默认id即方法名
              @Bean
              public Object someBean(){
                  System.out.println("someBean 初始化成功");
                  return Collections.singleton("someBean，通过配置类配置");
              }
          }"
        - 环境切换 spring.profiles.active=dev
          "配置文件名：
          application-${profile}.properties
          application-dev.properties
          application-prod.properties
          
          默认使用application.properties
          
          激活方法一 主配置类
          ------------------
          在application.properties中
          写spring.profiles.active=dev
          就可以切换到dev环境
          
          激活方法二 命令行
          -------------------
          spring.profile.active=dev"
        - 开启debug模式 debug=true
          "可以打印全部生效的自动配置类"
      - 单元测试
        - maven pom
          "<dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-test</artifactId>
              <scope>test</scope>
          </dependency>"
        - 测试代码 三个注解
          "@RunWith(SpringRunner.class)
          @SpringBootTest
          class PrivacyApplicationTests {
              private final Logger LOGGER = LoggerFactory.getLogger(PrivacyApplicationTests.class);
          
              @Test
              public void test(){
                  LOGGER.info("test");
              }
          }"
      - 日志
        - 接口使用SLF4J
          "http://www.slf4j.org/
          
          使用
          ---------------------------------
          import org.slf4j.Logger;
          import org.slf4j.LoggerFactory;
          
          public class HelloWorld {
            public static void main(String[] args) {
              Logger logger = LoggerFactory.getLogger(HelloWorld.class);
              logger.info("Hello World");
            }
          }"
        - 实现使用Logback
        - 使用方法->最简单
          "final Logger logger = LoggerFactory.getLogger(getClass());"
        - application.properties中简单配置日志
          - 修改输出级别
            "# 日志输出级别
            logging.level.com.zrx=trace
            
            logging.level.包名
            
            太牛逼了，可以指定到包的级别"
          - 设置日志输出文件
            "# 日志输出文件
            #logging.file.name=./log/springboot0129.log"
          - 设置日志格式
            "# 控制台输出日志格式
            #logging.pattern.console=
            # 文件日志输出格式
            #logging.pattern.file="
        - 自己写日志文件 logback.xml 等
        - 切换日志框架
        - 我的日志工具类，简化Logger写法⭐
          "package com.zrx.utils;
          
          import org.slf4j.LoggerFactory;
          
          import java.util.HashMap;
          import java.util.Map;
          
          /**
           * Description
           * 对 org.slf4j 的包装
           * 使用 Logger.getLogger()即可获得 org.slf4j.Logger
           * <p>
           * Data
           * 17:10
           *
           * @author zrx
           * @version 1.0
           */
          
          public class Logger {
              //本类的Logger
              private static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(Logger.class);
              //放置全部Logger的MAP
              private static final Map<Class<?>, org.slf4j.Logger> MAP = new HashMap<>();
              static {
                  //放入本例的Logger
                  MAP.put(Logger.class,LOGGER);
              }
          
              public static org.slf4j.Logger getLogger(){
                  //找到调用的类
                  final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
                  final StackTraceElement traceElement = stackTrace[2];
                  Class<?> klass = null;
                  try {
                      klass = Class.forName(traceElement.getClassName());
                  } catch (ClassNotFoundException ignored) {
                      klass = Logger.class;
                  }
          
                  //注册
                  if(!MAP.containsKey(klass))
                      MAP.put(klass,LoggerFactory.getLogger(klass));
          
                  return MAP.get(klass);
              }
          }"
      - web相关
        - ⭐@CrossOrigin 允许跨域访问—— 放在controller上
          - @Deprecated 允许跨域访问——垃圾办法
            "下面的代码是从网上复制的，不知道安不安全，但是能用
            ----------------------------------
            package com.zrx.config;
            
            import org.springframework.context.annotation.Bean;
            import org.springframework.context.annotation.Configuration;
            import org.springframework.web.cors.CorsConfiguration;
            import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
            import org.springframework.web.filter.CorsFilter;
            
            /**
             * Description
             * 允许跨域请求
             * 
             * 来自：https://blog.csdn.net/xcbeyond/article/details/84453832
             * 不知安全性问题
             * 但是能用
             * <p>
             * Data
             * 15:37
             *
             * @author zrx
             * @version 1.0
             */
            
            @Configuration
            public class CorsConfig {
                private CorsConfiguration buildConfig() {
                    CorsConfiguration corsConfiguration = new CorsConfiguration();
                    corsConfiguration.addAllowedOrigin("*"); //允许任何域名
                    corsConfiguration.addAllowedHeader("*"); //允许任何头
                    corsConfiguration.addAllowedMethod("*"); //允许任何方法
                    return corsConfiguration;
                }
            
                @Bean
                public CorsFilter corsFilter() {
                    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
                    source.registerCorsConfiguration("/**", buildConfig()); //注册
                    return new CorsFilter(source);
                }
            }"
        - springboot配置controller全局路径
          "@RequestMapping(path = "/test/json")"
        - JSON相关
          - ⭐ObjectMapper 数据转为JSON格式
            "spring已经配置了JSON，使用方法：
            private final ObjectMapper mapper = new ObjectMapper();
            mapper.writeValueAsString(set);
            
            实例
            ------------------------
            @GetMapping("/emps")
            public String list() throws JsonProcessingException {
                Logger.getLogger().info("/emps被访问");
                return mapper.writeValueAsString(set);
            }"
          - ⭐@RequestBody 从POST请求中读取JSON并包装
            "@PostMapping("/emps")
            //使用@RequestBody 自动识别请求为application/json 然后封装为对象
            public String addEmps(@RequestBody Employee employee) throws JsonProcessingException {
                Logger.getLogger().info("/emps收到添加请求：" + employee);
                set.add(employee);
                return mapper.writeValueAsString(new Employee(200,"OK"));
            }"
          - springboot返回json数据
            "只要注释了@RestController  的controller
            里面的所有返回值都会自动解析为json格式"
          - springboot接受json数据并包装 @RequestBody
            "@PostMapping("/post/person")
            public Object receivePerson(@RequestBody PersonInTestController person){
                LOGGER.info("post mapping /test/json/post/person = {}",person);
            
                return new JsonInTestController(person);
            }"
          - 序列化转string @JsonSerialize(using = ToStringSerializer.class)
            "如long类型会失真，那就转string
            
            对于Long类型的数据，如果我们在Controller层将结果序列化为json，直接传给前端的话，在Long长度大于17位时会出现精度丢失的问题。如何避免精度丢失呢？最常用的办法就是将Long类型字段统一转成String类型。"
        - 各种请求的map处理 @XXXMapping @PathVariable  @RequestBody 
          - @GetMapping  @PathVariable 
            "@GetMapping("/emp/{id}")
            public String getEmp(@PathVariable("id") Integer id) throws JsonProcessingException {
                Logger.getLogger().info("/emp收到添加请求：" + id);
                return mapper.writeValueAsString(map.getOrDefault(id, new Employee(404, "员工不存在")));
            }
            
            @GetMapping("/emps")//GET 请求，获取全部数据
            public String list() throws JsonProcessingException {
                Logger.getLogger().info("/emps被访问（获取员工列表）");
                return mapper.writeValueAsString(map.values().toArray());
            }"
          - @PostMapping  @RequestBody  ->可以解析JSON并包装成对象
            "@PostMapping("/emp") //POST 请求，上传数据
            //使用@RequestBody 自动识别请求为application/json 然后封装为对象
            public String addEmps(@RequestBody Employee employee) throws JsonProcessingException {
                Logger.getLogger().info("/emp收到添加请求（添加员工）：" + employee);
                map.put(employee.id, employee);
                return mapper.writeValueAsString(new Employee(200, "OK"));
            }"
          - @PutMapping 数据同POST 所以使用@RequestBody 
            "@PutMapping("/emp") //PUT 请求，修改员工
            public String updateEmp(@RequestBody Employee employee) throws JsonProcessingException {
                Logger.getLogger().info("/emp/{id} 修改员工" + employee);
                if (map.containsKey(employee.id)) {
                    Employee oldEmp = map.get(employee.id);
                    map.put(employee.id, employee);
                    Logger.getLogger().info("成功修改员工" + employee);
            
                    return mapper.writeValueAsString(oldEmp);
                } else {
                    Logger.getLogger().info("要修改的员工不存在");
                    return mapper.writeValueAsString(new Employee(404, "要修改的员工不存在"));
                }
            }"
          - @DeleteMapping  
            "@DeleteMapping("/emp/{id}")
            public String delEmp(@PathVariable("id") Integer id) throws JsonProcessingException{
                Logger.getLogger().info("/emp/{id} 删除员工" + id);
                Employee employee = map.getOrDefault(id, null);
                if(employee==null){
                    Logger.getLogger().info("要删除的员工不存在");
                    return mapper.writeValueAsString(new Employee(404, "要删除的员工不存在"));
                }else {
                    Logger.getLogger().info("员工" + employee + "删除成功");
                    map.remove(id);
                    return mapper.writeValueAsString(employee);
                }
            }"
          - 以上请求测试，完整的controller
            "可以独立运行，内置数据
            -----------------------------------------
            package com.zrx.controller;
            
            import com.fasterxml.jackson.core.JsonProcessingException;
            import com.fasterxml.jackson.databind.ObjectMapper;
            import com.zrx.SpringbootRelearnApplication;
            import com.zrx.utils.Logger;
            import org.springframework.stereotype.Component;
            import org.springframework.web.bind.annotation.*;
            
            import java.util.*;
            
            /**
             * Description
             * 学习RESTFUL
             * <p>
             * Data
             * 15:05
             *
             * @author zrx
             * @version 1.0
             */
            
            @CrossOrigin
            @RestController
            public class RestfulLearnController {
                private final ObjectMapper mapper = new ObjectMapper();
            
                @GetMapping("/emp/{id}")
                public String getEmp(@PathVariable("id") Integer id) throws JsonProcessingException {
                    Logger.getLogger().info("/emp收到添加请求：" + id);
                    return mapper.writeValueAsString(map.getOrDefault(id, new Employee(404, "员工不存在")));
                }
            
                @GetMapping("/emps")//GET 请求，获取全部数据
                public String list() throws JsonProcessingException {
                    Logger.getLogger().info("/emps被访问（获取员工列表）");
                    return mapper.writeValueAsString(map.values().toArray());
                }
            
                @PostMapping("/emp") //POST 请求，上传数据
                //使用@RequestBody 自动识别请求为application/json 然后封装为对象
                public String addEmps(@RequestBody Employee employee) throws JsonProcessingException {
                    Logger.getLogger().info("/emp收到添加请求（添加员工）：" + employee);
                    map.put(employee.id, employee);
                    return mapper.writeValueAsString(new Employee(200, "OK"));
                }
            
                @PutMapping("/emp") //PUT 请求，修改员工
                public String updateEmp(@RequestBody Employee employee) throws JsonProcessingException {
                    Logger.getLogger().info("/emp/{id} 修改员工" + employee);
                    if (map.containsKey(employee.id)) {
                        Employee oldEmp = map.get(employee.id);
                        map.put(employee.id, employee);
                        Logger.getLogger().info("成功修改员工" + employee);
            
                        return mapper.writeValueAsString(oldEmp);
                    } else {
                        Logger.getLogger().info("要修改的员工不存在");
                        return mapper.writeValueAsString(new Employee(404, "要修改的员工不存在"));
                    }
                }
            
                @DeleteMapping("/emp/{id}")
                public String delEmp(@PathVariable("id") Integer id) throws JsonProcessingException{
                    Logger.getLogger().info("/emp/{id} 删除员工" + id);
                    Employee employee = map.getOrDefault(id, null);
                    if(employee==null){
                        Logger.getLogger().info("要删除的员工不存在");
                        return mapper.writeValueAsString(new Employee(404, "要删除的员工不存在"));
                    }else {
                        Logger.getLogger().info("员工" + employee + "删除成功");
                        map.remove(id);
                        return mapper.writeValueAsString(employee);
                    }
                }
            
            
                //数据
                Map<Integer, Employee> map = new HashMap<>();
            
                {
                    for (int i = 0; i < 25; i++) {
                        map.put(101 + i,
                                new Employee(101 + i, String.valueOf((char) ('a' + i)).repeat(3))
                        );
                    }
                }
            
            
                //员工类
                private static class Employee {
                    private Integer id;
                    private String name;
            
                    @Override
                    public String toString() {
                        return "Employee{" +
                                "id=" + id +
                                ", name='" + name + '\'' +
                                '}';
                    }
            
                    public Employee() {
            
                    }
            
                    public Employee(Integer id, String name) {
                        this.id = id;
                        this.name = name;
                    }
            
                    public Integer getId() {
                        return id;
                    }
            
                    public void setId(Integer id) {
                        this.id = id;
                    }
            
                    public String getName() {
                        return name;
                    }
            
                    public void setName(String name) {
                        this.name = name;
                    }
                }
            }"
          - 以上请求测试，所用的Vue
            "前后端分离的酸爽
            -----------------------------------------
            <template>
              <div>
                <button @click="getList">获取员工列表</button>
                <button @click="emptyList">清空员工列表</button>
                <br>
                <button @click="addEmp">添加员工</button>
                <button @click="updateEmp">修改员工</button>
                <input type="text" v-model="id">
                <input type="text" v-model="name">
                <br>
                <button @click="getEmp">获取员工</button>
                <button @click="delEmp">删除员工</button>
                <input type="text" v-model="id">
            
                <hr/>
                <table>
                  <thead>
                  <td>id</td>
                  <td>name</td>
                  </thead>
                  <tr v-for="e in emps">
                    <td>{{e.id}}</td>
                    <td>{{e.name}}</td>
                  </tr>
                </table>
                <p>{{message}}</p>
              </div>
            </template>
            
            <script>
              import {request} from "../../network/request";
            
              export default {
                name: "SpringbootTest",
                data(){
                  return{
                    emps:[],
                    message:"新页面",
                    id:0,
                    name:'请输入姓名'
                  };
                },
                methods:{
                  getList(){
                    this.message="正在发送请求";
                    request({
                      url:'http://localhost:8079/emps',
                      // method:'get'
                    }).then(res=>{
                      console.log(res);
                      this.emps = res.data;
                      this.message="拿到请求";
                    }).catch(err=>{
                      this.message="请求失败";
                    })
                  },
                  emptyList(){
                    this.emps=[];
                    this.message='删除了员工列表';
                  },
                  addEmp(){
                    const newEmp = {id:this.id,name:this.name};
                    this.message="正在添加员工" + newEmp;
                    request({
                      url:'http://localhost:8079/emp',
                      method:'post',
                      data:newEmp
                    }).then(res=>{
                      console.log(res.data);
                      this.message=res.data;
                    }).catch(err=>{
                      this.message="请求失败";
                    })
                  },
                  getEmp(){
                    request({
                      url:'http://localhost:8079/emp/' + this.id,
                      method: 'get'
                    }).then(res=>{
                      this.message = "员工信息为{"+ res.data.id + "," + res.data.name + "]";
                    }).catch(err=>console.log(err))
                  },
                  updateEmp(){
                    const emp = {
                      id:this.id,
                      name:this.name
                    };
                    console.log(emp);
                    request({
                      url:'http://localhost:8079/emp/',
                      method:'put',
                      data:emp
                    }).then(res=>{
                      this.message="旧员工信息为{"+ res.data.id + "," + res.data.name + "]";
                    }).catch(err=>console.log(err))
                  },
                  delEmp(){
                    request({
                      url:'http://localhost:8079/emp/' + this.id,
                      method:'delete'
                    }).then(res=>{
                      this.message = "被删除的员工信息为{"+ res.data.id + "," + res.data.name + "]";
                    }).catch(err=>console.log(err));
                  }
                }
              }
            </script>
            
            <style scoped>
            
            </style>"
        - 错误页面
          - 默认下电脑访问出现错误页面，手机访问返回错误的json数据
            "错误默认处理流程：
            1. 一旦出现4XX / 5XX 的错误
            2. ErrorPageCustomizer 会生效 - 定制错误的相应规则
            	会转发到/error 请求
            3. BasicErrorController 会响应/error 请求
            	根据浏览器是电脑还是手机，响应不同的数据(HTML/JSON)
            	具体规则：浏览器的accept优先是text/html，则发html，accept: 'application/json' 则返回JSON
            4. DefaultErrorViewReslover 解析响应什么格式的请求(html/json)
            
            
            示例
            -----------------
            GET http://localhost:8079/emps1
            Accept: application/json
            #{
            #  "timestamp": "2020-01-30T02:45:16.482+0000",
            #  "status": 404,
            #  "error": "Not Found",
            #  "message": "No message available",
            #  "path": "/emps1"
            #}
            ###
            
            GET http://localhost:8079/emps1
            Accept: text/html
            #<html>
            #<body><h1>Whitelabel Error Page</h1>
            #<p>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p>
            #<div id='created'>Thu Jan 30 10:50:37 CST 2020</div>
            #<div>There was an unexpected error (type=Not Found, status=404).</div>
            #<div>No message available</div>
            #</body>
            #</html>
            ###"
          - ⭐定制错误时返回JSON数据
            - 第一步 构造异常类
              "//异常类
              private static class EmployeeNotExistException extends RuntimeException{
                  public EmployeeNotExistException(){
                      super("用户不存在");
                      Logger.getLogger().info("EmployeeNotExistException 异常被创建");
                  }
              }"
            - 第二步 构造异常处理类 - 底层是AOP @ControllerAdvice  @ExceptionHandler 
              "//异常处理器 -> AOP
              @ControllerAdvice
              private static class EmployeeNotExistExceptionHandle{
              
                  //异常处理。注解包含异常的类
                  @ExceptionHandler(EmployeeNotExistException.class)
                  @ResponseBody//handleException就是一个controller-method，这个注解表示返回值RESTFUL风格
                  public String handleException(EmployeeNotExistException e) throws JsonProcessingException{
                      Logger.getLogger().info("正在处理JsonProcessingException异常");
                      return mapper.writeValueAsString(new Employee(404,"用户不存在 form ExceptionHandler"));
                  }
              
              
              
                  private final ObjectMapper mapper = new ObjectMapper();
              }"
            - 第三步 在controller中抛出异常
              "if(employee==null){
                  Logger.getLogger().info("要删除的员工不存在");
                  throw new EmployeeNotExistException();
              }"
            - 另 使用 @ExceptionHandler(Exception.class) 拦截所有其他异常
        - ⭐返回图片 bufferImage
          "@GetMapping(value = "/picture/width/{width}/height/{height}/color/{r}/{g}/{b}/info/{info}", produces = MediaType.IMAGE_JPEG_VALUE)
          public Object getPicture(@PathVariable("width") int width,
                                   @PathVariable("height") int height,
                                   @PathVariable("r") int r,
                                   @PathVariable("g") int g,
                                   @PathVariable("b") int b,
                                   @PathVariable("info") String info) throws Exception {
              LOGGER.info("get mapping /test/json/picture/width/{}/height/{}/color/{}/{}/{}/info/{}",width,height,r,g,b,info);
          
              BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR);
              Graphics graphics = bufferedImage.getGraphics();
              graphics.setColor(new Color(r, g, b));
              graphics.fillRect(0, 0, width, height);
          
              graphics.setColor(Color.black);
              graphics.setFont(new Font(Font.SERIF,Font.ITALIC,height/10));
              graphics.drawString(info, RANDOM.nextInt(width / 2), RANDOM.nextInt(height / 2));
          
              ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
              ImageIO.write(bufferedImage, "jpeg", byteArrayOutputStream);
              final byte[] bytes = byteArrayOutputStream.toByteArray();
              byteArrayOutputStream.close();
              return bytes;
          
          }"
      - 数据库 mybatis
        - 配置 data source 数据源
          - pom导入依赖
            "<dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-configuration-processor</artifactId>
            </dependency>
            
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-jdbc</artifactId>
            </dependency>
            
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
            </dependency>"
          - 配置文件
            "# 数据库 jdbc访问模式
            spring.datasource.username=root
            spring.datasource.password=123456
            spring.datasource.url=jdbc:mysql://192.168.2.3:3306/testAndLearn?serverTimezone=Asia/Shanghai
            spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver"
          - 使用方法
            "拿到了数据库连接池和连接
            --------------------------------
            @SpringBootTest
            public class JdbcTest {
                @Autowired
                private DataSource dataSource;
            
                @Test
                public void dataSourceInject() throws SQLException {
                    System.out.println("dataSource = " + dataSource);
                    System.out.println("dataSource.getClass() = " + dataSource.getClass());
            
                    //dataSource = HikariDataSource (null)
                    //dataSource.getClass() = class com.zaxxer.hikari.HikariDataSource
            
                    Connection connection = dataSource.getConnection();
            
                    //connection = HikariProxyConnection@1994834032 wrapping com.mysql.cj.jdbc.ConnectionImpl@184afb78
            
                    System.out.println("connection = " + connection);
                }
            }"
          - 换成 Druid 数据源
            "duird的好处
            --------------
            Hikari号称JAVA领域中最快的数据连接池，你可去点连接进去看看，第一行就是说他自己多么厉害，秒杀什么什么的，不过再快我也觉得没有阿里巴巴奉献给apache的Druid好，因为阿里巴巴的服务周到，里面有监控中心，可以帮助我们快速定位慢sql等。
            
            第一步 POM导入
            -----------------
            × https://mvnrepository.com/artifact/com.alibaba/druid
            以上过失，有自己的starter
            <!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter -->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid-spring-boot-starter</artifactId>
                <version>1.1.21</version>
            </dependency>
            
            
            第二步 配置 type
            ----------------------
            spring.datasource.username=root
            spring.datasource.password=123456
            spring.datasource.url=jdbc:mysql://192.168.2.3:3306/testAndLearn?serverTimezone=Asia/Shanghai
            spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
            spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
            
            最后测试
            -----------------
            输出
            --------------------
            dataSource = {
            	CreateTime:"2020-01-30 22:18:18",
            	ActiveCount:0,
            	PoolingCount:0,
            	CreateCount:0,
            	DestroyCount:0,
            	CloseCount:0,
            	ConnectCount:0,
            	Connections:[
            	]
            }
            dataSource.getClass() = class com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper
            connection = com.mysql.cj.jdbc.ConnectionImpl@5f5297e3"
          - 对 Druid 数据源深度配置 + 监控功能
            - 第一步 配置文件
              "# 数据库 jdbc访问模式
              spring.datasource.username=root
              spring.datasource.password=123456
              spring.datasource.url=jdbc:mysql://192.168.2.3:3306/testAndLearn?serverTimezone=Asia/Shanghai
              spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
              spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
              # druid 数据源配置
              spring.datasource.initialSize: 5
              spring.datasource.minIdle: 5
              spring.datasource.maxActive: 20
              spring.datasource.maxWait: 60000
              spring.datasource.timeBetweenEvictionRunsMillis: 60000
              spring.datasource.minEvictableIdleTimeMillis: 300000
              spring.datasource.validationQuery: SELECT 1 FROM DUAL
              spring.datasource.testWhileIdle: true
              spring.datasource.testOnBorrow: false
              spring.datasource.testOnReturn: false
              spring.datasource.poolPreparedStatements: true
              ##配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
              spring.datasource.filters: stat,wall
              spring.datasource.maxPoolPreparedStatementPerConnectionSize: 20
              spring.datasource.useGlobalDataSourceStat: true  
              spring.datasource.connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500"
            - 第二步 配置config类手动拿到 dataSource
              "@Configuration
              public class DruidConfig {
                  //手动new出这个bean，就可以使用配置文件了
                  @ConfigurationProperties(prefix = "spring.datasource")
                  @Bean
                  public DataSource druidDataSource(){
                      return new DruidDataSource();
                  }
              }"
            - 第三步 使用 servlet 和 filter 设置监控相关(这里的配置应该抽出来)
              "//配置druid监控
              //配置一个管理后台的servlet
              @Bean
              public ServletRegistrationBean<StatViewServlet> statViewServlet(){
                  ServletRegistrationBean<StatViewServlet> bean =
                          new ServletRegistrationBean<>(new StatViewServlet(), "/druid/*");
              
                  Map<String,String> initParameters = new HashMap<>();
                  initParameters.put("loginUsername","admin");
                  initParameters.put("loginPassword","123456");
                  initParameters.put("allow","localhost");
                  initParameters.put("deny","192.168.2.254");
              
                  bean.setInitParameters(initParameters);
              
                  return bean;
              }
              
              //配置一个监控的filter
              @Bean
              public FilterRegistrationBean<WebStatFilter> webStatFilter(){
                  FilterRegistrationBean<WebStatFilter> bean = new FilterRegistrationBean<>();
                  bean.setFilter(new WebStatFilter());
              
                  Map<String,String> initParameters = new HashMap<>();
                  initParameters.put("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,");
              
                  bean.setInitParameters(initParameters);
                  bean.setUrlPatterns(Collections.singletonList("/*"));
              
                  return bean;
              }"
            - 总的代码
              "/**
               * Description
               * DruidConfig 数据源配置类
               * <p>
               * Data
               * 22:22
               *
               * @author zrx
               * @version 1.0
               */
              
              @Configuration
              public class DruidConfig {
                  //手动new出这个bean，就可以使用配置文件了
                  @ConfigurationProperties(prefix = "spring.datasource")
                  @Bean
                  public DataSource druidDataSource(){
                      return new DruidDataSource();
                  }
              
                  //配置druid监控
                  //配置一个管理后台的servlet
                  @Bean
                  public ServletRegistrationBean<StatViewServlet> statViewServlet(){
                      ServletRegistrationBean<StatViewServlet> bean =
                              new ServletRegistrationBean<>(new StatViewServlet(), "/druid/*");
              
                      Map<String,String> initParameters = new HashMap<>();
                      initParameters.put("loginUsername","admin");
                      initParameters.put("loginPassword","123456");
                      initParameters.put("allow","localhost");
                      initParameters.put("deny","192.168.2.254");
              
                      bean.setInitParameters(initParameters);
              
                      return bean;
                  }
              
                  //配置一个监控的filter
                  @Bean
                  public FilterRegistrationBean<WebStatFilter> webStatFilter(){
                      FilterRegistrationBean<WebStatFilter> bean = new FilterRegistrationBean<>();
                      bean.setFilter(new WebStatFilter());
              
                      Map<String,String> initParameters = new HashMap<>();
                      initParameters.put("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,");
              
                      bean.setInitParameters(initParameters);
                      bean.setUrlPatterns(Collections.singletonList("/*"));
              
                      return bean;
                  }
              
              
              }"
        - 整合MyBatis
          - 第一步 POM
            "<!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter -->
            <dependency>
                <groupId>org.mybatis.spring.boot</groupId>
                <artifactId>mybatis-spring-boot-starter</artifactId>
                <version>2.1.1</version>
            </dependency>"
          - 第二步 写mapper @Repository  @Mapper 
            "@Repository
            @Mapper //告诉 mybatis 这是一个操作数据库的mapper
            public interface PersonMapper {
            
                @Select("select * from person where id = #{id}")
                public Person getPersonById(Integer id);
            
                public static class Person{
                    private Integer id;
                    private String name;
            
                    @Override
                    public String toString() {
                        return "Person{" +
                                "id=" + id +
                                ", name='" + name + '\'' +
                                '}';
                    }
            
                    public Integer getId() {
                        return id;
                    }
            
                    public void setId(Integer id) {
                        this.id = id;
                    }
            
                    public String getName() {
                        return name;
                    }
            
                    public void setName(String name) {
                        this.name = name;
                    }
                }
            }"
          - 最后测试
            "@RestController
            public class MybatisTestController {
                @Autowired
                PersonMapper personMapper;
            
                ObjectMapper objectMapper = new ObjectMapper();
            
                @GetMapping("/person/{id}")
                public String getPersonById(@PathVariable("id") Integer id) throws JsonProcessingException {
                    return objectMapper.writeValueAsString(
                            personMapper.getPersonById(id)
                    );
                }
            }"
          - mabatis的配置->写配置类
            "@Configuration
            public class MyBatisConfig {
                @Bean
                public ConfigurationCustomizer configurationCustomizer(){
                    return new ConfigurationCustomizer(){
                        @Override
                        public void customize(org.apache.ibatis.session.Configuration configuration) {
                            //可以表中的 aaa_bbb 包装到 aaaBbb 字段上
            //                configuration.setMapUnderscoreToCamelCase(true);
                        }
                    };
                }
            }"
          - 其他
            - #{} ${} 的区别
              "1、#{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号，如上面的值 “4,44,514”就会变成“ '4,44,514' ”；
              
              2、${ }是字符串替换， MyBatis在处理${ }时,它会将sql中的${ }替换为变量的值，传入的数据不会加两边加上单引号。"
            - 属性名 和 字段名 不一致
              "@Select("SELECT * FROM department WHERE did = #{id}")
              @Results({
                      @Result(property = "id",column = "did",id = true)
              })
              Department getDepartmentById(int id);"
            - 日志打印
              "配置中：logging.level.com.madokast.privacy.learn.mapper = debug
              
              其中 com.madokast.privacy.learn.mapper 是我的mapper 包"
      - springboot启动中的钩子
        - 启动流程
          - 1. 创建 SpringApplication 对象
            "public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
               return new SpringApplication(primarySources).run(args);
            }
            
            ---->
            this.primarySources  主配置类
            
            this.webApplicationType 推断是不是web应用 （具体是何种web应用 SERVLET）
            
            setInitializers //从类路径下找到META-INF/spring.factories配置的所有applicationInitializer 然后保存
            -----------
            找到了六个
            this.initializers = {ArrayList@2160}  size = 7
             0 = {DelegatingApplicationContextInitializer@2162} 
             1 = {SharedMetadataReaderFactoryContextInitializer@2163} 
             2 = {ContextIdApplicationContextInitializer@2164} 
             3 = {ConfigurationWarningsApplicationContextInitializer@2165} 
             4 = {RSocketPortInfoApplicationContextInitializer@2166} 
             5 = {ServerPortInfoApplicationContextInitializer@2167} 
             6 = {ConditionEvaluationReportLoggingListener@2168} 
            -----------------
            
            setListeners //类路径下找到META-INF/spring.factories 找applicationListener
            ---------------
            找到了11个
            this.listeners = {ArrayList@2227}  size = 11
             0 = {CloudFoundryVcapEnvironmentPostProcessor@2229} 
             1 = {ConfigFileApplicationListener@2230} 
             2 = {AnsiOutputApplicationListener@2231} 
             3 = {LoggingApplicationListener@2232} 
             4 = {ClasspathLoggingApplicationListener@2233} 
             5 = {BackgroundPreinitializer@2234} 
             6 = {DelegatingApplicationListener@2235} 
             7 = {ParentContextCloserApplicationListener@2236} 
             8 = {ClearCachesApplicationListener@2237} 
             9 = {FileEncodingApplicationListener@2238} 
             10 = {LiquibaseServiceLocatorApplicationListener@2239} 
            ------------------
            
            this.mainApplicationClass = deduceMainApplicationClass();//决定哪一个application class 是一个主程序
            也就是看传进来的所有配置类，拿给有main方法
            
            
            /**
             * Create a new {@link SpringApplication} instance. The application context will load
             * beans from the specified primary sources (see {@link SpringApplication class-level}
             * documentation for details. The instance can be customized before calling
             * {@link #run(String...)}.
             * @param resourceLoader the resource loader to use
             * @param primarySources the primary bean sources
             * @see #run(Class, String[])
             * @see #setSources(Set)
             */
            @SuppressWarnings({ "unchecked", "rawtypes" })
            public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
               this.resourceLoader = resourceLoader;
               Assert.notNull(primarySources, "PrimarySources must not be null");
               this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
               this.webApplicationType = WebApplicationType.deduceFromClasspath();
               setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
               setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
               this.mainApplicationClass = deduceMainApplicationClass();
            }"
          - 2. 运行 run 方法
            "/**
             * Run the Spring application, creating and refreshing a new
             * {@link ApplicationContext}.
             * @param args the application arguments (usually passed from a Java main method)
             * @return a running {@link ApplicationContext}
             */
            public ConfigurableApplicationContext run(String... args) {
            
            //监听 计时器
               StopWatch stopWatch = new StopWatch();
               stopWatch.start();
            
            //IOC容器=》下面的try中创建
               ConfigurableApplicationContext context = null;
            
            //异常报告
               Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
            
               configureHeadlessProperty();
            
            //run 监听器。来自 META-INF/spring.factories
            //拿到 EventPublishingRunListener 
               SpringApplicationRunListeners listeners = getRunListeners(args);
            
            // SpringApplicationRunListeners 全部开始 (回调)
               listeners.starting();
            
            
               try {
            //封装命令行参数
                  ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            
            //准备环境。获取+准备+回调SpringApplicationRunListeners的environmentPrepared方法=》表示环境准备完成
                  ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
            
                  configureIgnoreBeanInfo(environment);
            
            //准备，打印banner 
                  Banner printedBanner = printBanner(environment);
            
            //创建IOC容器 servlet？reactor？non-web？
                  context = createApplicationContext();
            
            //异常分析报告
                  exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                        new Class[] { ConfigurableApplicationContext.class }, context);
            
            //准备上下文 保存environment  listeners applicationArguments
            //进行了 initializer.initialize(context); 这首个回调 这里的initializer来自第一步的setInitializers 
            //紧接着有 listeners.contextLoaded(context); 也是回调
            //这个运行完后，全部环境准备好了
            //LOG输出
            ------------------------------
            2020-01-31 11:41:24.928  INFO 21784 --- [           main] com.zrx.SpringbootRelearnApplication     : Starting SpringbootRelearnApplication on DESKTOP-A8S64LR with PID 21784 (O:\Documents\GitHub\JavaLearn2020\springbootRelearn\target\classes started by madokast_dell in O:\Documents\GitHub\JavaLearn2020\springbootRelearn)
            2020-01-31 11:41:25.004 DEBUG 21784 --- [           main] com.zrx.SpringbootRelearnApplication     : Running with Spring Boot v2.2.4.RELEASE, Spring v5.2.3.RELEASE
            2020-01-31 11:41:25.008  INFO 21784 --- [           main] com.zrx.SpringbootRelearnApplication     : No active profile set, falling back to default profiles: default
            
            -------------------------------
                  prepareContext(context, environment, listeners, applicationArguments, printedBanner);
            
            //刷新刷新，扫描并创建所有的组件，嵌入式tomcat也创建了
            //LOG输出一堆东西
            ----------------------------------------
            2020-01-31 11:43:31.637  INFO 21784 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8079 (http)
            2020-01-31 11:43:31.745  INFO 21784 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
            2020-01-31 11:43:31.747  INFO 21784 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.30]
            2020-01-31 11:43:32.477  INFO 21784 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
            2020-01-31 11:43:32.479  INFO 21784 --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 11293 ms
            2020-01-31 11:43:34.906  INFO 21784 --- [           main] f.a.AutowiredAnnotationBeanPostProcessor : Autowired annotation should only be used on methods with parameters: public java.lang.String com.zrx.controller.HelloController.hello()
            2020-01-31 11:43:38.156  INFO 21784 --- [           main] com.zrx.config.MyConfig                  : someBean 初始化成功
            2020-01-31 11:43:39.375  INFO 21784 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
            2020-01-31 11:43:42.776  INFO 21784 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8079 (http) with context path ''
            
            ----------------------------------------
                  refreshContext(context);
            
            //这里面拿另外两个回调，并执行
            //runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
            //runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
            //然后这里面还回调
                  afterRefresh(context, applicationArguments);
            
            //
                  stopWatch.stop();
                  if (this.logStartupInfo) {
                     new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
                  }
            
            //listeners.started 回调
                  listeners.started(context);
                  callRunners(context, applicationArguments);
               }
               catch (Throwable ex) {
                  handleRunFailure(context, ex, exceptionReporters, listeners);
                  throw new IllegalStateException(ex);
               }
            
               try {
            //listeners.running回调
                  listeners.running(context);
               }
               catch (Throwable ex) {
                  handleRunFailure(context, ex, exceptionReporters, null);
                  throw new IllegalStateException(ex);
               }
            
            //返回IOC
               return context;
            }"
        - 启动中包含一些重要的回调事件 运用练习
          "配置在META-INF/spring.factoris
          ApplicationContextListener
          ApplicationRunListener
          
          //在IOC容器中的
          ApplicationRunner 
          commandLineRunner"
          - ApplicationContextInitializer
            "实现类
            --------------
            public class HelloApplicationContextInitializer
                    implements ApplicationContextInitializer<ConfigurableApplicationContext> {
                @Override
                public void initialize(ConfigurableApplicationContext configurableApplicationContext) {
                    Logger.getLogger().info("HelloApplicationContextInitializer.initialize()..." +
                            configurableApplicationContext);
                }
            }
            
            配置
            -------------
            在resource 文件夹下创建META-INF 文件夹
            下新建spring.factories
            
            写入
            # initializers
            org.springframework.context.ApplicationContextInitializer=\
              com.zrx.listener.HelloApplicationContextInitializer"
          - SpringApplicationRunListeners
            "实现类
            --------------
            public class HelloSpringApplicationRunListener
                    implements SpringApplicationRunListener {
            
                public HelloSpringApplicationRunListener(SpringApplication application, String[] args) {}
            
            
            
                @Override
                public void starting() {
                    Logger.getLogger().info("HelloSpringApplicationRunListener.starting()...");
                }
            
                @Override
                public void environmentPrepared(ConfigurableEnvironment environment) {
                    Logger.getLogger().info("HelloSpringApplicationRunListener.environmentPrepared()..."
                    + environment.getSystemProperties().get("os.name"));
                }
            
                @Override
                public void contextPrepared(ConfigurableApplicationContext context) {
                    Logger.getLogger().info("HelloSpringApplicationRunListener.contextPrepared()...");
                }
            
                @Override
                public void contextLoaded(ConfigurableApplicationContext context) {
                    Logger.getLogger().info("HelloSpringApplicationRunListener.contextPrepared()...");
                }
            
                @Override
                public void started(ConfigurableApplicationContext context) {
                    Logger.getLogger().info("HelloSpringApplicationRunListener.started()...");
                }
            
                @Override
                public void running(ConfigurableApplicationContext context) {
                    Logger.getLogger().info("HelloSpringApplicationRunListener.running()...");
                }
            
                @Override
                public void failed(ConfigurableApplicationContext context, Throwable exception) {
                    Logger.getLogger().info("HelloSpringApplicationRunListener.failed()...");
                }
            }
            
            配置
            -------------
            在resource 文件夹下创建META-INF 文件夹
            下新建spring.factories
            
            写入
            # listener
            org.springframework.boot.SpringApplicationRunListener=\
              com.zrx.listener.HelloSpringApplicationRunListener"
          - ApplicationRunner
            "@Component
            public class HelloApplicationRunner implements ApplicationRunner {
                @Override
                public void run(ApplicationArguments args) throws Exception {
                    Logger.getLogger().info("HelloApplicationRunner.run()...");
                }
            }"
          - commandLineRunner
            "@Component
            public class HelloCommandLineRunner implements CommandLineRunner {
                @Override
                public void run(String... args) throws Exception {
                    Logger.getLogger().info("HelloCommandLineRunner.run()..." + Arrays.toString(args));
                }
            }"
      - 缓存 redis
        - spring内置缓存器
          - 简单使用（底层：concurrent hash map）
            "1. 在启动类中加上注释
            	@EnableCaching // 开启基于注解的缓存
            2. 在 service 类的方法上注解
            	@Cacheable(cacheNames = "employee", condition = "#id>0", unless = "#result==null")"
          - @Cacheable  使用方法
            "放在 方法 上，缓存 方法 的 返回值
            * cacheNames 缓存名字，缓存组件的名字
            * key 缓存数据时使用的key。默认是方法参数的值
            * keyGenerator key生成器 和key二选一
            * cacheManager 缓存管理器
            * condition 指定条件成立的时候在缓存
            * unless 条件成立 不缓存
            * sync 异步模式"
          - @CachePut 
            "即执行方法，也放入缓存。使用场景：数据库的update
            数据库更新数据，同时把数据放入缓存，这样其他的方法这个数据时，就可以直接从缓存中取"
          - @CacheEvict 
            "执行方法，同时删除缓存。使用场景：数据库的delete"
          - @Caching 
            "以上三个方法的组合"
        - redis 缓存
          "当spring配置redis后，就不再使用内置缓存，而是用redis作为缓存
          所以关于 redis 的缓存配置 见上一节 《spring内置缓存器》"
          - docker 安装 redis
            "1. 下载
            	 docker pull redis
            2. 启动
            	docker run -d -p 6379:6379 --name redis0312 7eed8df88d3b"
          - 安装依赖 maven pom
            "<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-redis</artifactId>
                <version>2.2.5.RELEASE</version>
            </dependency>"
          - 配置信息 application.properties
            "spring.redis.host=192.168.2.3"
          - 注入 redis template
            "@Autowired
            private StringRedisTemplate stringRedisTemplate; //操作字符串"
          - 使用
            "stringRedisTemplate.opsForValue().append("msg","!!");
            stringRedisTemplate.opsForValue().get("msg");"
          - 保存object为json数据（手动使用redis时）
            "例子：保存Employee 为 Json
            1. Employee  序列化
            	Employee implements Serializable
            2. 定义自己的 redis 模板
            -------------------------------
            @Configuration
            public class RedisConfig {
            
                @Bean
                public RedisTemplate<String, Employee> employeeRedisTemplate(RedisConnectionFactory redisConnectionFactory)
                        throws UnknownHostException {
                    RedisTemplate<String, Employee> template = new RedisTemplate<>();
                    template.setConnectionFactory(redisConnectionFactory);
                    Jackson2JsonRedisSerializer<Employee> serializer = new Jackson2JsonRedisSerializer<>(Employee.class);
            
                    template.setDefaultSerializer(serializer);
            
                    return template;
                }
            }
            -------------------------------
            3. 使用它
            @Autowired
            private RedisTemplate<String,Employee> employeeRedisTemplate;"
          - 保存object为json数据（spring的缓存调用redis时）
            "需要自己写 cache template 和 cache manager
            "
            - 配置类
              "package com.madokast.privacy.learn.config;
              
              import com.madokast.privacy.learn.bean.Employee;
              import org.springframework.context.annotation.Bean;
              import org.springframework.context.annotation.Configuration;
              import org.springframework.data.redis.cache.RedisCacheConfiguration;
              import org.springframework.data.redis.cache.RedisCacheManager;
              import org.springframework.data.redis.cache.RedisCacheWriter;
              import org.springframework.data.redis.connection.RedisConnectionFactory;
              import org.springframework.data.redis.core.RedisTemplate;
              import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
              import org.springframework.data.redis.serializer.RedisSerializationContext;
              
              import java.net.UnknownHostException;
              import java.util.Objects;
              
              /**
               * Description
               * RedisConfig
               * 自己的redis模板
               * 在于将 Employee 存储为 json 字符串 格式
               * <p>
               * Data
               * 21:37
               *
               * @author zrx
               * @version 1.0
               */
              
              @Configuration
              public class RedisConfig {
              
                  /**
                   * 让 redis 保存为 Json 数据
                   * @param redisConnectionFactory ？
                   * @return 一个redis template 类似于 jdbc template
                   * @throws UnknownHostException ？
                   */
                  @Bean
                  public RedisTemplate<String, Employee> employeeRedisTemplate(RedisConnectionFactory redisConnectionFactory)
                          throws UnknownHostException {
                      RedisTemplate<String, Employee> template = new RedisTemplate<>();
                      template.setConnectionFactory(redisConnectionFactory);
                      Jackson2JsonRedisSerializer<Employee> serializer = new Jackson2JsonRedisSerializer<>(Employee.class);
              
                      template.setDefaultSerializer(serializer);
              
                      return template;
                  }
              
                  @Bean
                  public RedisCacheManager employeeRedisCacheManager(RedisTemplate<String, Employee> employeeRedisTemplate){
                      RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(
                              Objects.requireNonNull(employeeRedisTemplate.getConnectionFactory()));
                      RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()
                              .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(
                                      employeeRedisTemplate.getValueSerializer()));
                      return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);
                  }
              
              }"
            - 指定 manager 并使用
              "@Cacheable(cacheNames = "employee", condition = "#id>0", unless = "#result==null",cacheManager = "employeeRedisCacheManager")
              public Employee getEmployeeById(Integer id) {
                  LOGGER.info("数据库查询{}号员工", id);
                  return employeeMapper.getEmployeeById(id);
              }"
      - 消息 RabbitMQ
        - 安装 和 web配置
          - 安装 docker pull rabbitmq:3.8-management
            "-management 带有 管理界面"
          - 运行 docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq0313 3658aa401173
            "两个端口 5672 15672
            前者 服务
            后者 管理界面"
          - 访问管理界面 http://192.168.2.3:15672/ 
            "默认登陆 guest guest"
          - 创建 exchange
            "进入管理界面
            进入 exchange 界面
            点击 Add a new exchange
            可以指定 类型 和 持久化机制
            
            示例创建三个不同的 exchange	
            mdk.direct
            mdk.fanout	
            mdk.topic
            "
          - 创建 queue
            "进图队列界面
            创建队列
            
            miao
            miao.news
            miao.emps.
            zrx.news"
          - 绑定 exchange 和 queue
            "进入 exchange 界面
            需要输入 queue 的名字和 key
            
            key 中可以使用 #
            
            To	Routing key	Arguments	
            miao
            miao.#	
            miao.emps
            miao.#	
            miao.news
            #.news	
            zrx.news
            #.news	
            "
          - 在管理界面发送消息
            "进入 exchange ，点击 Publish message
            发送消息
            注意指定key"
          - 在管理界面接收消息
            "进入 queue 点击 get message"
        - springboot 配置 rabbitMQ
          - maven pom文件
            "<dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-amqp</artifactId>
            </dependency>"
          - 配置文件 application.properties
            "spring.rabbitmq.host=192.168.2.3
            spring.rabbitmq.username=guest
            spring.rabbitmq.password=guest
            #spring.rabbitmq.port=5672
            #spring.rabbitmq.virtual-host"
        - 简单使用 convertAndSend & receiveAndConvert
          "@RunWith(SpringRunner.class)
          @SpringBootTest
          public class RabbitMqLearn {
              private static final Logger LOGGER = LoggerFactory.getLogger(RabbitMqLearn.class);
          
              @Autowired
              private RabbitTemplate rabbitTemplate;
          
              @Autowired
              private EmployeeCacheService employeeCacheService;
          
              @Test
              public void directTest(){
                  LOGGER.info("rabbit mq 单播 direct 测试");
          
                  //需要自己构造 message
                  //rabbitTemplate.send(String exchange, String routingKey, Message message);
                  //public Message(byte[] body, MessageProperties messageProperties)
          
                  // 自动把 object 转为 message -- 默认 Java 序列化
                  //rabbitTemplate.convertAndSend(String exchange, String routingKey, Object message);
          
                  final Employee employeeById = employeeCacheService.getEmployeeById(1);
                  rabbitTemplate.convertAndSend("mdk.direct","miao",employeeById);
          
                  //接受消息
                  final Object miao = rabbitTemplate.receiveAndConvert("miao");
                  LOGGER.info("miao = {}",miao);
              }
          
              @Test
              public void fanoutTest(){
                  LOGGER.info("rabbit mq 广播 fanout 测试");
              }
          
              @Test
              public void topicTest(){
                  LOGGER.info("rabbit mq 组播 topic 测试");
              }
          }"
        - 序列化方法转为Json (默认的是Java序列化
          "新建配置类，会自动注入
          @Configuration
          public class RabbitConfig {
          
              @Bean
              public MessageConverter messageConverter(){
                  return new Jackson2JsonMessageConverter();
              }
          }"
        - 监听队列 @EnableRabbit @RabbitListener(queues = {"miao"})
          "第一步，在main类上添加注解
          	@EnableRabbit //开启 rabbitMq
          
          第二步，使用 @RabbitListener
          
          @RabbitListener(queues = {"miao"})
          public void listen(Employee employee){
              LOGGER.info("RabbitMq监听到{}",employee);
          }
          
          @Test
          public void send(){
              for (int i = 10262; i < 10262+50; i++) {
                  final Employee employeeById = employeeCacheService.getEmployeeById(i);
                  rabbitTemplate.convertAndSend("mdk.direct", "miao", employeeById);
              }
          }"
        - 在程序中管理exchange/queue/binding: AmqpAdmin
          "private void amqpAdminLearn(){
              amqpAdmin.declareExchange(new DirectExchange("exchangeName"));
              
              amqpAdmin.declareQueue(new Queue("queueName"));
              
              amqpAdmin.declareBinding(new Binding("queueName",
                      Binding.DestinationType.QUEUE,
                      "exchangeName","key",null));
          }"
      - 搜索 ElasticSearch
        - 安装和简单使用
          "中文文档 https://es.xiaoleilu.com/010_Intro/20_Document.html"
          - docker pull elasticsearch
          - docker run -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -d -p 9200:9200 -p 9300:9300 --name es0314a 5acf0e8da90b
            "显示了Java内存使用大小
            9200作为Http协议，主要用于外部通讯
            9300作为Tcp协议，jar之间就是通过tcp协议通讯
            ES集群之间是通过9300进行通讯"
          - springboot 默认支持两种技术和ES交互
            - jest
              - maven 引入依赖
                "<!-- https://mvnrepository.com/artifact/io.searchbox/jest -->
                <dependency>
                    <groupId>io.searchbox</groupId>
                    <artifactId>jest</artifactId>
                    <version>6.3.1</version>
                </dependency>
                "
              - 配置url
                "spring.elasticsearch.jest.uris=http://192.168.2.3:9200"
              - 简单使用
                "package com.madokast.privacy.learn;
                
                import io.searchbox.annotations.JestId;
                import io.searchbox.client.JestClient;
                import io.searchbox.core.Index;
                import io.searchbox.core.Search;
                import io.searchbox.core.SearchResult;
                import org.junit.Test;
                import org.junit.runner.RunWith;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import org.springframework.beans.factory.annotation.Autowired;
                import org.springframework.boot.test.context.SpringBootTest;
                import org.springframework.test.context.junit4.SpringRunner;
                
                /**
                 * Description
                 * JestLearn
                 * <p>
                 * Data
                 * 9:42
                 *
                 * @author zrx
                 * @version 1.0
                 */
                
                @RunWith(SpringRunner.class)
                @SpringBootTest
                public class JestLearn {
                    private final Logger LOGGER = LoggerFactory.getLogger(JestLearn.class);
                
                    @Autowired
                    private JestClient jestClient;
                
                //    @Test
                    public void index()throws Exception{
                        // 索引文档 （保存到表）
                        Article article = new Article(1, "zhangsan", "好消息", "hello, world!");
                
                        // 构建索引
                        Index index = new Index.Builder(article).index("atguigu").type("news").build();
                
                        // 执行
                        jestClient.execute(index);
                
                        //成功索引文档 http://192.168.2.3:9200/atguigu/news/1
                        //{
                        //    "_index": "atguigu",
                        //    "_type": "news",
                        //    "_id": "1",
                        //    "_version": 1,
                        //    "found": true,
                        //    "_source": {
                        //        "id": 1,
                        //        "author": "zhangsan",
                        //        "title": "好消息",
                        //        "content": "hello, world!"
                        //    }
                        //}
                    }
                
                    @Test
                    public void search() throws Exception{
                        String json = "{\n" +
                                "    \"query\" : {\n" +
                                "        \"match\" : {\n" +
                                "            \"title\" : \"好消息\"\n" +
                                "        }\n" +
                                "    }\n" +
                                "}";
                
                        Search search = new Search.Builder(json).addIndex("atguigu").addType("news").build();
                
                        SearchResult searchResult = jestClient.execute(search);
                
                        LOGGER.info("searchResult.getJsonString() = {}", searchResult.getJsonString());
                        //{
                        //    "took": 5,
                        //    "timed_out": false,
                        //    "_shards": {
                        //        "total": 5,
                        //        "successful": 5,
                        //        "skipped": 0,
                        //        "failed": 0
                        //    },
                        //    "hits": {
                        //        "total": 1,
                        //        "max_score": 0.7594807,
                        //        "hits": [
                        //            {
                        //                "_index": "atguigu",
                        //                "_type": "news",
                        //                "_id": "1",
                        //                "_score": 0.7594807,
                        //                "_source": {
                        //                    "id": 1,
                        //                    "author": "zhangsan",
                        //                    "title": "好消息",
                        //                    "content": "hello, world!"
                        //                }
                        //            }
                        //        ]
                        //    }
                        //}
                    }
                
                
                    private static class Article{
                        @JestId
                        private Integer id;
                        private String author;
                        private String title;
                        private String content;
                
                        public Article(Integer id, String author, String title, String content) {
                            this.id = id;
                            this.author = author;
                            this.title = title;
                            this.content = content;
                        }
                
                        public Integer getId() {
                            return id;
                        }
                
                        public void setId(Integer id) {
                            this.id = id;
                        }
                
                        public String getAuthor() {
                            return author;
                        }
                
                        public void setAuthor(String author) {
                            this.author = author;
                        }
                
                        public String getTitle() {
                            return title;
                        }
                
                        public void setTitle(String title) {
                            this.title = title;
                        }
                
                        public String getContent() {
                            return content;
                        }
                
                        public void setContent(String content) {
                            this.content = content;
                        }
                
                        @Override
                        public String toString() {
                            return "Article{" +
                                    "id=" + id +
                                    ", author='" + author + '\'' +
                                    ", title='" + title + '\'' +
                                    ", content='" + content + '\'' +
                                    '}';
                        }
                    }
                }"
            - springdata elasticsearch
              "官方文档 https://spring.io/projects/spring-data-elasticsearch"
              - maven 引入依赖
                "<!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-elasticsearch -->
                <dependency>
                    <groupId>org.springframework.data</groupId>
                    <artifactId>spring-data-elasticsearch</artifactId>
                    <version>3.2.5.RELEASE</version>
                </dependency>
                "
              - 新建配置类
                "@Configuration
                public class RestClientConfig extends AbstractElasticsearchConfiguration {
                
                    @Override
                    @Bean
                    public RestHighLevelClient elasticsearchClient() {
                
                        final ClientConfiguration clientConfiguration = ClientConfiguration.builder()
                                .connectedTo("192.168.2.3:9200")
                                .build();
                
                        return RestClients.create(clientConfiguration).rest();
                    }
                }"
              - 建立repository类 用于操作es
                "public interface BookRepository extends CrudRepository<ElasticController.Book,Integer> {
                }"
              - 需要存储的对象 bean 类
                "@Document(indexName = "atguigu", type = "book")//索引(数据库)名，类型(表)名
                public static class Book {
                    private Integer id;
                    private String name;
                    private String author;
                    // 省略getter setter
                }"
              - 简单使用
                "// 注入
                private final BookRepository bookRepository;
                
                public ElasticController(BookRepository bookRepository) {
                    this.bookRepository = bookRepository;
                }
                
                @GetMapping("/index")
                public void index() {
                    LOGGER.info("get mapping /index");
                    Book book = new Book(1, "三国演绎", "罗贯中");
                    Book book1 = new Book(2, "四国演绎", "宋贯中");
                    bookRepository.save(book);
                    bookRepository.save(book1);
                }"
      - 任务
        - 异步任务
          - 主类开启异步 @EnableAsync 
          - 编写异步方法 为于service中 @Async 
            "@Service
            public class AsyncService {
                private final Logger LOGGER = LoggerFactory.getLogger(AsyncService.class);
            
                @Async
                public void task() {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    LOGGER.info("任务执行结束");
                }
            }"
          - 调用异步方法 位于controller中
            "@RestController
            public class AsyncController {
                private final Logger LOGGER = LoggerFactory.getLogger(AsyncController.class);
            
                private final AsyncService asyncService;
            
                public AsyncController(AsyncService asyncService) {
                    this.asyncService = asyncService;
                }
            
                @GetMapping("/async")
                public Object async(){
                    LOGGER.info("发布异步任务");
                    asyncService.task();
                    LOGGER.info("立即返回？");
                    return "success";
                }
            
            }"
        - 定时任务
          - 主类开启定时 @EnableScheduling
          - 编写定时任务
            "@Service
            public class ScheduledService {
                private final Logger LOGGER = LoggerFactory.getLogger(ScheduledService.class);
            
                @Scheduled(cron = "0-59 * * * * *") //每秒执行
                public void scheduleTask(){
                    if(started){
                        LOGGER.info("定期执行任务");
                    }
                }
            
                private boolean started = false;
            }"
        - 邮件任务
          - 引入依赖 maven
            "<dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-mail</artifactId>
            </dependency>"
          - 配置相关信息
            "# mail
            spring.mail.username=madokaworker@163.com
            spring.mail.password=AZEKOVEGDWJCMWCJ
            spring.mail.host=smtp.163.com
            spring.mail.properties.mail.smtp.ssl.enable=true"
          - 发送简单邮件 强
            "@RestController
            @RequestMapping("/mail")
            public class MailController {
            
                private final Logger LOGGER = LoggerFactory.getLogger(MailController.class);
            
                private final JavaMailSenderImpl javaMailSender;
            
                public MailController(JavaMailSenderImpl javaMailSender) {
                    this.javaMailSender = javaMailSender;
                }
            
                @GetMapping("/send/{info}")
                public Object send(@PathVariable String info) {
                    SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
            
                    simpleMailMessage.setSubject("邮件标题");
            
                    simpleMailMessage.setText("内容: " + info);
            
                    simpleMailMessage.setTo("578562554@qq.com");
            
                    simpleMailMessage.setFrom("madokaworker@163.com");
            
                    javaMailSender.send(simpleMailMessage);
            
                    LOGGER.info("邮件{}已发送，请注意查收",info);
            
                    return "邮件" + info + "已发送，请注意查收";
                }
            }"
          - 发送HTML/附件 复杂邮件 起飞了
            "@RestController
            @RequestMapping("/mail")
            public class MailController {
            
                private final Logger LOGGER = LoggerFactory.getLogger(MailController.class);
                private final Random RANDOM = new Random();
            
                private final JavaMailSenderImpl javaMailSender;
            
                public MailController(JavaMailSenderImpl javaMailSender) {
                    this.javaMailSender = javaMailSender;
                }
            
                @GetMapping("/send/mine/{info}")
                public Object sendMineMail(@PathVariable String info)throws Exception{
                    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
            
                    MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
            
                    mimeMessageHelper.setSubject("复杂邮件");
            
                    //支持 HTML
                    mimeMessageHelper.setText("内容<b>" + info + "</b>",true);
            
                    mimeMessageHelper.setTo("578562554@qq.com");
            
                    mimeMessageHelper.setFrom("madokaworker@163.com");
            
                    // 图片
                    byte[] picture = getPicture(200, 400, 0, 255, 0, info);
                    ByteArrayDataSource byteArrayInputStream = new ByteArrayDataSource(picture, "image/jpeg");
            
                    //上传附件
                    mimeMessageHelper.addAttachment(info+".jpg",byteArrayInputStream);
            
                    javaMailSender.send(mimeMessage);
            
                    LOGGER.info("mine邮件{}发动成功",info);
            
                    return "mine邮件发送成功";
                }
            
            
                public byte[] getPicture(int width,
                                         int height,
                                         int r,
                                         int g,
                                         int b,
                                         String info) throws Exception {
            
                    BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR);
                    Graphics graphics = bufferedImage.getGraphics();
                    graphics.setColor(new Color(r, g, b));
                    graphics.fillRect(0, 0, width, height);
            
                    graphics.setColor(Color.black);
                    graphics.setFont(new Font(Font.SERIF, Font.BOLD, height / 10));
                    graphics.drawString(info, RANDOM.nextInt(width / 2) + width/10, RANDOM.nextInt(height / 2) + height/10);
            
                    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                    ImageIO.write(bufferedImage, "jpeg", byteArrayOutputStream);
                    final byte[] bytes = byteArrayOutputStream.toByteArray();
                    byteArrayOutputStream.close();
                    return bytes;
                }
            }"
      - 安全
        - spring security 简单实用 @Deprecated 
          - 引入依赖
            "<dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-security</artifactId>
            </dependency>"
          - 编写配置类
          - 略! 这是前后端混杂版本 不学了
      - 分布式
        - zookeeper dubbo
          - 安装 docker pull zookeeper:3.5.7
            "https://hub.docker.com/_/zookeeper"
          - 启动 docker run --name zk0316 -p 2181:2181 -d bbebb888169c
            "一共有三个端口 2181 2888 3888 
            但是现在不做集群 不做选举"
          - 简单使用
            - 略 @Service @Reference
        - spring cloud 慢慢来 先不学了
        - 面试的时候把基本工作原理弄懂就行了吧
      - 热部署 liveload
        - 依赖
          "<dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-devtools</artifactId>
              <optional>true</optional>
          </dependency>"
        - 修改代码后 ctrl + F9 就会重新编译 重新启动
      - 监控
        - 依赖
    - springcloud
      - 《疯狂》spring cloud 微服务框架
        - 概述（背
          - 单体应用
            "单体应用 一个jar/war包，打遍天下
            缺点：一个bug，整个系统出问题"
          - SOA架构
            "面向服务架构
            每个模块独立：销售、库存、会员、报表
            即各自单独的jar包
            
            一句话：业务分开，独立，各自提供服务"
          - ESB
            "Enterprise Service Bus，即企业服务总线
            
            一句话： 中介者模式
            SOA架构，各个模块之间都有联系，如销售模块需要会员模块的服务
            因此，将服务发布到ESB，有需要就去拿"
          - SAOP协议
            "Simple Object Access Protocol 简单对象访问协议
            
            通信协议。用于web服务
            
            底层：HTTP XML"
          - SOA 总结
            - 1. 应用划分为模块
            - 2. 每个模块将服务发布到ESB，利用SOAP交流
      - spring cloud 尚硅谷 2020版
        - 入门 版本 选型
          - 前言
            "2020版本 spring cloud alibaba
            
            很多技术已经停止维护了
            
            8-10天学习
            
            前期技术要求
            	springboot github ngnix
            
            课程对象
            	零基础 非科班"
          - 入门 微服务理论
            "什么是微服务
            	应用划分为小服务、每个服务独立，可以单独部署
            	再加上服务间的通信
            	
            关键词
            	服务注册与发现
            	服务调用
            	服务熔断
            	负载均衡
            	服务降级
            	服务消息队列
            	配置中心管理
            	服务网关
            	服务监控
            	全链路追踪
            	自动化构建部署
            	服务定制任务、调度操作
            
            springcloud
            	微服务 一站式解决
            
            历史
            	首先 视屏网站NETFLIX 最初微服务落地，设计出eureka
            	spring觉得好，收编了这个项目，对外提出springcloud"
          - 版本选型
            - 版本选项方法 主要处理springboot和springcloud
              "springboot 和springcloud 之间依赖
              -----------------------------
              大版本依赖
              https://spring.io/projects/spring-cloud
              	springcloud H版 使用springboot 2.2.X
              
              详细依赖信息
              https://start.spring.io/actuator/info"
            - 本教程中版本
              - spring cloud H.SR1
              - spring boot 2.2.2.RELEASE
              - cloud alibaba 2.1.0.RELEASE
              - Java8
              - Maven 3.5
              - MySQL 5.7
          - 中间件选型
            - 服务注册中心
              - Eureka /yureka/ @Deprecated 
              - ZooKeeper
              - Consul
              - Nacos √
                "alibaba开发 完美代替eureka"
            - 服务调用
              - Ribbon
              - LoadBalancer
            - 服务调用
              - Feign @Deprecated 
              - OpenFeign
            - 服务降级
              - Hystrix @Deprecated 
              - resilience4j
              - alibaba sentinel √
            - 服务网关
              - Zuul @Deprecated 
              - Zuul2
              - gateway √
            - 服务配置
              - Config @Deprecated 
              - alibaba Nacos √
            - 服务总线
              - Bus @Deprecated 
              - alibaba Nacos √
        - 构建原型
          - 约定>配置>编码
          - IDEA新建project工作空间
            - 总的父工程构建
              - idea new project
                "maven项目 Java8
                create from archetype
                maven-archtype-site"
              - 编码
                "ideaj 三个地方 utf8
                √ transparent native-to-ASCII conversion"
              - annotation process 打勾 注解生效
              - Java compiler 选 1.8
              - file types 过滤 *.idea *.iml 不显示IDEA相关文件
            - 父工程pom文件
              - 加入 <packaging>pom</packaging>
              - 父工程 pom 文件
                "<?xml version="1.0" encoding="UTF-8"?>
                
                <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                    <modelVersion>4.0.0</modelVersion>
                
                    <groupId>com.atguigu.springcloud</groupId>
                    <artifactId>cloud20200413</artifactId>
                    <version>1.0-SNAPSHOT</version>
                    <packaging>pom</packaging>
                
                    <properties>
                        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
                        <maven.compiler.source>1.8</maven.compiler.source>
                        <maven.compiler.target>1.8</maven.compiler.target>
                        <junit.version>4.12</junit.version>
                        <lombok.version>1.16.18</lombok.version>
                        <log4j.version>1.2.17</log4j.version>
                        <mysql.version>8.0.19</mysql.version>
                        <druid.version>1.1.16</druid.version>
                        <mybatis.spring.boot.version>2.1.1</mybatis.spring.boot.version>
                    </properties>
                
                    <dependencyManagement>
                        <dependencies>
                            <dependency>
                                <groupId>org.apache.maven.plugins</groupId>
                                <artifactId>maven-project-info-reports-plugin</artifactId>
                                <version>3.0.0</version>
                            </dependency>
                            <!--spring boot 2.2.2-->
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-dependencies</artifactId>
                                <version>2.2.2.RELEASE</version>
                                <type>pom</type>
                                <scope>import</scope>
                            </dependency>
                            <!--spring cloud Hoxton.SR1-->
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-dependencies</artifactId>
                                <version>Hoxton.SR1</version>
                                <type>pom</type>
                                <scope>import</scope>
                            </dependency>
                            <!--spring cloud alibaba-->
                            <dependency>
                                <groupId>com.alibaba.cloud</groupId>
                                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                                <version>2.1.0.RELEASE</version>
                                <type>pom</type>
                                <scope>import</scope>
                            </dependency>
                            <!--mysql-->
                            <dependency>
                                <groupId>mysql</groupId>
                                <artifactId>mysql-connector-java</artifactId>
                                <version>${mysql.version}</version>
                                <scope>runtime</scope>
                            </dependency>
                            <!-- druid-->
                            <dependency>
                                <groupId>com.alibaba</groupId>
                                <artifactId>druid</artifactId>
                                <version>${druid.version}</version>
                            </dependency>
                            <dependency>
                                <groupId>org.mybatis.spring.boot</groupId>
                                <artifactId>mybatis-spring-boot-starter</artifactId>
                                <version>${mybatis.spring.boot.version}</version>
                            </dependency>
                            <!--junit-->
                            <dependency>
                                <groupId>junit</groupId>
                                <artifactId>junit</artifactId>
                                <version>${junit.version}</version>
                            </dependency>
                            <!--log4j-->
                            <dependency>
                                <groupId>log4j</groupId>
                                <artifactId>log4j</artifactId>
                                <version>${log4j.version}</version>
                            </dependency>
                        </dependencies>
                
                    </dependencyManagement>
                
                    <build>
                        <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
                            <plugins>
                                <plugin>
                                    <artifactId>maven-clean-plugin</artifactId>
                                    <version>3.1.0</version>
                                </plugin>
                                <plugin>
                                    <artifactId>maven-site-plugin</artifactId>
                                    <version>3.7.1</version>
                                </plugin>
                                <plugin>
                                    <artifactId>maven-project-info-reports-plugin</artifactId>
                                    <version>3.0.0</version>
                                </plugin>
                            </plugins>
                        </pluginManagement>
                        <plugins>
                            <plugin>
                                <groupId>org.apache.maven.plugins</groupId>
                                <artifactId>maven-site-plugin</artifactId>
                                <configuration>
                                    <locales>en,fr</locales>
                                </configuration>
                            </plugin>
                        </plugins>
                    </build>
                
                </project>"
          - Rest微服务工程构建
            - cloud-provider-payment28001
              "服务提供者 支付模块"
              - 建立module
                "在父工程里面建立 module"
              - 改POM
                - 自动生成POM
                  "<?xml version="1.0" encoding="UTF-8"?>
                  <project xmlns="http://maven.apache.org/POM/4.0.0"
                           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                      <parent>
                          <artifactId>cloud20200413</artifactId>
                          <groupId>com.atguigu.springcloud</groupId>
                          <version>1.0-SNAPSHOT</version>
                      </parent>
                      <modelVersion>4.0.0</modelVersion>
                  
                      <artifactId>cloud-provider-payment28001</artifactId>
                  
                  
                  </project>"
                - 同时父工程里面的POM增加
                  "<modules>
                      <module>cloud-provider-payment28001</module>
                  </modules>"
                - 在本工程POM中添加依赖 父类中有的，可以不用写版本号
                  "<?xml version="1.0" encoding="UTF-8"?>
                  <project xmlns="http://maven.apache.org/POM/4.0.0"
                           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                      <parent>
                          <artifactId>cloud20200413</artifactId>
                          <groupId>com.atguigu.springcloud</groupId>
                          <version>1.0-SNAPSHOT</version>
                      </parent>
                      <modelVersion>4.0.0</modelVersion>
                  
                      <artifactId>cloud-provider-payment28001</artifactId>
                  
                      <dependencies>
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-web</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-actuator</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.mybatis.spring.boot</groupId>
                              <artifactId>mybatis-spring-boot-starter</artifactId>
                          </dependency>
                          <dependency>
                              <groupId>com.alibaba</groupId>
                              <artifactId>druid-spring-boot-starter</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>mysql</groupId>
                              <artifactId>mysql-connector-java</artifactId>
                          </dependency>
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-jdbc</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-devtools</artifactId>
                              <scope>runtime</scope>
                              <optional>true</optional>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.projectlombok</groupId>
                              <artifactId>lombok</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-test</artifactId>
                              <scope>test</scope>
                          </dependency>
                  
                      </dependencies>
                  
                  
                  </project>"
              - 写YML application.yml
                "server:
                  port: 28001
                
                spring:
                  application:
                    name: Cloud-payment-service
                  datasource:
                    type: com.alibaba.druid.pool.DruidDataSource
                    driver-class-name: com.mysql.jdbc.Driver
                    url: jdbc:mysql://192.168.2.3:3306/ichiwan?serverTimezone=Hongkong&useUnicode=true&characterEncoding=utf8mb4&useSSL=false
                    username: root
                    password: 123456
                
                mybatis:
                  mapper-locations: classpath:mapper/*.xml
                  type-aliases-package: com.atguigu.springcloud.entities"
              - 主启动
                "@SpringBootApplication
                public class Payment28001 {
                    private final static Logger LOGGER = LoggerFactory.getLogger(Payment28001.class);
                
                    public static void main(String[] args) {
                        SpringApplication.run(Payment28001.class, args);
                    }
                }"
              - 业务
                - 数据库建立
                  "create database if not exists springcloud20200413 default character set = 'utf8mb4';
                  
                  create table if not exists payment (
                      id
                          bigint
                          not null
                          auto_increment,
                      serial
                          varchar(200)
                          default '',
                      primary key
                          (id)
                  )engine=innoDB auto_increment=1 default charset =utf8mb4;"
                - entities
                  - payment
                    "public class Payment implements Serializable {
                        private final static Logger LOGGER = LoggerFactory.getLogger(Payment.class);
                        
                        private Long id;
                        private String serial;
                        
                        // getter setter"
                  - common result
                    "public class CommonResult<T> implements Serializable {
                        private final static Logger LOGGER = LoggerFactory.getLogger(CommonResult.class);
                    
                        private static Integer SUCCESS = 200;
                        private static Integer NOT_FOUND = 404;
                    
                        private Integer code;
                        private String message;
                        private T data;
                    
                        public static <T> CommonResult<T> success(String message,T data){
                            return new CommonResult<>(SUCCESS,message,data);
                        }
                    
                        public static <T> CommonResult<T> notFound(String message,T data){
                            return new CommonResult<>(NOT_FOUND,message,data);
                        }"
                - mapper DAO写法[重要]
                  - application.yml
                    "mybatis:
                      mapper-locations: classpath:mapper/*.xml
                      type-aliases-package: com.atguigu.springcloud.entity
                    
                    server:
                      port: 28001
                    
                    spring:
                      application:
                        name: Cloud-payment-service
                      datasource:
                        type: com.alibaba.druid.pool.DruidDataSource
                        driver-class-name: com.mysql.cj.jdbc.Driver
                        url: jdbc:mysql://192.168.2.3:3306/springcloud20200413?serverTimezone=Hongkong&useUnicode=true&characterEncoding=utf8&useSSL=false
                        username: root
                        password: 123456"
                  - PaymentMapper.xml
                    "<?xml version="1.0" encoding="utf-8" ?>
                    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "mybatis-3-mapper.dtd">
                    
                    <mapper namespace="com.atguigu.springcloud.dao.PaymentDao">
                        <insert id="create" parameterType="com.atguigu.springcloud.entity.Payment" useGeneratedKeys="true" keyProperty="id">
                            insert into payment(serial) values(#{serial})
                        </insert>
                    
                        <resultMap id="BaseResultMap" type="com.atguigu.springcloud.entity.Payment">
                            <id column="id" property="id" jdbcType="BIGINT"/>
                            <id column="serial" property="serial" jdbcType="VARCHAR"/>
                        </resultMap>
                        <select id="getById" parameterType="Long" resultMap="BaseResultMap">
                            select id,serial from payment where id=#{id};
                        </select>
                    </mapper>"
                  - mapper 类
                    "@Mapper
                    public interface PaymentDao {
                    
                        int create(Payment payment);
                    
                        Payment getById(@Param("id") Long id);
                    
                    }"
                - service..controller 略
            - cloud-consumer-order20080
              "服务消费者 订单模块"
              - maven空项目
              - pom
                "<?xml version="1.0" encoding="UTF-8"?>
                <project xmlns="http://maven.apache.org/POM/4.0.0"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                    <parent>
                        <artifactId>cloud20200413</artifactId>
                        <groupId>com.atguigu.springcloud</groupId>
                        <version>1.0-SNAPSHOT</version>
                    </parent>
                    <modelVersion>4.0.0</modelVersion>
                
                    <artifactId>cloud-provider-order20080</artifactId>
                
                    <dependencies>
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-starter-web</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-starter-actuator</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.mybatis.spring.boot</groupId>
                            <artifactId>mybatis-spring-boot-starter</artifactId>
                        </dependency>
                        <dependency>
                            <groupId>com.alibaba</groupId>
                            <artifactId>druid-spring-boot-starter</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>mysql</groupId>
                            <artifactId>mysql-connector-java</artifactId>
                        </dependency>
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-starter-jdbc</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-devtools</artifactId>
                            <scope>runtime</scope>
                            <optional>true</optional>
                        </dependency>
                
                        <dependency>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-starter-test</artifactId>
                            <scope>test</scope>
                        </dependency>
                
                    </dependencies>
                </project>"
              - yml
                "server:
                  port: 20080
                
                spring:
                  application:
                    name: Cloud-order-client"
              - 使用 RestTemplate 调用 cloud-provider-payment28001 的服务
                - 配置 RestTemplate
                  "@Configuration
                  public class RestTemplateConfig {
                      private final static Logger LOGGER = LoggerFactory.getLogger(RestTemplateConfig.class);
                  
                      @Bean
                      public RestTemplate getRestTemplate() {
                          LOGGER.info("RestTemplate insert");
                          return new RestTemplate();
                      }
                  }"
                - 使用 RestTemplate 编写 controller
                  "@RestController
                  @RequestMapping("/consumer/payment")
                  public class OrderController {
                      private final static Logger LOGGER = LoggerFactory.getLogger(OrderController.class);
                  
                      private RestTemplate restTemplate;
                  
                      private static final String PAYMENT_URL = "http://192.168.2.13:28001/payment";
                  
                      public OrderController(@RequestBody RestTemplate restTemplate) {
                          this.restTemplate = restTemplate;
                      }
                  
                      @PostMapping("/create")
                      public CommonResult<?> create(Payment payment) {
                          LOGGER.info("consumer create payment={}", payment);
                          return restTemplate.postForObject(PAYMENT_URL + "/create", payment, CommonResult.class);
                  
                      }
                  
                      @GetMapping("get/{id}")
                      public CommonResult<?> getById(@PathVariable("id") Long id) {
                          LOGGER.info("consumer get by id={}", id);
                          return restTemplate.getForObject(PAYMENT_URL + "/get/" + id, CommonResult.class);
                      }
                  }"
            - 重构 //cloud-api-commons
              - 两个modules都有实体类payment/commonResult 代码相同
                - 新建一个公用module： cloud-api-commons
                  "pom文件
                  ---------------------
                  <?xml version="1.0" encoding="UTF-8"?>
                  <project xmlns="http://maven.apache.org/POM/4.0.0"
                           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                      <parent>
                          <artifactId>cloud20200413</artifactId>
                          <groupId>com.atguigu.springcloud</groupId>
                          <version>1.0-SNAPSHOT</version>
                      </parent>
                      <modelVersion>4.0.0</modelVersion>
                  
                      <artifactId>cloud-api-commons</artifactId>
                  
                      <dependencies>
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-devtools</artifactId>
                              <scope>runtime</scope>
                              <optional>true</optional>
                          </dependency>
                  
                          <dependency>
                              <groupId>cn.hutool</groupId>
                              <artifactId>hutool-all</artifactId>
                              <version>5.3.0</version>
                          </dependency>
                      </dependencies>
                  
                  
                  </project>"
                - 新module用于存放公用代码 如实体类 utils
                - 另外module中公用代码删除，pom引入jar包
                  "<dependency>
                      <groupId>com.atguigu.springcloud</groupId>
                      <artifactId>cloud-api-commons</artifactId>
                      <version>${project.version}</version>
                  </dependency>"
        - spring cloud netflix
          - 服务注册与发现 Eureka / zookeeper / consul
            - 前期回顾
              "构建一个REST web 的 payment 模块
              向外暴露 28001 端口，提供两个服务
              	订单查询
              	http://192.168.2.13:28001/payment/get/{id}
              	订单创建
              	http://192.168.2.13:28001/payment/create
              
              构建一个REST web 的 order 模块
              调用 payment 模块的服务 这里利用 restTemplate 工具
              向外暴露 20080 端口，两个服务
              	http://192.168.2.13:20080/consumer/payment/get/{id}
              	http://192.168.2.13:20080/consumer/payment/create
              
              注意：以上两个业务，业务代码在 	payment 模块 中，而 order 模块只是调用REST接口，再转发而已"
            - 知识点
              - 服务治理
                "当服务提供者、消费者很多，很复杂时，就需要一个中间者
                提供服务发现、负载均衡、容错等机制"
              - 服务注册
                "                                                      注册中心
                                                               -                             -
                             - 获取注册信息  -                                注册/刷新/取消 
                           -                                                                                    -
                消费者          -----   >>        调用服务    ----- >>               提供者
                
                
                
                "
              - RPC Remote Procedure Call 远程过程调用
                "反义词：本地过程调用，即调用某个函数
                
                但是现在这个函数在远端计算机上，怎么调用？
                	1. 希望能调用
                	2. 希望能屏蔽底层，让用户调用远程方法和本地方法一样
                	3. 希望能集群，这样一个点宕机了，其他的还能用
                
                怎么找到这个方法呢？这就需要注册中心了
                
                总结一下，RPC要解决的两个问题：
                解决分布式系统中，服务之间的调用问题。
                远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。"
              - Eureka
                - Eureka 两个组件
                  - server 提供注册服务
                  - client 通过注册中心进行访问
                - Eureka 工作流程
                  - 1. 启动 eureka 注册中心
                  - 2. 启动服务提供者模块 payment
                    "服务提供者会自动注册到 eureka
                    <服务名称, 地址>"
                  - 3. 启动服务消费者模块 order
                    "消费者调用接口时，首先利用<服务名>去注册中心拿RPC远程调用地址"
                  -   消费者获取地址后，底层使用 HttpClient 技术实现远程调用
                  -   消费者会缓存这个地址，同时每 30s 去注册中心更新地址
                - Eureka 自我保护模式
                  "访问 eureka 出现红字
                  -------------------------
                  EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
                  -------------------------
                  
                  表示不会删除/注销失效的微服务
                  
                  属于 CAP 中的 AP
                  
                  这么做的原因：防止 服务 和 server 不通，但是实际上 服务还能工作"
                - Eureka 停止更新
              - zookeeper
                "一个分布式协调工具，可以实现 注册中心功能"
                - [临时节点]默认没有保护机制 收不到心跳就删除节点
              - consul
                - 分布式服务发现和配置管理中心 Go语言开发
                - 功能 服务发现、健康检查、KV存储、多数据中心、可视化web界面
              - CAP理论
                - CA 用于单点集群
                - CP 一致性、分区容错性 性能不高
                  "zookeeper consul
                  
                  网络分区 不通时，不用旧值。"
                - AP 可用性、分区容错性 对一致性要求不高
                  "eureka
                  
                  为了满足高可用，可以返回旧数据。网络分区时，不同网络不同，可以各自为政。"
            - Eureka 简单使用
              - Eureka 单机构建
                - 构建 server 服务注册中心 27001
                  - 建立module
                    "cloud-eureka-server27001"
                  - POM spring-cloud-starter-netflix-eureka-server
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>cloud20200413</artifactId>
                            <groupId>com.atguigu.springcloud</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>cloud-eureka-server27001</artifactId>
                    
                        <dependencies>
                            <!-- 不用写版本,因为 eureka 在父工程 spring cloud 中 -->
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
                            </dependency>
                    
                    
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-devtools</artifactId>
                                <scope>runtime</scope>
                                <optional>true</optional>
                            </dependency>
                    
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-test</artifactId>
                                <scope>test</scope>
                            </dependency>
                    
                            <dependency>
                                <groupId>junit</groupId>
                                <artifactId>junit</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.atguigu.springcloud</groupId>
                                <artifactId>cloud-api-commons</artifactId>
                                <version>${project.version}</version>
                            </dependency>
                        </dependencies>
                    </project>"
                  - YML
                    "server:
                      port: 27001
                    
                    eureka:
                      instance:
                        hostname: 192.168.2.13
                      client:
                    // 不注册自己
                        register-with-eureka: false
                        fetch-registry: false
                        service-url:
                          defaultZone: http://${euraka.instance.hostname}:${server.port}/eureka/"
                  - 主启动
                    "@EnableEurekaServer
                    @SpringBootApplication
                    public class EurekaServer27001 {
                        private final static Logger LOGGER = LoggerFactory.getLogger(EurekaServer27001.class);
                    
                        public static void main(String[] args) {
                            SpringApplication.run(EurekaServer27001.class, args);
                        }
                    }"
                  - 测试
                    "访问 http://192.168.2.13:27001/"
                - 将服务提供者 payment28001注册进27001
                  - 改POM
                    "<dependency>
                        <groupId>org.springframework.cloud</groupId>
                        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                    </dependency>"
                  - 改YML
                    "eureka:
                      client:
                        register-with-eureka: true
                        fetch-registry: true
                        service-url:
                          defaultZone: http://192.168.2.13:27001/eureka/"
                  - 主启动 @EnableEurekaClient
                    "@EnableEurekaClient
                    @SpringBootApplication
                    public class Payment28001 {
                        private final static Logger LOGGER = LoggerFactory.getLogger(Payment28001.class);
                    
                        public static void main(String[] args) {
                            SpringApplication.run(Payment28001.class, args);
                        }
                    }"
                  - 测试
                    "进入 http://192.168.2.13:27001/ 
                    看是不是有 CLOUD-PAYMENT-SERVICE"
                - 将服务消费者 order20080注册进27001
                  - 改POM 同27001
                  - 改YML 同27001
                    "server:
                      port: 20080
                    
                    spring:
                      application:
                        name: cloud-order-client
                    
                    eureka:
                      client:
                        register-with-eureka: true
                        fetch-registry: true
                        service-url:
                          defaultZone: http://192.168.2.13:27001/eureka/"
                  - 主启动 同27001
                  - 测试 通27001
                    "CLOUD-ORDER-CLIENT"
              - Eureka 集群构建 (多个server)
                - 目的：负载均衡、服务容错
                - 原理：互相注册、相互守望
                  "两个 eureka server 27001 / 27002 互相注册"
                - 构建步骤
                  - 构建第二个 server 模块 cloud-eureka-server27002
                    "POM 代码和 cloud-eureka-server27001 一致"
                  - cloud-eureka27001 YML文件
                    "server:
                      port: 27001
                    
                    eureka:
                      instance:
                        hostname: 192.168.2.13
                      client:
                        register-with-eureka: false
                        fetch-registry: false
                        service-url:
                          defaultZone: http://192.168.2.3:27002/eureka/"
                  - cloud-eureka27002 YML文件
                    "server:
                      port: 27002
                    
                    eureka:
                      instance:
                        hostname: 192.168.2.3
                      client:
                        register-with-eureka: false
                        fetch-registry: false
                        service-url:
                          defaultZone: http://192.168.2.13:27001/eureka/"
                  - 修改 payment28001 和 order20080 文件
                    "defaultZone: http://192.168.2.13:27001/eureka/,http://192.168.2.3:27002/eureka/"
                  - 测试
                    "http://192.168.2.13:27001/
                    http://192.168.2.3:27002/
                    查看是不是都注册成功"
              - 服务提供者集群构建
                - 构建 cloud-provider-payment28002 模块
                  "复制自 cloud-provider-payment28001 只是把端口改成 28002 "
                - YML文件
                  "server:
                    port: 28002
                  
                  spring:
                    application:
                      name: Cloud-payment-service
                    datasource:
                      type: com.alibaba.druid.pool.DruidDataSource
                      driver-class-name: com.mysql.cj.jdbc.Driver
                      url: jdbc:mysql://192.168.2.3:3306/springcloud20200413?serverTimezone=Hongkong&useUnicode=true&characterEncoding=utf8&useSSL=false
                      username: root
                      password: 123456
                  
                  eureka:
                    client:
                      register-with-eureka: true
                      fetch-registry: true
                      service-url:
                        defaultZone: http://192.168.2.13:27001/eureka/,http://192.168.2.3:27002/eureka/
                  #      defaultZone: http://192.168.2.13:27001/eureka/
                  
                  mybatis:
                    mapper-locations: classpath:mapper/*.xml
                    type-aliases-package: com.atguigu.springcloud.entity"
                - 注意：这两个服务的名字是一样的，只是端口不同
                  "spring:
                    application:
                      name: Cloud-payment-service"
                - 为了能够区分具体是谁提供的服务，修改下两个服务的controller代码
                  "注：不影响业务
                  
                  代码：
                  ------------------------
                  package com.atguigu.springcloud.controller;
                  
                  import com.atguigu.springcloud.entity.CommonResult;
                  import com.atguigu.springcloud.entity.Payment;
                  import com.atguigu.springcloud.service.PaymentService;
                  import org.slf4j.Logger;
                  import org.slf4j.LoggerFactory;
                  import org.springframework.beans.factory.annotation.Value;
                  import org.springframework.web.bind.annotation.*;
                  
                  import javax.annotation.Resource;
                  import java.util.Optional;
                  
                  /**
                   * Description
                   * PaymentController
                   * <p>
                   * Data
                   * 2020/4/13-21:13
                   *
                   * @author zrx
                   * @version 1.0
                   */
                  
                  
                  @RequestMapping("/payment")
                  @RestController
                  public class PaymentController {
                      private final static Logger LOGGER = LoggerFactory.getLogger(PaymentController.class);
                  
                      @Resource
                      private PaymentService paymentService;
                  
                      @Value("${server.port}")
                      private String port;
                  
                      @PostMapping(value = "/create")
                      public CommonResult<Integer> create(@RequestBody Payment payment) {
                          int result = paymentService.create(payment);
                          LOGGER.info("payment insert result={}", result);
                  
                          if (result > 0)
                              return CommonResult.success("插入数据库成功" + serverFrom(), result);
                          else
                              return CommonResult.notFound("插入数据库失败" + serverFrom(), result);
                      }
                  
                  
                      @GetMapping("/get/{id}")
                      public CommonResult<Payment> getById(@PathVariable("id") Long id) {
                          Optional<Payment> optionalPayment = paymentService.getById(id);
                  
                          LOGGER.info("select payment={}", optionalPayment.orElse(null));
                  
                          return optionalPayment.
                                  map(payment -> CommonResult.success("查找成功" + serverFrom(), payment))
                                  .orElseGet(() -> CommonResult.notFound("查找失败,不存在" + serverFrom(), null));
                  
                      }
                  
                      private String serverFrom() {
                          return "-- 服务提供者的端口号是" + port + " --";
                      }
                  
                  }"
                - 测试
                  "http://192.168.2.13:27001/
                  http://192.168.2.3:27002/
                  
                  可以看到 CLOUD-PAYMENT-SERVICE 服务下有两个实例"
                - 修改 order20080 代码 调用地址不再写死
                  "// 写死
                  //private static final String PAYMENT_URL = "http://192.168.2.13:28001/payment";
                  
                  // 服务名称
                  private static final String PAYMENT_URL = "http://CLOUD-PAYMENT-SERVICE/payment";"
                - 修改 restTemplate Bean 加上注解 @LoadBalanced 就可以解析上面的域名 轮询到28001和28002
                  "@Configuration
                  public class RestTemplateConfig {
                      private final static Logger LOGGER = LoggerFactory.getLogger(RestTemplateConfig.class);
                  
                      @Bean
                      @LoadBalanced // 2020年4月15日 负载均衡 //实际上可以解析服务域名 "http://CLOUD-PAYMENT-SERVICE"
                      public RestTemplate getRestTemplate() {
                          LOGGER.info("RestTemplate insert");
                          return new RestTemplate();
                      }
                  }"
                - 测试 http://192.168.2.13:20080/consumer/payment/get/39 依次提供服务
              - 额外配置
                - eureka 注册的实例 修改主机名称
                  "修改前： 
                  DESKTOP-N2R9QDH:cloud-order-client:20080
                  
                  YML修改 加上 eureka.instance.instance-id
                  eureka:
                    client:
                      register-with-eureka: true
                      fetch-registry: true
                      service-url:
                        defaultZone: http://192.168.2.13:27001/eureka/,http://192.168.2.3:27002/eureka/
                  #      defaultZone: http://192.168.2.13:27001/eureka/
                    instance:
                      instance-id: payment28001
                  
                  修改后
                  直接显示 payment28001"
                - eureka 注册的实例 访问路径显示IP地址
                  "YML添加
                  
                  eureka:
                    client:
                      register-with-eureka: true
                      fetch-registry: true
                      service-url:
                        defaultZone: http://192.168.2.13:27001/eureka/,http://192.168.2.3:27002/eureka/
                  #      defaultZone: http://192.168.2.13:27001/eureka/
                    instance:
                      instance-id: order20080
                      prefer-ip-address: true"
                - client 发送 心跳信息的间隔
                  "YML lease-renewal-interval-in-seconde"
                - server 多久不收到心跳就移除 client
                  "YML lease-expiration-duration-in-seconds"
                - Eureka 禁止保护模式
                  "YML
                  ------------
                  eureka:
                    server:
                      enable-self-preservation: false"
              - 获取注册信息 DiscoveryClient类
                "1. 主启动类加上 @EnableDiscoveryClient
                
                2. 注入 
                @Resource
                private DiscoveryClient discoveryClient;
                
                3. 使用它
                @GetMapping("/discovery")
                public Object discovery() {
                    List<String> services = discoveryClient.getServices();
                
                    for (String service : services) {
                        //service = cloud-payment-service
                        //service = cloud-order-client
                        LOGGER.info("service = {}", service);
                    }
                
                    List<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");
                
                    for (ServiceInstance instance : instances) {
                        LOGGER.info("instance = {}", instance);
                    }
                
                    return discoveryClient;
                    //{
                    //    "services": [
                    //        "cloud-payment-service",
                    //        "cloud-order-client"
                    //    ],
                    //    "order": 0
                    //}
                }"
            - zookeeper 简单使用
              - 安装并运行 zookeeper
                "docker run --name docker-zookeeper -p 2888:2888 -p 3888:3888 -p 8080:8080 -p 2181:2181 --restart always -d zookeeper:3.4"
              - 注册服务提供者
                - 建立模块 cloud-provider-payment28004
                  - POM文件!!! 有坑
                    "简单加入会出问题：
                    ---------------------------------
                    <dependency>
                        <groupId>org.springframework.cloud</groupId>
                        <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
                    </dependency>
                    
                    应该是
                    ------------------------------
                    <dependency>
                        <groupId>org.springframework.cloud</groupId>
                        <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
                        <!--这个依赖里面的 zookeeper 不是我想要的版本，因此移除。下面手动导入我要的版本-->
                        <exclusions>
                            <exclusion>
                                <groupId>org.apache.zookeeper</groupId>
                                <artifactId>zookeeper</artifactId>
                            </exclusion>
                        </exclusions>
                    </dependency>
                    <!--手动导入我要的版本-->
                    <dependency>
                        <groupId>org.apache.zookeeper</groupId>
                        <artifactId>zookeeper</artifactId>
                        <!--Zookeeper version: 3.4.14-4c25d480e66aadd371de8bd2fd8da255ac140bcf, built on 03/06/2019 16:18 GMT-->
                        <version>3.4.14</version>
                        <!--但是这个版本中的日志是 log4j，和spring的 logback 冲突，所以移除-->
                        <exclusions>
                            <exclusion>
                                <groupId>org.slf4j</groupId>
                                <artifactId>slf4j-log4j12</artifactId>
                            </exclusion>
                        </exclusions>
                    </dependency>
                    
                    
                    
                    完整
                    ----------------
                    <?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>cloud20200413</artifactId>
                            <groupId>com.atguigu.springcloud</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>cloud-provider-payment28004</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.mybatis.spring.boot</groupId>
                                <artifactId>mybatis-spring-boot-starter</artifactId>
                            </dependency>
                            <dependency>
                                <groupId>com.alibaba</groupId>
                                <artifactId>druid-spring-boot-starter</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>mysql</groupId>
                                <artifactId>mysql-connector-java</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-jdbc</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
                                <!--这个依赖里面的 zookeeper 不是我想要的版本，因此移除。下面手动导入我要的版本-->
                                <exclusions>
                                    <exclusion>
                                        <groupId>org.apache.zookeeper</groupId>
                                        <artifactId>zookeeper</artifactId>
                                    </exclusion>
                                </exclusions>
                            </dependency>
                            <!--手动导入我要的版本-->
                            <dependency>
                                <groupId>org.apache.zookeeper</groupId>
                                <artifactId>zookeeper</artifactId>
                                <!--Zookeeper version: 3.4.14-4c25d480e66aadd371de8bd2fd8da255ac140bcf, built on 03/06/2019 16:18 GMT-->
                                <version>3.4.14</version>
                                <!--但是这个版本中的日志是 log4j，和spring的 logback 冲突，所以移除-->
                                <exclusions>
                                    <exclusion>
                                        <groupId>org.slf4j</groupId>
                                        <artifactId>slf4j-log4j12</artifactId>
                                    </exclusion>
                                </exclusions>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-devtools</artifactId>
                                <scope>runtime</scope>
                                <optional>true</optional>
                            </dependency>
                    
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-test</artifactId>
                                <scope>test</scope>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.atguigu.springcloud</groupId>
                                <artifactId>cloud-api-commons</artifactId>
                                <version>${project.version}</version>
                            </dependency>
                    
                        </dependencies>
                    
                    
                    </project>
                    
                    
                    </project>"
                  - YML文件
                    "server:
                      port: 28004
                    
                    spring:
                      application:
                        name: Cloud-payment-service
                      cloud:
                        zookeeper:
                          connect-string: 192.168.2.3:2181
                      datasource:
                        type: com.alibaba.druid.pool.DruidDataSource
                        driver-class-name: com.mysql.cj.jdbc.Driver
                        url: jdbc:mysql://192.168.2.3:3306/springcloud20200413?serverTimezone=Hongkong&useUnicode=true&characterEncoding=utf8&useSSL=false
                        username: root
                        password: 123456
                    
                    mybatis:
                      mapper-locations: classpath:mapper/*.xml
                      type-aliases-package: com.atguigu.springcloud.entity"
                  - 主启动类 @EnableDiscoveryClient
                    "用于 consul 或者 zookeeper 作为注册中心"
                - zookeeper 测试
                  - cd bin
                  - ./zkCli.sh 
                  - 客户端进入 ls /
                    "显示 [services, zookeeper]"
                  - ls /services
                    "显示 [Cloud-payment-service] 正是注册的服务"
                  - ls /services/Cloud-payment-service
                    "显示[861421c9-561a-4424-a6cd-fbc9b97ef5f7]"
                  - get /services/Cloud-payment-service/861421c9-561a-4424-a6cd-fbc9b97ef5f7
                    "显示
                    {
                        "name": "Cloud-payment-service",
                        "id": "861421c9-561a-4424-a6cd-fbc9b97ef5f7",
                        "address": "DESKTOP-N2R9QDH",
                        "port": 28004,
                        "sslPort": null,
                        "payload": {
                            "@class": "org.springframework.cloud.zookeeper.discovery.ZookeeperInstance",
                            "id": "application-1",
                            "name": "Cloud-payment-service",
                            "metadata": {}
                        },
                        "registrationTimeUTC": 1586959507565,
                        "serviceType": "DYNAMIC",
                        "uriSpec": {
                            "parts": [
                                {
                                    "value": "scheme",
                                    "variable": true
                                },
                                {
                                    "value": "://",
                                    "variable": false
                                },
                                {
                                    "value": "address",
                                    "variable": true
                                },
                                {
                                    "value": ":",
                                    "variable": false
                                },
                                {
                                    "value": "port",
                                    "variable": true
                                }
                            ]
                        }
                    }
                    cZxid = 0x15
                    ctime = Wed Apr 15 14:05:09 UTC 2020
                    mZxid = 0x15
                    mtime = Wed Apr 15 14:05:09 UTC 2020
                    pZxid = 0x15
                    cversion = 0
                    dataVersion = 0
                    aclVersion = 0
                    ephemeralOwner = 0x1007b1278780005
                    dataLength = 535
                    numChildren = 0"
              - 注册服务消费者
                - 建立模块 cloud-consumer-order20080
                  - POM
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>cloud20200413</artifactId>
                            <groupId>com.atguigu.springcloud</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>cloud-provider-payment28004</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.mybatis.spring.boot</groupId>
                                <artifactId>mybatis-spring-boot-starter</artifactId>
                            </dependency>
                            <dependency>
                                <groupId>com.alibaba</groupId>
                                <artifactId>druid-spring-boot-starter</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>mysql</groupId>
                                <artifactId>mysql-connector-java</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-jdbc</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
                                <!--这个依赖里面的 zookeeper 不是我想要的版本，因此移除。下面手动导入我要的版本-->
                                <exclusions>
                                    <exclusion>
                                        <groupId>org.apache.zookeeper</groupId>
                                        <artifactId>zookeeper</artifactId>
                                    </exclusion>
                                </exclusions>
                            </dependency>
                            <!--手动导入我要的版本-->
                            <dependency>
                                <groupId>org.apache.zookeeper</groupId>
                                <artifactId>zookeeper</artifactId>
                                <!--Zookeeper version: 3.4.14-4c25d480e66aadd371de8bd2fd8da255ac140bcf, built on 03/06/2019 16:18 GMT-->
                                <version>3.4.14</version>
                                <!--但是这个版本中的日志是 log4j，和spring的 logback 冲突，所以移除-->
                                <exclusions>
                                    <exclusion>
                                        <groupId>org.slf4j</groupId>
                                        <artifactId>slf4j-log4j12</artifactId>
                                    </exclusion>
                                </exclusions>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-devtools</artifactId>
                                <scope>runtime</scope>
                                <optional>true</optional>
                            </dependency>
                    
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-test</artifactId>
                                <scope>test</scope>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.atguigu.springcloud</groupId>
                                <artifactId>cloud-api-commons</artifactId>
                                <version>${project.version}</version>
                            </dependency>
                    
                        </dependencies>
                    
                    
                    </project>"
                  - YML
                    "server:
                      port: 20084
                    
                    spring:
                      application:
                        name: cloud-order-client
                      cloud:
                        zookeeper:
                          connect-string: 192.168.2.3:2181"
                  - 主启动 @EnableDiscoveryClient
                    "package com.atguigu.springcloud;
                    
                    import org.slf4j.Logger;
                    import org.slf4j.LoggerFactory;
                    import org.springframework.boot.SpringApplication;
                    import org.springframework.boot.autoconfigure.SpringBootApplication;
                    import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
                    
                    
                    /**
                     * Description
                     * OrderMain20080
                     * <p>
                     * Data
                     * 2020/4/13-22:04
                     *
                     * @author zrx
                     * @version 1.0
                     */
                    
                    @EnableDiscoveryClient
                    @SpringBootApplication
                    public class OrderMain20084 {
                        private final static Logger LOGGER = LoggerFactory.getLogger(OrderMain20084.class);
                    
                        public static void main(String[] args) {
                            SpringApplication.run(OrderMain20084.class, args);
                        }
                    
                    }"
                  - restTemplate配置类
                    "@Configuration
                    public class RestTemplateConfig {
                        private final static Logger LOGGER = LoggerFactory.getLogger(RestTemplateConfig.class);
                    
                        @Bean
                        @LoadBalanced // 2020年4月15日 负载均衡 //实际上可以解析服务域名 "http://CLOUD-PAYMENT-SERVICE"
                        public RestTemplate getRestTemplate() {
                            LOGGER.info("RestTemplate insert");
                            return new RestTemplate();
                        }
                    }"
                  - controller 地址来自zookeeper http://Cloud-payment-service/payment
                    "@RestController
                    @RequestMapping("/consumer/payment")
                    public class OrderController {
                        private final static Logger LOGGER = LoggerFactory.getLogger(OrderController.class);
                    
                        private RestTemplate restTemplate;
                    
                        // 写死
                        // private static final String PAYMENT_URL = "http://192.168.2.13:28004/payment";
                    
                        // 服务名称
                        private static final String PAYMENT_URL = "http://Cloud-payment-service/payment";
                    
                        public OrderController(RestTemplate restTemplate) {
                            this.restTemplate = restTemplate;
                        }
                    
                        @PostMapping("/create")
                        public CommonResult<?> create(@RequestBody Payment payment) {
                            LOGGER.info("consumer create payment={}", payment);
                            return restTemplate.postForObject(PAYMENT_URL + "/create", payment, CommonResult.class);
                    
                        }
                    
                        @GetMapping("get/{id}")
                        public CommonResult<?> getById(@PathVariable("id") Long id) {
                            LOGGER.info("consumer get by id={}", id);
                    
                            return restTemplate.getForObject(PAYMENT_URL + "/get/" + id, CommonResult.class);
                        }
                    }"
                - zookeeper 测试
                  - ls /services
                    "[Cloud-payment-service, cloud-order-client]"
                  - http://192.168.2.13:20084/consumer/payment/get/39 访问成功
                    "{
                        "code": 200,
                        "message": "查找成功-- 服务提供者的端口号是28004 --",
                        "data": {
                            "id": 39,
                            "serial": "配置EUREKA集群"
                        }
                    }"
            - consul简单使用
              - 略
          - 负载均衡 Ribborn
            - Ribborn
              - 入门
                "嵌入客户端（服务消费者）中，提供负载均衡算法和PRC
                连接超时重试等
                
                
                一句话：负载均衡+restTemplate调用
                
                进入维护模式
                
                替换 load balance"
              - 和 eureka 结合
                "引入 eureka 客户端，自动带有 ribbon 
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                </dependency>"
              - 深入学习 RestTemplate
                - getForObject 响应体对象直接转为json对象
                  "return restTemplate.getForObject(PAYMENT_URL + "/get/" + id, CommonResult.class);"
                - getForEntity 返回ResponseEntity包含相应中的重要信息，如相应头、状态码
                  "ResponseEntity<CommonResult> forEntity =
                          restTemplate.getForEntity(PAYMENT_URL + "/get/" + id, CommonResult.class);
                  
                  if (forEntity.getStatusCode().is2xxSuccessful()) {
                      return forEntity.getBody();
                  }else {
                      return CommonResult.notFound("没有找到",404);
                  }"
                - postForObject
                - postForEntity
              - 均衡算法 IRule ⭐面试考点
                - 原理
                  "第几次请求 % 服务器总数目 = 实际调用第几个服务器
                  
                  注意处理并发
                  1. 第几次请求 这个需要用 AtomicInteger 来记录
                  2. list.get(第几次请求 % size) 可能为 null 需要重试"
                - 源码 public Server choose(Object key)
                  "利用 key （即服务提供者的名字） 选择具体哪个实例 server"
                - 内置算法
                  - RoundRobinRule 轮询
                  - RandomRule 随机
                  - RetryRule  轮询的扩展 重试
                  - BestAvailableRule 过滤故障服务，再选择负载最小的
                  - ZoneAvoidanceRule 默认的复合判断服务所在区域和性能
                - 替换算法
                  - 自定义配置类 但是这个类不能被spring扫描到，否则会失去特殊性
                  - 在启动类所在包外部，新建包 com.atguigu.myrule 新建类MyRibbonRule类
                    "@Configuration
                    public class MyRibbonRule {
                        private final static Logger LOGGER = LoggerFactory.getLogger(MyRibbonRule.class);
                    
                        @Bean
                        public IRule myRule(){
                            return new RandomRule(); // 随机
                        }
                    }"
                  - 在自动类上加上 @RibbonClient(name = "CLOUD-PAYMENT-SERVICE", configuration = MyRibbonRule.class)
                - 自己手写算法 略 实现IRule即可
            - Ribborn 和 Nginx 的区别
              "Nginx 服务器的均衡。浏览器的请求全部进入 Nginx。再转发
              Ribborn 微服务均衡。服务消费者均衡的调用服务提供者。
              
              Nginx /njiks/"
          - 服务接口调用 OpenFeign
            - OpenFeign 声明式的web服务客户端
              "使用方法：创建接口（底层动态实现这个接口），添加注解 类似mybatis"
            - OpenFeign 目的：替代 ribbon+restTemplate
            - 简单使用
              - 注意：需要配合 eureka 服务注册使用，并运行服务提供者：
                "cloud-provider-payment28001
                    [eureka 服务注册中心] 服务提供者
                cloud-provider-payment28002
                    [eureka 服务注册中心] 服务提供者"
              - 新建模块 cloud-consumer-order20088
              - POM
                "主要是 eureka 客户端 + openfeign
                
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-starter-openfeign</artifactId>
                </dependency>
                
                全部
                -----------------
                <?xml version="1.0" encoding="UTF-8"?>
                <project xmlns="http://maven.apache.org/POM/4.0.0"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                    <parent>
                        <artifactId>cloud20200413</artifactId>
                        <groupId>com.atguigu.springcloud</groupId>
                        <version>1.0-SNAPSHOT</version>
                    </parent>
                    <modelVersion>4.0.0</modelVersion>
                
                    <artifactId>cloud-consumer-order20088</artifactId>
                
                    <dependencies>
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-starter-web</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-starter-actuator</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.springframework.cloud</groupId>
                            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.springframework.cloud</groupId>
                            <artifactId>spring-cloud-starter-openfeign</artifactId>
                        </dependency>
                
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-devtools</artifactId>
                            <scope>runtime</scope>
                            <optional>true</optional>
                        </dependency>
                
                
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-starter-test</artifactId>
                            <scope>test</scope>
                        </dependency>
                
                        <dependency>
                            <groupId>com.atguigu.springcloud</groupId>
                            <artifactId>cloud-api-commons</artifactId>
                            <version>${project.version}</version>
                        </dependency>
                
                    </dependencies>
                </project>"
              - YML
                "server:
                  port: 20088
                
                spring:
                  application:
                    name: cloud-order-client
                
                eureka:
                  client:
                    register-with-eureka: true
                    fetch-registry: true
                    service-url:
                      defaultZone: http://192.168.2.13:27001/eureka/,http://192.168.2.3:27002/eureka/
                #      defaultZone: http://192.168.2.13:27001/eureka/
                  instance:
                    instance-id: order20088
                    prefer-ip-address: true"
              - 启动类 @EnableFeignClients
                "@EnableFeignClients
                //@EnableEurekaClient //不再需要这个，因为feign自带
                @SpringBootApplication
                public class OrderFeignMain20088 {
                    private final static Logger LOGGER = LoggerFactory.getLogger(OrderFeignMain20088.class);
                
                    public static void main(String[] args) {
                        SpringApplication.run(OrderFeignMain20088.class, args);
                    }
                }"
              - 应用接口 @FeignClient
                "@Component
                @FeignClient("CLOUD-PAYMENT-SERVICE") // 服务名字
                public interface PaymentService {
                    /**
                     *
                     * @param payment payment
                     * @return i>0 表示插入成功
                     */
                    @PostMapping("payment/create") // 注意是完整路径
                    CommonResult<Integer> create(@RequestBody Payment payment);
                
                    @GetMapping("payment/get/{id}")
                    CommonResult<Payment> getById(@PathVariable("id") Long id);
                }"
              - controller
                "@RestController
                @RequestMapping("/consumer/payment")
                public class OrderFeignController {
                    private final static Logger LOGGER = LoggerFactory.getLogger(OrderFeignController.class);
                
                    @Resource // 注入接口，自动实现
                    private PaymentService paymentService;
                
                    @PostMapping("/create")
                    public CommonResult<?> create(@RequestBody Payment payment) {
                        LOGGER.info("payment = {}", payment);
                        return paymentService.create(payment);
                    }
                
                    @GetMapping("get/{id}")
                    public CommonResult<?> getById(@PathVariable("id") Long id) {
                        LOGGER.info("id = {}", id);
                        return paymentService.getById(id);
                    }
                }"
            - 超时控制
              - 消费者默认等待1s，请求超时则TimeOut
              - 案例：有个服务，需要执行3秒才有返回值。如何让feign不认为这是超时？
                "这个由 ribbon 控制
                YML 添加
                
                ribbon:
                  # 连接超时
                  ConnectTimeout: 5000
                  # 响应超时
                  ReadTimeout: 5000"
            - 日志打印
              - 日志级别
                "NONE 无日志 默认
                BASIC 请求方法、URL、返回状态码
                HEARDERS 请求头、响应头
                FULL 请求体、响应体"
              - 配置方法 1.配置类 2.YML
                - 配置类
                  "@Configuration
                  public class FeignConfig {
                      private final static Logger LOGGER = LoggerFactory.getLogger(FeignConfig.class);
                  
                      /**
                       * feign 日志级别
                       * @return FULL 级别
                       */
                      @Bean
                      public feign.Logger.Level level(){
                          return feign.Logger.Level.FULL;
                      }
                  }"
                - YML 开启应用接口的debug
                  "logging:
                    level:
                      com.atguigu.springcloud.PaymentService: debug"
              - 效果
                "2020-04-20 22:34:53.317  INFO 13568 --- [io-20088-exec-2] c.a.s.controller.OrderFeignController    : id = 43
                2020-04-20 22:34:53.317 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] ---> GET http://CLOUD-PAYMENT-SERVICE/payment/get/43 HTTP/1.1
                2020-04-20 22:34:53.317 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] ---> END HTTP (0-byte body)
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] <--- HTTP/1.1 200 (20ms)
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] connection: keep-alive
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] content-type: application/json
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] date: Mon, 20 Apr 2020 14:34:53 GMT
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] keep-alive: timeout=60
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] transfer-encoding: chunked
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] 
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] {"code":200,"message":"查找成功-- 服务提供者的端口号是28001 --","data":{"id":43,"serial":"feign使用成功"}}
                2020-04-20 22:34:53.339 DEBUG 13568 --- [io-20088-exec-2] com.atguigu.springcloud.PaymentService   : [PaymentService#getById] <--- END HTTP (124-byte body)"
          - 服务降级/熔断 Hystrix
            - 基础知识
              - 服务扇出
                "                       |-- B
                服务A 调用 -|
                                       |-- C -> |
                                                      --> D 、E
                
                服务多层调用"
              - 服务扇出导致的雪崩
                "调用链路上，某个服务出现延时、不可用，导致整个微服务崩溃
                
                这时需要服务降级"
              - 服务降级 fallback
                "当某个服务不可用时，返回备用相应（FallBack），而不是长时间的等待"
                - 触发原因
                  "宕机 异常 超时 熔断 线程池/信号量满了"
              - 服务熔断 break
                "服务负载太大，拒绝请求，导致降级。而不是积压着导致崩溃
                
                负载降低后，可以恢复服务"
              - 服务限流 flow limit
                "限制每秒处理请求次数"
            - Hystrix
              - 简单使用
                - 建立环境
                  - 新建项目cloud-eureka-server27010 //单独eureka服务器
                    - POM
                      "<?xml version="1.0" encoding="UTF-8"?>
                      <project xmlns="http://maven.apache.org/POM/4.0.0"
                               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                               xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                          <parent>
                              <artifactId>cloud20200413</artifactId>
                              <groupId>com.atguigu.springcloud</groupId>
                              <version>1.0-SNAPSHOT</version>
                          </parent>
                          <modelVersion>4.0.0</modelVersion>
                      
                          <artifactId>cloud-eureka-server27010</artifactId>
                      
                          <dependencies>
                              <!-- 不用写版本,因为 eureka 在父工程 spring cloud 中 -->
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
                              </dependency>
                      
                      
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-web</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-actuator</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-devtools</artifactId>
                                  <scope>runtime</scope>
                                  <optional>true</optional>
                              </dependency>
                      
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-test</artifactId>
                                  <scope>test</scope>
                              </dependency>
                      
                              <dependency>
                                  <groupId>junit</groupId>
                                  <artifactId>junit</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>com.atguigu.springcloud</groupId>
                                  <artifactId>cloud-api-commons</artifactId>
                                  <version>${project.version}</version>
                              </dependency>
                          </dependencies>
                      </project>"
                    - YML
                      "server:
                        port: 27010
                      
                      eureka:
                        instance:
                          hostname: 192.168.2.13
                        client:
                          register-with-eureka: false
                          fetch-registry: false
                          service-url:
                            defaultZone: http://192.168.2.3:27010/eureka/
                        server:
                          enable-self-preservation: false"
                    - 启动类
                      "@EnableEurekaServer
                      @SpringBootApplication
                      public class EurekaServer27010 {
                          private final static Logger LOGGER = LoggerFactory.getLogger(EurekaServer27010.class);
                      
                          public static void main(String[] args) {
                              SpringApplication.run(EurekaServer27010.class, args);
                          }
                      }"
                  - 新建项目cloud-provider-payment28010
                    - POM hystrix + eureka
                      "<?xml version="1.0" encoding="UTF-8"?>
                      <project xmlns="http://maven.apache.org/POM/4.0.0"
                               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                               xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                          <parent>
                              <artifactId>cloud20200413</artifactId>
                              <groupId>com.atguigu.springcloud</groupId>
                              <version>1.0-SNAPSHOT</version>
                          </parent>
                          <modelVersion>4.0.0</modelVersion>
                      
                          <artifactId>cloud-provider-payment28010</artifactId>
                      
                      
                          <dependencies>
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-web</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-actuator</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.mybatis.spring.boot</groupId>
                                  <artifactId>mybatis-spring-boot-starter</artifactId>
                              </dependency>
                              <dependency>
                                  <groupId>com.alibaba</groupId>
                                  <artifactId>druid-spring-boot-starter</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>mysql</groupId>
                                  <artifactId>mysql-connector-java</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-jdbc</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                              </dependency>
                      
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-devtools</artifactId>
                                  <scope>runtime</scope>
                                  <optional>true</optional>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.projectlombok</groupId>
                                  <artifactId>lombok</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-test</artifactId>
                                  <scope>test</scope>
                              </dependency>
                      
                              <dependency>
                                  <groupId>com.atguigu.springcloud</groupId>
                                  <artifactId>cloud-api-commons</artifactId>
                                  <version>${project.version}</version>
                              </dependency>
                      
                          </dependencies>
                      
                      
                      </project>"
                    - YML
                      "server:
                        port: 28010
                      
                      spring:
                        application:
                          name: Cloud-payment-service
                        datasource:
                          type: com.alibaba.druid.pool.DruidDataSource
                          driver-class-name: com.mysql.cj.jdbc.Driver
                          url: jdbc:mysql://192.168.2.3:3306/springcloud20200413?serverTimezone=Hongkong&useUnicode=true&characterEncoding=utf8&useSSL=false
                          username: root
                          password: 123456
                      
                      eureka:
                        client:
                          register-with-eureka: true
                          fetch-registry: true
                          service-url:
                            defaultZone: http://192.168.2.13:27001/eureka/,http://192.168.2.3:27002/eureka/
                        instance:
                          instance-id: payment28010
                          prefer-ip-address: true
                      
                      mybatis:
                        mapper-locations: classpath:mapper/*.xml
                        type-aliases-package: com.atguigu.springcloud.entity"
                    - 主启动类
                      "@EnableEurekaClient
                      @SpringBootApplication
                      public class Payment28010 {
                          private final static Logger LOGGER = LoggerFactory.getLogger(Payment28010.class);
                      
                          public static void main(String[] args) {
                              SpringApplication.run(Payment28010.class, args);
                          }
                      }"
                    - 业务类
                      "包含两个业务，A立即返回，B会导致当前线程休眠3秒
                      这时，如果大量访问B，会导致A也受到影响，因为没有多余线程处理A
                      
                      ----------------------
                      @RequestMapping("/payment")
                      @RestController
                      public class PaymentController {
                          private final static Logger LOGGER = LoggerFactory.getLogger(PaymentController.class);
                      
                          @Resource
                          private PaymentService paymentService;
                      
                          @Value("${server.port}")
                          private String port;
                      
                      
                          /**
                           * 正常业务
                           */
                          @PostMapping(value = "/create")
                          public CommonResult<Integer> create(@RequestBody Payment payment) {
                              int result = paymentService.create(payment);
                              LOGGER.info("payment insert result={}", result);
                      
                              if (result > 0)
                                  return CommonResult.success("插入数据库成功" + serverFrom(), result);
                              else
                                  return CommonResult.notFound("插入数据库失败" + serverFrom(), result);
                          }
                      
                      
                          /**
                           * 暂停3秒
                           */
                          @GetMapping("/get/{id}")
                          public CommonResult<Payment> getById(@PathVariable("id") Long id) {
                              int timeOut = 3;
                      
                              try {
                                  TimeUnit.SECONDS.sleep(timeOut);
                      
                              } catch (InterruptedException ignore) {
                              }
                      
                              //int result = paymentService.create(payment);
                              //LOGGER.info("payment insert result={}", result);
                      
                              Map<String, String> infoMap = new HashMap<>();
                              infoMap.put("线程名", Thread.currentThread().getName());
                              infoMap.put("服务提供者", serverFrom());
                              infoMap.put("动作", "耗时" + timeOut + "秒，不插入，返回-1");
                      
                              LOGGER.info("infoMap = {}", infoMap);
                      
                              return CommonResult.notFound(infoMap.toString(), null);
                          }
                      
                          private String serverFrom() {
                              return "-- 服务提供者的端口号是" + port + " --";
                          }
                      }"
                  - 利用jmeter进行压力测试
                  - 新建项目 cloud-consumer-order20090
                    - POM feign+hystrix
                      "<?xml version="1.0" encoding="UTF-8"?>
                      <project xmlns="http://maven.apache.org/POM/4.0.0"
                               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                               xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                          <parent>
                              <artifactId>cloud20200413</artifactId>
                              <groupId>com.atguigu.springcloud</groupId>
                              <version>1.0-SNAPSHOT</version>
                          </parent>
                          <modelVersion>4.0.0</modelVersion>
                      
                          <artifactId>cloud-consumer-order20090</artifactId>
                      
                          <dependencies>
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-web</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-openfeign</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-actuator</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-devtools</artifactId>
                                  <scope>runtime</scope>
                                  <optional>true</optional>
                              </dependency>
                      
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-starter-test</artifactId>
                                  <scope>test</scope>
                              </dependency>
                      
                              <dependency>
                                  <groupId>com.atguigu.springcloud</groupId>
                                  <artifactId>cloud-api-commons</artifactId>
                                  <version>${project.version}</version>
                              </dependency>
                      
                          </dependencies>
                      </project>"
                    - YML
                      "@EnableFeignClients
                      @SpringBootApplication
                      public class OrderFeignMain20090 {
                          private final static Logger LOGGER = LoggerFactory.getLogger(OrderFeignMain20090.class);
                      
                          public static void main(String[] args) {
                              SpringApplication.run(OrderFeignMain20090.class,args);
                          }
                      }"
                    - 启动类
                      "@EnableFeignClients
                      @SpringBootApplication
                      public class OrderFeignMain20090 {
                          private final static Logger LOGGER = LoggerFactory.getLogger(OrderFeignMain20090.class);
                      
                          public static void main(String[] args) {
                              SpringApplication.run(OrderFeignMain20090.class,args);
                          }
                      }"
                    - service接口 面向feign
                      "@Service
                      @FeignClient(name = "CLOUD-PAYMENT-SERVICE")
                      public interface OrderService {
                      
                      
                          @PostMapping(value = "/payment/create")
                          CommonResult<Integer> create(@RequestBody Payment payment);
                      
                          /**
                           * 暂停3秒
                           */
                          @GetMapping("/payment/get/{id}")
                          CommonResult<Payment> getById(@PathVariable("id") Long id);
                      
                      }"
                    - controller 调用service
                      "@RestController
                      @RequestMapping("/consumer/payment")
                      public class OrderController {
                          private final static Logger LOGGER = LoggerFactory.getLogger(OrderController.class);
                      
                          @Resource // 注入接口，自动实现
                          private OrderService orderService;
                      
                          @PostMapping("/create")
                          public CommonResult<?> create(@RequestBody Payment payment) {
                              LOGGER.info("payment = {}", payment);
                              return orderService.create(payment);
                          }
                      
                          @GetMapping("get/{id}")
                          public CommonResult<?> getById(@PathVariable("id") Long id) {
                              LOGGER.info("id = {}", id);
                              return orderService.getById(id);
                          }
                      }"
                - 面临的问题 ⭐
                  "服务提供者 cloud-provider-payment28010 有两个服务（url）
                  	A. http://192.168.2.13:20090/consumer/payment/get/43
                  	B. http://192.168.2.13:20090/consumer/payment/create
                  
                  其中A服务，每次调用需要3秒（sleep(3000)），另一个B服务秒返回
                  
                  当并发访问A时，线程池满了，都去处理A任务，这就导致B服务也会收到影响
                  
                  需求：
                  	出现超时时，不再等待，返回友好信息
                  	兜底 服务降级
                  
                  "
                - 服务降级 消费者/提供者都可以降级
                  - 定义：当调用的服务出现意外情况，转而调用兜底服务
                  - 简单使用
                    - 1. 如果使用了feign 则配置文件加上
                      "feign:
                        hystrix:
                          enabled: true"
                    - 2. 启动类开启 @EnableCircuitBreaker 或 @EnableHystrix
                      "@EnableHystrix 自带@EnableCircuitBreaker "
                    - 3. 写兜底方法和注解
                      "getById 这个方法执行需要3秒
                      在这个方法上添加注解
                      @HystrixCommand(fallbackMethod="兜底方法",commandProperties ={什么情况下执行兜底方法})
                      
                      在本类中，写兜底方法getByIdFallbackForTimeout
                      
                      
                      @GetMapping("/get/{id}")
                      @HystrixCommand(fallbackMethod = "getByIdFallbackForTimeout",commandProperties = {
                              @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "1000")
                      })
                      public CommonResult<Payment> getById(@PathVariable("id") Long id) {
                          int timeOut = 3;
                          try { TimeUnit.SECONDS.sleep(timeOut);} catch (InterruptedException ignore) {}
                          //....
                      }
                      
                      public CommonResult<Payment> getByIdFallbackForTimeout(Long id) {
                          return CommonResult.requestTimeout("请求超时", Payment.getNullPayment());
                      }"
                    - 注意：以上配置也可以兜底出现异常的情况（除了超时、异常也会进去兜底方法）
                  - 一些优化
                    - 业务逻辑和兜底方法放在一起，代码混杂
                      - 注意需要 feign 和 接口service
                      - 0. 提前准备好 feign 的接口service
                        "@Service
                        @FeignClient(name = "CLOUD-PAYMENT-SERVICE")
                        public interface OrderService {
                        
                        
                            @PostMapping(value = "/payment/create")
                            CommonResult<Integer> create(@RequestBody Payment payment);
                        
                            /**
                             * 暂停3秒
                             */
                            @GetMapping("/payment/get/{id}")
                            CommonResult<Payment> getById(@PathVariable("id") Long id);
                        
                        }"
                      - 1. 实现 feign 的接口service
                        "@Service
                        public class OrderServiceFallbackImpl implements OrderService {
                            private final static Logger LOGGER = LoggerFactory.getLogger(OrderServiceFallbackImpl.class);
                        
                            @Override
                            public CommonResult<Integer> create(Payment payment) {
                                return CommonResult.error("未知异常兜底", -1, 500);
                            }
                        
                            @Override
                            public CommonResult<Payment> getById(Long id) {
                                return CommonResult.error("未知异常兜底", Payment.getNullPayment(), 500);
                            }
                        }"
                      - 2. feign 的接口service 注解 @FeignClient 增加属性
                        "@FeignClient(name = "CLOUD-PAYMENT-SERVICE", fallback = OrderServiceFallbackImpl.class)"
                    - 设置全局兜底fallback
                      - 1. controller类上注解 @DefaultProperties(defaultFallback = "defaultFallbackMethod") 
                      - 2. controller类写默认兜底方法
                      - 3. 需要进行兜底的方法加上注解 @HystrixCommand 
                        "@RequestMapping("/payment")
                        @RestController
                        @DefaultProperties(defaultFallback = "defaultFallbackMethod")
                        public class PaymentController {
                            private final static Logger LOGGER = LoggerFactory.getLogger(PaymentController.class);
                        
                            @Resource
                            private PaymentService paymentService;
                        
                            @Value("${server.port}")
                            private String port;
                        
                        
                            /**
                             * 正常业务
                             */
                            @PostMapping(value = "/create")
                            @HystrixCommand
                            public CommonResult<Integer> create(@RequestBody Payment payment) {
                                int result = paymentService.create(payment);
                                LOGGER.info("payment insert result={}", result);
                        
                                if (result > 0)
                                    return CommonResult.success("插入数据库成功" + serverFrom(), result);
                                else
                                    return CommonResult.notFound("插入数据库失败" + serverFrom(), result);
                            }
                        
                        
                            /**
                             * 暂停3秒
                             */
                            @GetMapping("/get/{id}")
                            @HystrixCommand(fallbackMethod = "getByIdFallbackForTimeout",commandProperties = {
                                    @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "1000")
                            })
                            public CommonResult<Payment> getById(@PathVariable("id") Long id) {
                                LOGGER.info("进入getById");
                                int timeOut = 3;
                                try { TimeUnit.SECONDS.sleep(timeOut);} catch (InterruptedException ignore) {
                                    LOGGER.info("被打断了？");
                                }
                                LOGGER.info("超时{}秒结束", timeOut);
                        
                                Map<String, String> infoMap = new HashMap<>();
                                infoMap.put("线程名", Thread.currentThread().getName());
                                infoMap.put("服务提供者", serverFrom());
                                infoMap.put("动作", "耗时" + timeOut + "秒，不插入，返回-1");
                        
                                LOGGER.info("infoMap = {}", infoMap);
                        
                                return CommonResult.notFound(infoMap.toString(), null);
                            }
                        
                            public CommonResult<Payment> getByIdFallbackForTimeout(Long id) {
                                LOGGER.info("进入getByIdFallbackForTimeout");
                                return CommonResult.requestTimeout("请求超时", Payment.getNullPayment());
                            }
                        
                            public CommonResult<Nullable> defaultFallbackMethod(){
                                return CommonResult.notFound("默认兜底",null);
                            }
                        
                        
                            private String serverFrom() {
                                return "-- 服务提供者的端口号是" + port + " --";
                            }
                        }"
                - 服务熔断
                  - 定义：某服务总是出现异常时，不再执行业务，直接返回友好信息。正常后可恢复
                    "服务降级和熔断的区别：
                    	服务降级——原业务还是会执行，只是可能有异常
                    	服务熔断——原业务不再执行了"
                  - 熔断器三个状态
                    - 关闭：不熔断，执行业务（若出错还是会进入兜底方法）
                    - 开启：不再执行业务，直接执行兜底方法
                    - 半开：尝试放1个请求去执行业务，若成功，则进入关闭状态
                  - 默认熔断扳机 满足两个条件
                    - 1. 10秒内有20次以上的请求
                    - 2. 10秒内请求错误率>50%
                  - 恢复策略
                    "经过一段时间后，进入半开状态"
                  - 简单使用
                    - 建立环境
                      - 新建项目 cloud-eureka-server27012
                      - 新建项目 cloud-provider-payment28012
                      - 新建项目 cloud-consumer-order20092
                    - 在contrller层 加上服务熔断逻辑
                      "// 服务熔断
                      @GetMapping("get/{id}")
                      @HystrixCommand(fallbackMethod = "getByIdFallback",commandProperties = {
                              @HystrixProperty(name = "circuitBreaker.enabled",value = "true"), // 是否开始熔断
                              @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"), //请求次数
                              @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"), // 时间窗口，只有10秒内，请求有10次以上，且错误率>60%才会熔断
                              @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"), // 失败率达到多少后跳闸
                      })
                      public CommonResult<?> getById(@PathVariable("id") Long id) {
                          LOGGER.info("getById id = {}", id);
                      
                          if (id < 0)
                              throw new RuntimeException("id[" + id + "]不能为负数");
                      
                          return orderService.getById(id);
                      }
                      
                      public CommonResult<?> getByIdFallback(Long id) {
                          return CommonResult.badRequest("id[" + id + "]不能为负数", null);
                      }"
                - 服务限流 略
              - 服务监控
                - hystrix提供服务监控功能
                - 新建模块 cloud-provider-payment28013
                - POM 需要 actuator
                - 略
          - 服务网关 springcloud gateway
            - 位置
              "外部访问
              ↓↓↓↓↓↓↓↓
              负载均衡 只有一台，全部从此入口
              ↓                 ↓
              服务网关 服务网关 多台
              ↓↓↓↓↓
              微服务ABCDE...  集群
              
              "
            - 作用：将外界请求发到微服务节点、在请求前后可以控制（进再出）
              "反向代理 鉴权 流量控制 熔断 监控"
            - zuul @Deprecated 
              "zuul 1.0 进入维护模式
              zuul 2.0 一直不发布正式版
              
              "
            - Gateway
              - 技术：webflux reactor-netty 非阻塞 响应式
              - 比zuul优势
                "动态路由 匹配任何请求属性
                对路由指定 过滤filter 断言predicate
                集成hystrix断路器
                集成springcloud服务发现
                支持限流
                支持路径重写
                
                zuul 阻塞框架 —— 没来一个请求，都是从线程池拿一个线程，并一直持有，直到完成全部操作
                zuul tomcat容器 传统 servlet IO 
                
                异步非阻塞——很少的线程，就能完成大量请求"
              - 核心概念
                - 路由 route
                  "转发到不同的微服务"
                  - 路由=id名字、uri、断言、过滤
                    "id 取个唯一名字
                    uri 处理哪个请求
                    断言 是否转发
                    过滤 修改请求/相应"
                - 断言 predicate
                  "匹配则路由
                  
                  一个路由可以多次断言"
                  - 最常用的 Path
                - 过滤 filter 类似于拦截器
                  "在请求前or后，对请求进行修改"
                  - 工作位置：pre post
                  - 全局过滤器
                  - 特定路由的过滤器
                  - 目的：日志、鉴权（token校验）
              - 简单使用
                - 基础环境
                  - 新建模块 cloud-eureka-server27020
                    "最简单的eureka服务端"
                  - 新建模块 cloud-provider-payment28020 
                    "最简单的服务提供者"
                  - 新建模块 cloud-provider-payment28021
                    "同上 只是端口为28021"
                - 静态路由
                  - YML 配置法
                    - 新建模块 cloud-gateway29527
                    - POM 需要 spring-cloud-starter-gateway 和 eureka  [注意去除web组件]
                      "<?xml version="1.0" encoding="UTF-8"?>
                      <project xmlns="http://maven.apache.org/POM/4.0.0"
                               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                               xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                          <parent>
                              <artifactId>cloud20200413</artifactId>
                              <groupId>com.atguigu.springcloud</groupId>
                              <version>1.0-SNAPSHOT</version>
                          </parent>
                          <modelVersion>4.0.0</modelVersion>
                      
                          <artifactId>cloud-gateway29527</artifactId>
                      
                          <dependencies>
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-gateway</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.cloud</groupId>
                                  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                              </dependency>
                      
                              <dependency>
                                  <groupId>org.springframework.boot</groupId>
                                  <artifactId>spring-boot-devtools</artifactId>
                                  <scope>runtime</scope>
                                  <optional>true</optional>
                              </dependency>
                      
                              <dependency>
                                  <groupId>com.atguigu.springcloud</groupId>
                                  <artifactId>cloud-api-commons</artifactId>
                                  <version>${project.version}</version>
                              </dependency>
                          </dependencies>
                      </project>"
                    - YML
                      "server:
                        port: 29527
                      
                      spring:
                        application:
                          name: cloud-gateway29527
                        cloud:
                          gateway:
                            routes: # 数组
                              - id: cloud-provider-payment28020 #路由id名，需要唯一
                                uri: http://192.168.2.13:28020 #服务地址
                                predicates:
                                  - Path=/payment/get/** # 断言数组
                              - id: cloud-provider-payment28021
                                uri: http://192.168.2.13:28021
                                predicates:
                                  - Path=/payment/create
                      
                      eureka:
                        client:
                          register-with-eureka: true
                          fetch-registry: true
                          service-url:
                            defaultZone: http://192.168.2.13:27020/eureka/
                        instance:
                          instance-id: cloud-gateway29527
                          prefer-ip-address: true"
                    - 主启动
                      "@EnableEurekaClient
                      @SpringBootApplication
                      public class Gateway29527 {
                          private final static Logger LOGGER = LoggerFactory.getLogger(Gateway29527.class);
                      
                          public static void main(String[] args) {
                              SpringApplication.run(Gateway29527.class, args);
                          }
                      }"
                    - 效果
                      "http://192.168.2.13:29527/payment/get/58 -->实际是 28020
                      http://192.168.2.13:29527/payment/create --> 实际是 28021"
                  - 硬编码法
                    - 新建模块 cloud-gateway29528
                    - POM YML 主启动 同29527
                      "YML 去除 gateway 配置信息"
                    - 加入配置类
                      "@Configuration
                      public class GatewayConfig {
                          private final static Logger LOGGER = LoggerFactory.getLogger(GatewayConfig.class);
                      
                          @Bean
                          public RouteLocator routes(RouteLocatorBuilder builder) {
                              //https://news.sogou.com/ent
                              //https://news.sogou.com/business
                              return builder.routes()
                                      .route("ent", r -> r.path("/ent").uri("https://news.sogou.com/ent"))
                                      .route("business", r -> r.path("business").uri("https://news.sogou.com/business"))
                                      .build();
                          }
                      }"
                - 动态路由
                  - 实现原理：根据eureka中的服务名实现动态路由
                  - 实现方法：YML文件配置中把uri改成lb://服务名
                    "lb 含义 load balance"
                  - 简单使用
                    - 创建 cloud-gateway29529
                      - POM
                        "<?xml version="1.0" encoding="UTF-8"?>
                        <project xmlns="http://maven.apache.org/POM/4.0.0"
                                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                                 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                            <parent>
                                <artifactId>cloud20200413</artifactId>
                                <groupId>com.atguigu.springcloud</groupId>
                                <version>1.0-SNAPSHOT</version>
                            </parent>
                            <modelVersion>4.0.0</modelVersion>
                        
                            <artifactId>cloud-gateway29529</artifactId>
                            <dependencies>
                                <dependency>
                                    <groupId>org.springframework.cloud</groupId>
                                    <artifactId>spring-cloud-starter-gateway</artifactId>
                                </dependency>
                        
                                <dependency>
                                    <groupId>org.springframework.cloud</groupId>
                                    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                                </dependency>
                        
                                <dependency>
                                    <groupId>org.springframework.boot</groupId>
                                    <artifactId>spring-boot-devtools</artifactId>
                                    <scope>runtime</scope>
                                    <optional>true</optional>
                                </dependency>
                        
                                <dependency>
                                    <groupId>com.atguigu.springcloud</groupId>
                                    <artifactId>cloud-api-commons</artifactId>
                                    <version>${project.version}</version>
                                </dependency>
                            </dependencies>
                        </project>"
                      - YML
                        "server:
                          port: 29529
                        
                        spring:
                          application:
                            name: cloud-gateway29529
                          cloud:
                            gateway:
                              discovery:
                                locator:
                                  enabled: true # 开启从注册中心动态创建路由的功能
                              routes:
                                - id: cloud-provider-payment28020 #路由id名，需要唯一
                                  uri: lb://CLOUD-PAYMENT-SERVICE # lb://服务名字
                                  predicates:
                                    - Path=/payment/get/** # 断言数组
                                - id: cloud-provider-payment28021
                                  uri: lb://CLOUD-PAYMENT-SERVICE
                                  predicates:
                                    - Path=/payment/create
                        
                        eureka:
                          client:
                            register-with-eureka: true
                            fetch-registry: true
                            service-url:
                              defaultZone: http://192.168.2.13:27020/eureka/
                          instance:
                            instance-id: cloud-gateway29529
                            prefer-ip-address: true"
                      - 主启动
                        "@EnableEurekaClient
                        @SpringBootApplication
                        public class Gateway29529 {
                            private final static Logger LOGGER = LoggerFactory.getLogger(Gateway29529.class);
                        
                            public static void main(String[] args) {
                                SpringApplication.run(Gateway29529.class, args);
                            }
                        }"
                    - 需要配合 cloud-eureka-server27020 cloud-provider-payment28020 cloud-provider-payment280201
                - predicate 使用
                  - 配置方法 YML法
                    "routes:
                      - id: cloud-provider-payment28020 #路由id名，需要唯一
                        uri: lb://CLOUD-PAYMENT-SERVICE # lb://服务名字
                        predicates:
                          - Path=/payment/get/** # 此处配置断言"
                  - 常用predicate
                    - After=2020-04-27T17:20:21.789-07:oo[America/Denver] 表示次此刻后才true
                      "时刻格式：ZoneDateTime 对象
                      可以用于功能上线"
                    - Before 之前才true
                    - Cookie=name, regex // 必须带有name的cooike，且值满徐regex正则表达式
                    - Header 请求头必须含有且值满足regex
                    - 其他的查看文档
                      "https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#gateway-request-predicates-factories"
                  - 附录：curl工具 利用URL语法在命令行下工作的文件传输工具
                    - curl url --cookie "name=value"
                      "发送cookie"
                - filter 使用
                  - 内置过滤器
                    - 举例：添加header
                    - 文档https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#gatewayfilter-factories
                  - 自定义全局过滤器
                    "@Bean
                    public GlobalFilter customFilter() {
                        return new CustomGlobalFilter();
                    }
                    
                    public class CustomGlobalFilter implements GlobalFilter, Ordered {
                    
                        @Override
                        public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                            log.info("custom global filter");
                            return chain.filter(exchange);
                        }
                    
                        @Override
                        public int getOrder() {
                            return -1;
                        }
                    }"
          - 服务配置 springcloud config
            - 痛点：多个微服务都要连接数据库，现在数据库密码修改了，每个微服务配置都要变
            - 目的：一套集中的、动态的配置管理设施
            - springcloud config
              - 功能
                "集中管理配置文件
                不同环境配置文件切换
                运行期动态调整
                配置发生变动时、服务可感知、不需要重启
                配置信息以REST接口暴露
                GIT整和"
              - 简单实用
                - 服务端构建流程
                  - GitHub上建立Repository https://github.com/madokast/springcloudConfig
                  - 上传配置文件 https://github.com/madokast/springcloudConfig/tree/master/springcloud-config0428
                  - 新建模块 cloud-config-center23344
                  - POM
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>cloud20200413</artifactId>
                            <groupId>com.atguigu.springcloud</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>cloud-config-center23344</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-config-server</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-devtools</artifactId>
                                <scope>runtime</scope>
                                <optional>true</optional>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.atguigu.springcloud</groupId>
                                <artifactId>cloud-api-commons</artifactId>
                                <version>${project.version}</version>
                            </dependency>
                        </dependencies>
                    
                    </project>"
                  - YML
                    "server:
                      port: 23344
                    
                    spring:
                      application:
                        name: cloud-config-center23344
                      cloud:
                        config:
                          server:
                            git:
                              uri: https://github.com/madokast/springcloudConfig.git
                              search-paths:
                                - springcloud-config0428
                              skipSslValidation: true
                              force-pull: true
                          label: master
                    
                    eureka:
                      client:
                        register-with-eureka: true
                        fetch-registry: true
                        service-url:
                          defaultZone: http://192.168.2.13:27020/eureka/
                    
                      instance:
                        instance-id: config-center23344
                        prefer-ip-address: true"
                  - 主启动
                    "@SpringBootApplication
                    @EnableConfigServer
                    public class Config23344 {
                        private final static Logger LOGGER = LoggerFactory.getLogger(Config23344.class);
                    
                        public static void main(String[] args) {
                            SpringApplication.run(Config23344.class, args);
                    
                        }
                    }"
                - 客户端构建流程（客户端就是每个微服务）
                  - 新建模块 cloud-config-client23355
                  - POM
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>cloud20200413</artifactId>
                            <groupId>com.atguigu.springcloud</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>cloud-config-client23355</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-starter-config</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-devtools</artifactId>
                                <scope>runtime</scope>
                                <optional>true</optional>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.atguigu.springcloud</groupId>
                                <artifactId>cloud-api-commons</artifactId>
                                <version>${project.version}</version>
                            </dependency>
                        </dependencies>
                    
                    
                    </project>"
                  - 建立 bootstrap.yml 文件（优先级比application.yml高）
                    "server:
                      port: 23355
                    
                    spring:
                      application:
                        name: config-client23355
                      cloud:
                        config:
                          label: master
                          name: config
                          profile: dev
                          uri: http://192.168.2.13:23344
                    
                    eureka:
                      client:
                        register-with-eureka: true
                        fetch-registry: true
                        service-url:
                          defaultZone: http://192.168.2.13:27020/eureka/
                    
                      instance:
                        instance-id: config-client23355
                        prefer-ip-address: true
                    
                    
                    mybatis:
                      mapper-locations: classpath:mapper/*.xml
                      type-aliases-package: com.atguigu.springcloud.entity"
                  - git 上的 config-dev.yml
                    "spring:
                      datasource:
                        driver-class-name: com.mysql.cj.jdbc.Driver
                        password: 123456
                        type: com.alibaba.druid.pool.DruidDataSource
                        url: jdbc:mysql://192.168.2.3:3306/springcloud20200413?serverTimezone=Hongkong&useUnicode=true&characterEncoding=utf8&useSSL=false
                        username: root"
                  - 改配之后 实现自动更新
                    - POM引入
                      "<dependency>
                          <groupId>org.springframework.boot</groupId>
                          <artifactId>spring-boot-starter-actuator</artifactId>
                      </dependency>"
                    - YML
                      "management:
                        endpoints:
                          web:
                            exposure:
                              include: "*""
                    - controller类加上 @RefreshScope 注解
                    - 更新方法 // 手动方法
                      "1. 上传github
                      2. 刷新服务端
                      3. 刷新客户端 发送POST请求到客户端 /actuator/refresh"
          - 服务总线 bus-amqp
            - 痛点 配合springconfig实现配置动态刷新
            - 目的 服务间传播消息
            - 原理 利用消息队列，构建一个共用的主题topic
              "主题里的消息会被所有服务监听，每个服务都可以广播消息"
            - 刷新方法 外部POST到一个服务，由这个服务广播到所有其他服务
            - 简单使用
              - 安装rabbitMQ
                "docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management"
              - 访问 http://192.168.2.3:15672
                "guest guest"
              - spring config 服务端 新增配置
                - POM
                  "<dependency>
                      <groupId>org.springframework.cloud</groupId>
                      <artifactId>spring-cloud-starter-bus-amqp</artifactId>
                  </dependency>
                  
                  
                  完整POM
                  -----------
                  <?xml version="1.0" encoding="UTF-8"?>
                  <project xmlns="http://maven.apache.org/POM/4.0.0"
                           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                      <parent>
                          <artifactId>cloud20200413</artifactId>
                          <groupId>com.atguigu.springcloud</groupId>
                          <version>1.0-SNAPSHOT</version>
                      </parent>
                      <modelVersion>4.0.0</modelVersion>
                  
                      <artifactId>cloud-config-center23344</artifactId>
                  
                      <dependencies>
                          <dependency>
                              <groupId>org.springframework.cloud</groupId>
                              <artifactId>spring-cloud-config-server</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.cloud</groupId>
                              <artifactId>spring-cloud-starter-bus-amqp</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.cloud</groupId>
                              <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-web</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-actuator</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-devtools</artifactId>
                              <scope>runtime</scope>
                              <optional>true</optional>
                          </dependency>
                  
                          <dependency>
                              <groupId>com.atguigu.springcloud</groupId>
                              <artifactId>cloud-api-commons</artifactId>
                              <version>${project.version}</version>
                          </dependency>
                      </dependencies>
                  
                  </project>"
                - YML
                  "spring:
                    rabbitmq:
                      host: 192.168.2.3
                      port: 5672
                      username: guest
                      password: guest
                  
                  # rabbitMQ 暴露bus刷新配置端点
                  management:
                    endpoints:
                      web:
                        exposure:
                          include: 'bus-refresh'
                  
                  完整yml
                  -------------------
                  server:
                    port: 23344
                  
                  spring:
                    application:
                      name: cloud-config-center23344
                    cloud:
                      config:
                        server:
                          git:
                            uri: https://github.com/madokast/springcloudConfig.git
                            search-paths:
                              - springcloud-config0428
                            skipSslValidation: true
                            force-pull: true
                        label: master
                    rabbitmq:
                      host: 192.168.2.3
                      port: 5672
                      username: guest
                      password: guest
                  
                  eureka:
                    client:
                      register-with-eureka: true
                      fetch-registry: true
                      service-url:
                        defaultZone: http://192.168.2.13:27020/eureka/
                  
                    instance:
                      instance-id: config-center23344
                      prefer-ip-address: true
                  
                  # rabbitMQ 暴露bus刷新配置端点
                  management:
                    endpoints:
                      web:
                        exposure:
                          include: 'bus-refresh'"
              - spring config 客户端 新增配置
                - POM spring-cloud-starter-bus-amqp
                - YML
                  "server:
                    port: 23355
                  
                  spring:
                    application:
                      name: config-client23355
                    cloud:
                      config:
                        label: master
                        name: config
                        profile: dev
                        uri: http://192.168.2.13:23344
                    rabbitmq:
                      host: 192.168.2.3
                      port: 5672
                      username: guest
                      password: guest
                  
                  eureka:
                    client:
                      register-with-eureka: true
                      fetch-registry: true
                      service-url:
                        defaultZone: http://192.168.2.13:27020/eureka/
                  
                    instance:
                      instance-id: config-client23355
                      prefer-ip-address: true
                  
                  
                  mybatis:
                    mapper-locations: classpath:mapper/*.xml
                    type-aliases-package: com.atguigu.springcloud.entity
                  
                  management:
                    endpoints:
                      web:
                        exposure:
                          include: "*""
              - 发送 curl -X POST "http://192.168.2.13:23344/actuator/bus-refresh" 实现全部服务刷新
              - 定点通知 curl -X POST "http://192.168.2.13:23344/actuator/bus-refresh/{服务名称:服务端口}"
                "如 CONFIG-CLIENT23355:23355"
          - 消息驱动 stream
            - 对各种具体的MQ消息队列的封装，统一消息编程模型
              "activeMQ rabbitMQ racketMQ kafka"
            - 基础
              - 传统的消息队列
                - 消息 message
                  "生成者 发送 消息 消费者 接受"
                - 通道 message channel 消息走的通道
              - spring cloud stream
                "https://spring.io/projects/spring-cloud-stream"
                - binder 绑定器 绑定具体的MQ
                - channel 队列的抽象
                - inputs / sink 收消息
                - outputs / source 发消息
                - 模式 基于主题的发布/订阅模型
                  "rabbit MQ的 exchange
                  kafka 的 topic"
                - 流程
                  "生成者 -> source -> channel -> binder -> 底层
                  底层 -> binder -> channel -> sink -> 消费者"
                - 常用API 注解 @Input @Output @StreamListener @EnableBinding 
            - 简单使用
              - 新建模块 cloud-stream-rabbitmq-provider28801
                - POM
                  "<?xml version="1.0" encoding="UTF-8"?>
                  <project xmlns="http://maven.apache.org/POM/4.0.0"
                           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                      <parent>
                          <artifactId>cloud20200413</artifactId>
                          <groupId>com.atguigu.springcloud</groupId>
                          <version>1.0-SNAPSHOT</version>
                      </parent>
                      <modelVersion>4.0.0</modelVersion>
                  
                      <artifactId>cloud-stream-rabbitmq-provider28801</artifactId>
                  
                      <dependencies>
                          <dependency>
                              <groupId>org.springframework.cloud</groupId>
                              <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-web</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-actuator</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.cloud</groupId>
                              <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                          </dependency>
                  
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-devtools</artifactId>
                              <scope>runtime</scope>
                              <optional>true</optional>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-test</artifactId>
                              <scope>test</scope>
                          </dependency>
                  
                          <dependency>
                              <groupId>com.atguigu.springcloud</groupId>
                              <artifactId>cloud-api-commons</artifactId>
                              <version>${project.version}</version>
                          </dependency>
                      </dependencies>
                  </project>"
                - YML
                  "server:
                    port: 28801
                  
                  spring:
                    application:
                      name: cloud-stream-rabbitmq-provider28801
                    cloud:
                      stream:
                        bindings:
                          input:
                            destination: default.messages
                            binder: local_rabbit
                          output:
                            destination: default.messages
                            binder: local_rabbit
                        binders:
                          local_rabbit:
                            type: rabbit
                            environment:
                              spring:
                                rabbitmq:
                                  host: 192.168.2.3
                                  port: 5672
                                  username: guest
                                  password: guest
                  
                  eureka:
                    client:
                      register-with-eureka: true
                      fetch-registry: true
                      service-url:
                        defaultZone: http://192.168.2.13:27020/eureka/
                  
                    instance:
                      instance-id: cloud-stream-rabbitmq-provider28801
                      prefer-ip-address: true
                      lease-renewal-interval-in-seconds: 2
                      lease-expiration-duration-in-seconds: 5"
                - 主启动
                  "@SpringBootApplication
                  @EnableEurekaClient
                  public class StreamConsumer28802 {
                      private final static Logger LOGGER = LoggerFactory.getLogger(StreamConsumer28802.class);
                  
                      public static void main(String[] args) {
                          SpringApplication.run(StreamConsumer28802.class, args);
                      }
                  }"
                - 消息发送接口
                  "public interface IMessageProvider {
                  
                      void send(String message);
                  
                  }"
                - 接口实现 @EnableBinding(Source.class) 
                  "//@Service 不需要service
                  @EnableBinding(Source.class) // 绑定为消息源
                  public class MessageProviderImpl implements IMessageProvider {
                      private final static Logger LOGGER = LoggerFactory.getLogger(MessageProviderImpl.class);
                  
                      @Resource
                      private MessageChannel output;
                  
                      @Override
                      public void send(String message) {
                          LOGGER.info("发送消息 = {}", message);
                          output.send(MessageBuilder.withPayload(message).build());
                      }
                  }"
                - controller
                  "@RestController
                  public class SendMessageController {
                      private final static Logger LOGGER = LoggerFactory.getLogger(SendMessageController.class);
                  
                      @Resource
                      private IMessageProvider messageProviderImpl;
                  
                      @GetMapping("/send/{msg}")
                      public Object send(@PathVariable String msg) {
                          LOGGER.info("msg = {}", msg);
                  
                          messageProviderImpl.send(msg);
                  
                          return CommonResult.success("发送消息", msg);
                      }
                  }"
              - 新建模块 cloud-stream-rabbitmq-consumer28802
                - POM 同 28801
                - YML 同 28801
                - 主启动
                  "@SpringBootApplication
                  @EnableEurekaClient
                  public class StreamConsumer28802 {
                      private final static Logger LOGGER = LoggerFactory.getLogger(StreamConsumer28802.class);
                  
                      public static void main(String[] args) {
                          SpringApplication.run(StreamConsumer28802.class, args);
                      }
                  }"
                - 消息接收
                  "@RestController
                  @EnableBinding(Sink.class)
                  public class ReceiveMessageController {
                      private final static Logger LOGGER = LoggerFactory.getLogger(ReceiveMessageController.class);
                  
                  
                      @Value("${server.port}")
                      private String serverPort;
                  
                  
                      @StreamListener(Sink.INPUT)
                      public void input(Message<String> message) {
                          LOGGER.info("{}收到消息{}", serverPort, message.getPayload());
                      }
                  }"
              - 新建模块 cloud-stream-rabbitmq-consumer28803
                - 同 28803 只是端口不同
              - 使用 http://192.168.2.13:28801/send/msg111 发送消息
                "28802 和 28803 可以收到消息并打印出来"
              - 消费者分组
                - 消息会往每个组发送，组内消费者竞争获取消息
                - 默认下消费者都是不同的组，所以都会拿到消息
                  "28802和28803收到相同消息
                  
                  因为默认下，这两个服务处于不同的组"
                - 如果两个消费者处于同一个组，则竞争消息（轮流发送）
                - 配置 YML group
                  "input:
                    destination: default.messages
                    binder: local_rabbit
                    group: atguigu"
              - 持久化
                - 默认分组（不写group）时，不会持久化消息
                - 指定分组下，会持久化消息
          - 分布式请求链路跟踪 zipkin sleuth
            - 痛点：追踪服务调用链路
            - 相关术语
              "一次请求就是一颗树，例如
              
              A->B->C
                        ->D
              
              服务A请求B，B请求C和D
              
              这棵树称为 链路，用 trace id 标识
              
              span id 即节点，如 A B C D
              
              parent id 表示父节点，也就是谁调用我
              
              例如 A 的父节点 null
              	B 父节点 A
              	D 父节点 B
              "
              - trace id 一条完整的请求链路（树）编号
              - span id 请求中的一个节点（服务）
              - parent id 上一级请求（父节点）
            - 技术 sleuth 跟踪调用 / zipkin 负责展现
            - 简单实用
              "一句话：
              POM加入zipkin
              yml加入
              
              spring:
                zipkin:
                  base-url: http://192.168.2.3:9411
                sleuth:
                  sampler:
                    probability: 1
              
              即可"
              - 运行 zipkin
                "docker run -d -p 9411:9411 openzipkin/zipkin:2.12.9"
              - 启动后验证 http://192.168.2.3:9411/zipkin/
              - 构建模块 cloud-sleuth-payment29880 （简单的eureka客户端）
                - POM  spring-cloud-starter-zipkin
                  "<?xml version="1.0" encoding="UTF-8"?>
                  <project xmlns="http://maven.apache.org/POM/4.0.0"
                           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                      <parent>
                          <artifactId>cloud20200413</artifactId>
                          <groupId>com.atguigu.springcloud</groupId>
                          <version>1.0-SNAPSHOT</version>
                      </parent>
                      <modelVersion>4.0.0</modelVersion>
                  
                      <artifactId>cloud-sleuth-payment29880</artifactId>
                  
                      <dependencies>
                          <dependency>
                              <groupId>org.springframework.cloud</groupId>
                              <artifactId>spring-cloud-starter-zipkin</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-web</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-actuator</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.mybatis.spring.boot</groupId>
                              <artifactId>mybatis-spring-boot-starter</artifactId>
                          </dependency>
                          <dependency>
                              <groupId>com.alibaba</groupId>
                              <artifactId>druid-spring-boot-starter</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>mysql</groupId>
                              <artifactId>mysql-connector-java</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-jdbc</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.cloud</groupId>
                              <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
                          </dependency>
                  
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-devtools</artifactId>
                              <scope>runtime</scope>
                              <optional>true</optional>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.projectlombok</groupId>
                              <artifactId>lombok</artifactId>
                          </dependency>
                  
                          <dependency>
                              <groupId>org.springframework.boot</groupId>
                              <artifactId>spring-boot-starter-test</artifactId>
                              <scope>test</scope>
                          </dependency>
                  
                          <dependency>
                              <groupId>com.atguigu.springcloud</groupId>
                              <artifactId>cloud-api-commons</artifactId>
                              <version>${project.version}</version>
                          </dependency>
                  
                      </dependencies>
                  
                  
                  </project>"
                - YML
                  "server:
                    port: 29880
                  
                  spring:
                    application:
                      name: Cloud-payment-service
                    zipkin:
                      base-url: http://192.168.2.3:9411
                    datasource:
                      type: com.alibaba.druid.pool.DruidDataSource
                      driver-class-name: com.mysql.cj.jdbc.Driver
                      url: jdbc:mysql://192.168.2.3:3306/springcloud20200413?serverTimezone=Hongkong&useUnicode=true&characterEncoding=utf8&useSSL=false
                      username: root
                      password: 123456
                    sleuth:
                      sampler: # 采样率
                        probability: 1
                  
                  eureka:
                    client:
                      register-with-eureka: true
                      fetch-registry: true
                      service-url:
                        defaultZone: http://192.168.2.13:27020/eureka/
                    instance:
                      instance-id: payment29880
                      prefer-ip-address: true
                  
                  mybatis:
                    mapper-locations: classpath:mapper/*.xml
                    type-aliases-package: com.atguigu.springcloud.entity
                  
                  management:
                    endpoints:
                      web:
                        exposure:
                          include: "*""
              - 构建模块 cloud-sleuth-consumer29080
        - spring cloud alibaba
          - 历史
            "最初 alibaba推出 dubbo 
            
            之后停更
            
            于是 spring cloud 利用 netflix 发展起来
            
            之后  Netflix 停更
            
            于是 alibaba 推出 新的微服务框架，加入 spring
            
            https://www.zhihu.com/question/50806354/answer/1099399169"
            - dubbo 高性能 和 RPC框架
              "目的：解决 RPC 问题 远程过程调用
              一个接口方法是一个服务"
            - springcloud 一系列通用工具构建分布式系统
              "一个Java应用是一个服务"
          - 功能 服务限流、降级、注册发现、消息驱动、云对象存储、分布式任务
            "文档 https://github.com/alibaba/spring-cloud-alibaba/wiki"
          - nacos 服务发现、配置中心、负载均衡
            - 服务注册
              - 基础
                - 官网 https://nacos.io/en-us/
                - 名字 naming config service
                - 即相当于 eureka + config + bus
                - 文档 https://nacos.io/zh-cn/docs/quick-start.html
                - 支持CP和AP切换
                  - CP consul coreDNS
                    "服务端主动探测客户端的健康状态
                    保留不健康实例
                    持久化"
                  - AP eureka/zookeeper
                    "客户端上报监控状态
                    移除不健康的实例
                    非持久化"
              - 简单使用
                - 安装
                  - 下载 https://github.com/alibaba/nacos/releases/tag/1.2.1
                  - 启动 /bin/startup.cmd
                  - 访问 http://192.168.2.13:8848/nacos
                    "账号密码 nacos"
                - 父POM文件
                  "<?xml version="1.0" encoding="UTF-8"?>
                  
                  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                    <modelVersion>4.0.0</modelVersion>
                  
                    <groupId>com.atguigu.springcloud.alibaba</groupId>
                    <artifactId>springcloudalibaba20200502</artifactId>
                    <packaging>pom</packaging>
                    <version>1.0-SNAPSHOT</version>
                    <modules>
                      <module>cloudalibaba-provider-payment19001</module>
                    </modules>
                  
                  
                    <properties>
                      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
                      <maven.compiler.source>1.8</maven.compiler.source>
                      <maven.compiler.target>1.8</maven.compiler.target>
                      <junit.version>4.12</junit.version>
                      <log4j.version>1.2.17</log4j.version>
                    </properties>
                  
                    <dependencyManagement>
                      <dependencies>
                        <dependency>
                          <groupId>org.apache.maven.plugins</groupId>
                          <artifactId>maven-project-info-reports-plugin</artifactId>
                          <version>3.0.0</version>
                        </dependency>
                        <!--spring boot 2.2.2-->
                        <dependency>
                          <groupId>org.springframework.boot</groupId>
                          <artifactId>spring-boot-dependencies</artifactId>
                          <version>2.2.2.RELEASE</version>
                          <type>pom</type>
                          <scope>import</scope>
                        </dependency>
                        <!--spring cloud Hoxton.SR1-->
                        <dependency>
                          <groupId>org.springframework.cloud</groupId>
                          <artifactId>spring-cloud-dependencies</artifactId>
                          <version>Hoxton.SR1</version>
                          <type>pom</type>
                          <scope>import</scope>
                        </dependency>
                        <!--spring cloud alibaba-->
                        <dependency>
                          <groupId>com.alibaba.cloud</groupId>
                          <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                          <version>2.1.0.RELEASE</version>
                          <type>pom</type>
                          <scope>import</scope>
                        </dependency>
                        <!--junit-->
                        <dependency>
                          <groupId>junit</groupId>
                          <artifactId>junit</artifactId>
                          <version>${junit.version}</version>
                        </dependency>
                        <!--log4j-->
                        <dependency>
                          <groupId>log4j</groupId>
                          <artifactId>log4j</artifactId>
                          <version>${log4j.version}</version>
                        </dependency>
                      </dependencies>
                  
                    </dependencyManagement>
                  
                    <build>
                      <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
                        <plugins>
                          <plugin>
                            <artifactId>maven-clean-plugin</artifactId>
                            <version>3.1.0</version>
                          </plugin>
                          <plugin>
                            <artifactId>maven-site-plugin</artifactId>
                            <version>3.7.1</version>
                          </plugin>
                          <plugin>
                            <artifactId>maven-project-info-reports-plugin</artifactId>
                            <version>3.0.0</version>
                          </plugin>
                        </plugins>
                      </pluginManagement>
                      <plugins>
                        <plugin>
                          <groupId>org.apache.maven.plugins</groupId>
                          <artifactId>maven-site-plugin</artifactId>
                          <configuration>
                            <locales>en,fr</locales>
                          </configuration>
                        </plugin>
                      </plugins>
                    </build>
                  
                  </project>"
                - 服务提供者19001 / 19002
                  - 新建模块 cloudalibaba-provider-payment19001
                  - POM
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>springcloudalibaba20200502</artifactId>
                            <groupId>com.atguigu.springcloud.alibaba</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>cloudalibaba-provider-payment19001</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>com.alibaba.cloud</groupId>
                                <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                        </dependencies>
                    
                    </project>"
                  - YML
                    "server:
                      port: 19001
                    
                    spring:
                      application:
                        name: nacos-provider
                      cloud:
                        nacos:
                          discovery:
                            server-addr: 192.168.2.13:8848
                    management:
                      endpoints:
                        web:
                          exposure:
                            include: '*'"
                  - 自动类
                    "@SpringBootApplication
                    @EnableDiscoveryClient
                    public class NacosProvider19001 {
                    
                        public static void main(String[] args) {
                            SpringApplication.run(NacosProvider19001.class, args);
                        }
                    
                    }"
                  - controller
                    "@RestController
                    @RequestMapping("/provider")
                    public class EchoController {
                    
                        @Value("${server.port}")
                        private String port;
                    
                        @GetMapping(value = "/echo/{string}")
                        public String echo(@PathVariable String string) {
                            return "Hello Nacos Provider " + string + " from " + port;
                        }
                    }"
                  - 再复制一个 cloudalibaba-provider-payment19002
                - 服务消费者cloudalibaba-consumer-order9091
                  - POM
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>springcloudalibaba20200502</artifactId>
                            <groupId>com.atguigu.springcloud.alibaba</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>cloudalibaba-consumer-order9091</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>com.alibaba.cloud</groupId>
                                <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                        </dependencies>
                    
                    </project>"
                  - YML
                    "server:
                      port: 9091
                    
                    spring:
                      application:
                        name: nacos-consumer
                      cloud:
                        nacos:
                          discovery:
                            server-addr: 192.168.2.13:8848
                    management:
                      endpoints:
                        web:
                          exposure:
                            include: '*'
                    
                    # 这样可以再外界修改服务名，而不是写死
                    service-url:
                      nacos-user-service: http://nacos-provider"
                  - 主启动
                    "@EnableDiscoveryClient
                    @SpringBootApplication
                    public class NacosConsumer9091 {
                        private final static Logger LOGGER = LoggerFactory.getLogger(NacosConsumer9091.class);
                    
                        public static void main(String[] args) {
                            SpringApplication.run(NacosConsumer9091.class,args);
                        }
                    }"
                  - restTemplate配置类
                    "@Configuration
                    public class RestTemplateConfig {
                        private final static Logger LOGGER = LoggerFactory.getLogger(RestTemplateConfig.class);
                    
                        @Bean
                        @LoadBalanced
                        public RestTemplate get() {
                            return new RestTemplate();
                        }
                    }"
                  - controller
                    "@RestController
                    public class OrderController {
                        private final static Logger LOGGER = LoggerFactory.getLogger(OrderController.class);
                    
                        @Resource
                        private RestTemplate restTemplate;
                    
                        @Value("${service-url.nacos-user-service}")
                        private String server_url;
                    
                        @GetMapping("/echo/{string}")
                        public Object echo(@PathVariable String string) {
                            String forObject = restTemplate.getForObject(server_url + "/provider/echo/" + string, String.class);
                    
                            return "来自服务提供者:" + forObject;
                        }
                    }"
            - 服务配置
              - 基础配置
                - 新建模块 config-nacos-client13377
                  - POM spring-cloud-starter-alibaba-nacos-config
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>springcloudalibaba20200502</artifactId>
                            <groupId>com.atguigu.springcloud.alibaba</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>config-nacos-client13377</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>com.alibaba.cloud</groupId>
                                <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.alibaba.cloud</groupId>
                                <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-devtools</artifactId>
                            </dependency>
                    
                        </dependencies>
                    
                    </project>"
                  - bootstrap.yml
                    "server:
                      port: 13377
                    
                    spring:
                      application:
                        name: config-nacos-client
                      cloud:
                        nacos:
                          discovery:
                            server-addr: 192.168.2.13:8848
                          config:
                            server-addr: 192.168.2.13:8848
                            file-extension: yaml"
                  - application.yml
                    "spring:
                      profiles:
                        active: dev # 表示去拉开发环境的配置"
                  - 主启动
                    "@EnableDiscoveryClient
                    @SpringBootApplication
                    public class NacosConfig13377 {
                        private final static Logger LOGGER = LoggerFactory.getLogger(NacosConfig13377.class);
                    
                        public static void main(String[] args) {
                            SpringApplication.run(NacosConfig13377.class, args);
                        }
                    }"
                  - controller
                    "@RestController
                    @RefreshScope // 支持动态刷新
                    public class ConfigController {
                        private final static Logger LOGGER = LoggerFactory.getLogger(ConfigController.class);
                    
                        @Value("${config.info}")
                        private String configInfo;
                    
                        @GetMapping("/config/info")
                        public Object info() {
                            return configInfo;
                        }
                    }"
                - /nacos 网站 新建配置 dataId config-nacos-client-dev.yaml
                  "config: 
                   info: 0.0.2"
                - 重点： dataId 格式 ${spring.application.name}-${profile}. ${file-extension:properties}
              - 三级分级配置
                - 痛点：多环境多项目管理
                - namespace+group+dataId
                  "命名空间：用于配置隔离"
                - namespace 的指定（在nacos可以创建不同的namespace）
                  "spring:
                    application:
                      name: config-nacos-client
                    cloud:
                      nacos:
                        discovery:
                          server-addr: 192.168.2.13:8848
                        config:
                          server-addr: 192.168.2.13:8848
                          file-extension: yaml
                          namespace: XXX"
                - group 的指定（在nacos可以在不同group建立相同文件）
                  "spring:
                    application:
                      name: config-nacos-client
                    cloud:
                      nacos:
                        discovery:
                          server-addr: 192.168.2.13:8848
                        config:
                          server-addr: 192.168.2.13:8848
                          file-extension: yaml
                          group: XXX"
              - 支持配置分文件 ext-config
                - 痛点：所有配置文件写一起，很臃肿，需要分开
                - bootstrap.yml
                  "spring:
                    application:
                      name: gulimall-coupon
                    profiles:
                      active: dev # 表示去拉开发环境的配置
                    cloud:
                      nacos:
                        config:
                          server-addr: 192.168.2.13:8848
                          file-extension: yaml
                          ext-config:
                            - data-id: common.yaml
                              namespace: public
                              group: DEFAULT_GROUP
                              refresh: true"
                - 在nacos 配置中心正常写配置就行了
              - 问题：配置中心和本地都配置了相同项，则配置中心优先
            - 集群
              - 目的：nacos服务器需要多个
              - 最小集群：nginx nacos*3 mysql
              - 简单实用Linux下
                - 下载 nacos-server-1.2.1.tar.gz
                  "https://github.com/alibaba/nacos/releases/tag/1.2.1?tdsourcetag=s_pctim_aiomsg"
            - 持久化（配置mysql）
              "没有mysql，则会持久化到内置数据库derby，每个节点独立，导致不一致"
              - 目的：nacos的一些数据持久化报错
          - sentinel 熔断限流（限流 or 异常降级）
            - 比hystrix优势 UI配置
            - 简单使用
              - 安装 sentinel-dashboard-1.7.2.jar
              - 启动 java -Dserver.port=28080 -Dcsp.sentinel.dashboard.server=localhost:28080  -jar sentinel-dashboard.jar
                "默认端口8080"
              - UI http://192.168.2.13:28080/
              - 在UI上配置
                - 新建模块 sentinel-service28401
                  - POM
                    "<?xml version="1.0" encoding="UTF-8"?>
                    <project xmlns="http://maven.apache.org/POM/4.0.0"
                             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                        <parent>
                            <artifactId>springcloudalibaba20200502</artifactId>
                            <groupId>com.atguigu.springcloud.alibaba</groupId>
                            <version>1.0-SNAPSHOT</version>
                        </parent>
                        <modelVersion>4.0.0</modelVersion>
                    
                        <artifactId>sentinel-service28401</artifactId>
                    
                        <dependencies>
                            <dependency>
                                <groupId>com.alibaba.cloud</groupId>
                                <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.alibaba.csp</groupId>
                                <artifactId>sentinel-datasource-nacos</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>com.alibaba.cloud</groupId>
                                <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.cloud</groupId>
                                <artifactId>spring-cloud-starter-openfeign</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-web</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-starter-actuator</artifactId>
                            </dependency>
                    
                            <dependency>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-devtools</artifactId>
                            </dependency>
                        </dependencies>
                    
                    
                    
                    </project>"
                  - YML
                    "server:
                      port: 28401
                    
                    spring:
                      application:
                        name: sentinel-service
                      cloud:
                        nacos:
                          discovery:
                            server-addr: 192.168.2.13:8848
                        sentinel:
                          transport:
                            dashboard: 192.168.2.13:28080
                            port: 8719
                    management:
                      endpoints:
                        web:
                          exposure:
                            include: '*'"
                  - 主启动
                    "@SpringBootApplication
                    @EnableDiscoveryClient
                    public class SentinelService28401 {
                        private final static Logger LOGGER = LoggerFactory.getLogger(SentinelService28401.class);
                    
                        public static void main(String[] args) {
                            SpringApplication.run(SentinelService28401.class, args);
                        }
                    }"
                  - controller
                    "@RestController
                    public class FlowLimitController {
                        private final static Logger LOGGER = LoggerFactory.getLogger(FlowLimitController.class);
                    
                        @GetMapping("/test1")
                        public Object test1() {
                            return "-------test1" + Math.random();
                        }
                    
                        @GetMapping("/test2")
                        public Object test2() {
                            return "-------test2" + Math.random();
                        }
                    
                        @GetMapping("/hotKey")
                        @SentinelResource(value = "hotKey", blockHandler = "deal_hotKey")
                        public String hotKeyTest(
                                @RequestParam(value = "p1", required = false) String p1,
                                @RequestParam(value = "p2", required = false) String p2
                                ) {
                            return "----hot key " + p1 + " " + p2;
                        }
                    
                        // 兜底方法
                        public String deal_hotKey(String p1, String p2, BlockException e) {
                            return "----deal hot key " + p1 + " " + p2 + " " + e;
                        }
                    }"
                - 流控（流量控制）
                  - 资源名：唯一。默认请求路径
                  - 来源：微服务名，默认default全部来源
                  - 阈值类型
                    - QPS 对每秒请求数限制
                    - 线程数 对最大线程数目限制
                  - 流控模式
                    - 直接 满足限流条件（QPS/线程数）就限制流量
                    - 关联 关联的资源达到阈值，限流自己
                      "被人惹事我买单
                      
                      关联一个资源（接口/api/url）"
                    - 链路
                  - 流控效果
                    - 快速失败
                      "默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。"
                    - warm up
                      "即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。"
                      - clodFactor 冷因子 3 表示初始OPS阈值是 最终阈值/3
                    - 排队等待
                      "（削峰）会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。"
                      - 最大排队时长
                - 降级
                  - 1. 平均响应时间
                  - 2. 异常比例
                  - 3. 一分钟内异常数
                  - 没有 hystrix 的半开状态，只有时间窗口。时间窗口过后，就恢复
                - 热点key限流
                  - 根据请求参数来限流
                  - 一句话：请求参数精准限流。统计请求参数（如 商品id），对top k的限流
                - 系统规则 对整个服务的控制
                  - LOAD    RT    线程数    入口 QPS    CPU 使用率
                    "LOAD CPU核数*2.5 仅限Linux
                    "
                - 优化
                  - 自定义兜底方法
                    "@SentinelResource(value = "资源名",blockHandlerClass = 兜底方法类,blockHandler = "兜底方法")"
                  - 全局统一兜底
                  - 兜底方法和业务方法分离
                    "@SentinelResource(value = "资源名",blockHandlerClass = 兜底方法类,blockHandler = "兜底方法")
                    @SentinelResource(value = 资源名,fallbackClass = 异常兜底方法类,fallback = 异常兜底方法)"
              - 利用 @SentinelResource 核心注解
                - value 资源名
                - blockHandlerClass blockHandler 限流时兜底类/方法
                - fallbackClass fallback 熔断时兜底类/方法
                - exceptionsToIgnore 异常忽略，不fallback
                - 简单使用
                  "@GetMapping("/echo/{string}")
                  @SentinelResource(
                          value = "echo",
                          blockHandler = "echo_blockHandler",
                          fallback = "echo_fallback"
                  )
                  public Object echo(@PathVariable String string) {
                      if("a".equals(string))
                          throw new RuntimeException("运行期异常");
                  
                      String forObject = restTemplate.getForObject(server_url + "/provider/echo/" + string, String.class);
                  
                      return "来自服务提供者:" + forObject;
                  }
                  
                  public Object echo_blockHandler(String s, BlockException e){
                      return s+" "+e + " from echo_blockHandler";
                  }
                  
                  public Object echo_fallback(String s,Throwable e){
                      return s+" "+e + " from echo_fallback";
                  }"
            - 和feign结合（不然就用restTemplate）
              - POM
                "<dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-starter-openfeign</artifactId>
                </dependency>"
              - YML 新增
                "feign:
                  sentinel:
                    enabled: true"
            - sentinel 配置持久化（默认不持久化）
              - 一句话：使用nacos持久化
              - POM
                "<dependency>
                    <groupId>com.alibaba.csp</groupId>
                    <artifactId>sentinel-datasource-nacos</artifactId>
                </dependency>"
              - YML
                "spring.cloud.sentinel.datasource.ds2.nacos.server-addr=localhost:8848
                spring.cloud.sentinel.datasource.ds2.nacos.data-id=sentinel
                spring.cloud.sentinel.datasource.ds2.nacos.group-id=DEFAULT_GROUP
                spring.cloud.sentinel.datasource.ds2.nacos.data-type=json
                spring.cloud.sentinel.datasource.ds2.nacos.rule-type=degrade"
          - seate 分布式事务
            - 术语
              - transaction id (XID) 全局事务ID
              - transaction coordinator TC 事务协调器 维护全局事务的运行状态，负责协调并驱动全局事务的提交/回滚
              - transaction manager  TM 事务管理器 控制全局事务边界，负责开启一个全局事务，并最终发起全局提交、全局回滚
              - resource manager  RM 资源管理器 控制分支事务、分支注册、状态汇报，接受事务协调器的指令，驱动分支事务的提交/回顾
            - 流程
              - 1. TM (微服务调用链里首个服务) 向 TC 申请开启全局事务。拿到XID
              - 2. XID 在微服务调用链中传播
              - 3. 每个微服务连的数据库，都是一个RM，RM 向 TC 注册分支事务
              - 4. 调用链结束，TM 向 TC 申请 XID 的提交/回滚
              - 5. TC 发起 XID 的提交/回顾
            - 工作原理
              - 每个单独SQL，都会单独commit
              - 出现异常后，全部执行逆向的SQL
            - 简单使用 略
              - 下载 http://seata.io/
              - 修改配置文件 两个
                - file.conf 不修改了
                  "transport {
                    # tcp udt unix-domain-socket
                    type = "TCP"
                    #NIO NATIVE
                    server = "NIO"
                    #enable heartbeat
                    heartbeat = true
                    # the client batch send request enable
                    enableClientBatchSendRequest = false
                    #thread factory for netty
                    threadFactory {
                      bossThreadPrefix = "NettyBoss"
                      workerThreadPrefix = "NettyServerNIOWorker"
                      serverExecutorThreadPrefix = "NettyServerBizHandler"
                      shareBossWorker = false
                      clientSelectorThreadPrefix = "NettyClientSelector"
                      clientSelectorThreadSize = 1
                      clientWorkerThreadPrefix = "NettyClientWorkerThread"
                      # netty boss thread size,will not be used for UDT
                      bossThreadSize = 1
                      #auto default pin or 8
                      workerThreadSize = "default"
                    }
                    shutdown {
                      # when destroy server, wait seconds
                      wait = 3
                    }
                    serialization = "seata"
                    compressor = "none"
                  }
                  
                  ## transaction log store, only used in server side
                  store {
                    ## store mode: file、db
                    mode = "file"
                    ## file store property
                    file {
                      ## store location dir
                      dir = "sessionStore"
                      # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions
                      maxBranchSessionSize = 16384
                      # globe session size , if exceeded throws exceptions
                      maxGlobalSessionSize = 512
                      # file buffer size , if exceeded allocate new buffer
                      fileWriteBufferCacheSize = 16384
                      # when recover batch read size
                      sessionReloadReadSize = 100
                      # async, sync
                      flushDiskMode = async
                    }
                  
                    ## database store property
                    db {
                      ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.
                      datasource = "druid"
                      ## mysql/oracle/postgresql/h2/oceanbase etc.
                      dbType = "mysql"
                      driverClassName = "com.mysql.cj.jdbc.Driver"
                      url = "jdbc:mysql://192.168.2.3:3306/seata?serverTimezone=Hongkong"
                      user = "root"
                      password = "123456"
                      minConn = 5
                      maxConn = 30
                      globalTable = "global_table"
                      branchTable = "branch_table"
                      lockTable = "lock_table"
                      queryLimit = 100
                    }
                  }
                  ## server configuration, only used in server side
                  server {
                    recovery {
                      #schedule committing retry period in milliseconds
                      committingRetryPeriod = 1000
                      #schedule asyn committing retry period in milliseconds
                      asynCommittingRetryPeriod = 1000
                      #schedule rollbacking retry period in milliseconds
                      rollbackingRetryPeriod = 1000
                      #schedule timeout retry period in milliseconds
                      timeoutRetryPeriod = 1000
                    }
                    undo {
                      logSaveDays = 7
                      #schedule delete expired undo_log in milliseconds
                      logDeletePeriod = 86400000
                    }
                    #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent
                    maxCommitRetryTimeout = "-1"
                    maxRollbackRetryTimeout = "-1"
                    rollbackRetryTimeoutUnlockEnable = false
                  }
                  
                  ## metrics configuration, only used in server side
                  metrics {
                    enabled = false
                    registryType = "compact"
                    # multi exporters use comma divided
                    exporterList = "prometheus"
                    exporterPrometheusPort = 9898
                  }"
                - registry.conf 注册到nacos
                  "registry {
                    # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
                    type = "nacos"
                  
                    nacos {
                      application = "seata-server"
                      serverAddr = "192.168.2.13:8848"
                      namespace = "public"
                      cluster = "default"
                      username = "nacos"
                      password = "nacos"
                    }"
              - 建立数据库 seata 用于存储事务过程
                "建表
                ------------
                CREATE TABLE `undo_log` (
                  `id` bigint(20) NOT NULL AUTO_INCREMENT,
                  `branch_id` bigint(20) NOT NULL,
                  `xid` varchar(100) NOT NULL,
                  `context` varchar(128) NOT NULL,
                  `rollback_info` longblob NOT NULL,
                  `log_status` int(11) NOT NULL,
                  `log_created` datetime NOT NULL,
                  `log_modified` datetime NOT NULL,
                  `ext` varchar(100) DEFAULT NULL,
                  PRIMARY KEY (`id`),
                  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
                ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
                
                DROP TABLE IF EXISTS `storage_tbl`;
                CREATE TABLE `storage_tbl` (
                  `id` int(11) NOT NULL AUTO_INCREMENT,
                  `commodity_code` varchar(255) DEFAULT NULL,
                  `count` int(11) DEFAULT 0,
                  PRIMARY KEY (`id`),
                  UNIQUE KEY (`commodity_code`)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
                
                
                DROP TABLE IF EXISTS `order_tbl`;
                CREATE TABLE `order_tbl` (
                  `id` int(11) NOT NULL AUTO_INCREMENT,
                  `user_id` varchar(255) DEFAULT NULL,
                  `commodity_code` varchar(255) DEFAULT NULL,
                  `count` int(11) DEFAULT 0,
                  `money` int(11) DEFAULT 0,
                  PRIMARY KEY (`id`)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
                
                
                DROP TABLE IF EXISTS `account_tbl`;
                CREATE TABLE `account_tbl` (
                  `id` int(11) NOT NULL AUTO_INCREMENT,
                  `user_id` varchar(255) DEFAULT NULL,
                  `money` int(11) DEFAULT 0,
                  PRIMARY KEY (`id`)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8;"
    - spring 5 核心原理与30个类手写实战 谭勇德
      - 设计模式——六大设计原则 Ankied
        - 哪6个？ SOLLID
          "SOLID
          S 单一职责
          O 开闭
          L 里氏 迪米特
          I 接口隔离
          D 依赖倒转"
        - 单一职责 ankied
        - 里氏替换 ankied
        - 依赖倒转
          - 高层模块和底层模块都应该依赖抽象
          - 目的：减少类间依赖(解耦)，有利于团队开发
        - 接口隔离
          - 接口细化，即接口方法即可能少
          - 举例：Animal接口拆为Eatable Movable
        - 迪米特
          - 一个对象应对其他对象有最少的了解
        - 开闭
          - 对扩展开放，对修改关闭
      - spring 中常用的设计模式
        - 简单工厂 & 工厂模式 区别
          "简单工厂：产品的生产在工厂内进行
          工厂模式：工厂本身是接口，产品生产由实现工厂进行"
        - 工厂模式 & 抽象工厂模式 区别
          "抽象工厂模式：工厂生产一类产品（产品族）"
        - 单例模式
          - 饿汉——类加载即初始化
          - 懒汉——懒初始化
          - 不双重检查锁，实现懒汉？——静态内部类
        - Java 原型设计模式 —— 即 Cloneable Ankied
    - springboot starter 开发
      - springboot 加载 bean 的四种方式
        "前三种方式，默认只能加载主启动类包下的 bean
        当然在主启动类 @SpringBootApplication 中写 scanBasePackages，也可以加载指定包中的类
        （原理：@SpringBootApplication  是个复合注解，包括 @ComponentScan）"
        - xml + @InportResource 
        - @Component  等注解
        - 配置类 @Configuration  + @Bean 
        - @Inport + Selector接口
          "要使用这个方法，首先写配置类
          然后写一个 Selector 类实现 ImportSelector 接口
          最后在主启动类上加上注解 @Import(AutoImportSelector.class)
          
          ---------------
          public class UserAutoConfiguration {
              private final static Logger LOGGER = LoggerFactory.getLogger(UserAutoConfiguration.class);
          
              @Bean
              public User user() {
                  LOGGER.info("UserAutoConfiguration 注入 User bean");
                  User user = new User();
                  user.setName("madokast");
                  return user;
              }
          
              public static class User {
                  private String name;
          
                  public String getName() {
                      return name;
                  }
          
                  public void setName(String name) {
                      this.name = name;
                  }
          
                  @Override
                  public String toString() {
                      return "User{" +
                              "name='" + name + '\'' +
                              '}';
                  }
              }
          }
          
          ------------------------
          
          ------------------------
          public class AutoImportSelector implements ImportSelector {
              private final static Logger LOGGER = LoggerFactory.getLogger(AutoImportSelector.class);
          
              @Override
              public String[] selectImports(AnnotationMetadata annotationMetadata) {
                  LOGGER.info("AutoImportSelector 加载 UserAutoConfiguration");
                  return new String[]{"com.github.madokast.learn.outer.config.UserAutoConfiguration"};
              }
              
          }
          --------------------------"
      - 最简单的 starter 开发
        - 创建 maven 空项目 first-spring-boot-autoconfiguration
          - 导入三个依赖
            "spring-boot-starter
            spring-boot-autoconfigure // 这两个必选，用来引入需要的注解
            spring-boot-configuration-processor // 这个可选，使用后会自动提取出配置信息 spring-configuration-metadata.json ，让 ide 中书写 application.properties 时有自动提示
            
            完整的pom文件
            ------------------------
            <?xml version="1.0" encoding="UTF-8"?>
            <project xmlns="http://maven.apache.org/POM/4.0.0"
                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                <modelVersion>4.0.0</modelVersion>
            
                <groupId>com.github.madokast</groupId>
                <artifactId>first-spring-boot-autoconfiguration</artifactId>
                <version>0.0.1</version>
                <packaging>jar</packaging>
            
                <properties>
                    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
                </properties>
            
                <dependencies>
                    <!--        只导入基础依赖-->
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter</artifactId>
                        <version>2.2.6.RELEASE</version>
                    </dependency>
            
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-autoconfigure</artifactId>
                        <version>2.2.6.RELEASE</version>
                    </dependency>
            
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-configuration-processor</artifactId>
                        <version>2.2.6.RELEASE</version>
                        <scope>compile</scope>
                        <optional>true</optional>
                    </dependency>
            
                </dependencies>
            
            </project>"
          - 创建一个我需要注入的 bean 类
            "public class MonggoDbConnection {
            	private String ip;
            	private Integer port;
            	// getter setter
            }"
          - 创建一个配置信息类
            "@ConfigurationProperties(prefix = "spring.ik.monggo")
            public class MonggoDbConnectionProperties {
                private String ip = "127.0.0.1";
                private Integer port = 7893;
                // getter setter
            }"
          - 创建一个配置类
            "写法和 @Configuration + @Bean 一模一样
            注意 @EnableConfigurationProperties 注解指定 配置信息类
            -------------------
            @Configuration
            @EnableConfigurationProperties(MonggoDbConnectionProperties.class)
            public class MonggoDbConnectionAutoConfiguration {
                @Bean
                public MonggoDbConnection monggoDbConnection(MonggoDbConnectionProperties properties) {
                    String ip = properties.getIp();
                    Integer port = properties.getPort();
                    MonggoDbConnection monggoDbConnection = new MonggoDbConnection();
                    monggoDbConnection.setIp(ip);
                    monggoDbConnection.setPort(port);
                    return monggoDbConnection;
                }
            }"
          - 在资源中创建 META-INF/spring.factories 文件
            "key 是固定的，value 即配置类全类名
            
            org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.github.madokast.MonggoDbConnectionAutoConfiguration"
        - 创建 maven 空项目 first-spring-boot-starter
          - POM 中导入 first-spring-boot-autoconfiguration
            "完整POM文件
            
            ----------------
            <?xml version="1.0" encoding="UTF-8"?>
            <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
                <modelVersion>4.0.0</modelVersion>
            
                <groupId>com.github.madokast</groupId>
                <artifactId>first-spring-boot-starter</artifactId>
                <version>0.0.1</version>
                <name>first-spring-boot-starter</name>
                <description>第一个springboot starter</description>
            
                <dependencies>
                    <dependency>
                        <!--            starter 工程仅仅是依赖 auto configuration 工程 聚合 jar 包-->
                        <groupId>com.github.madokast</groupId>
                        <artifactId>first-spring-boot-autoconfiguration</artifactId>
                        <version>0.0.1</version>
                    </dependency>
            
                </dependencies>
            
            </project>"
        - 两个项目 maven install 后即可发布到本地仓库，其他项目就可以使用了
  - 日志
    - Log4j  最早
      "1996年提出，逐步完善，想并入 Java 标准库中，但是被 sum 拒绝"
    - JUL  Java标准库中的日志
      "随 Java1.4 发布（java.util.logging），但是此时 Log4j 已经称为 Java 日志事实标准"
    - JCL 接口  Apache提出
      "JCL 只是一个接口（org.apache.commons.logging.Log），底层可以是 Log4j 或 JUL"
    - SLF4J 接口 & Logback
      "Log4j 的作者离开 Apache 后，设计了 SLF4J 接口及其实现 Logback"
    - 总结：两大接口 Apache common log 和 SLF4J
      "一般具体的日志实现类，都存在对应到两个接口的适配器"
    - SLF4J + logback配置
      - POM
        "<!--        slf4j日志-->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.25</version>
        </dependency>
        
        <!-- 添加logback-classic依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
        </dependency>
        <!-- 添加logback-core依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-core</artifactId>
            <version>1.2.3</version>
        </dependency>"
      - logback.xml
        "<?xml version="1.0" encoding="UTF-8"?>
        <configuration debug="true">
        
            <!-- 控制台输出 -->
            <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
                <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
                    <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
                    <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
                </encoder>
            </appender>
        
        
            <!-- 日志输出级别 -->
            <root level="TRACE">
                <appender-ref ref="STDOUT" />
            </root>
        </configuration>"
- 数据库
  - MySQL
    - MySQL 初级
      - 概念
        - 为什么使用？ 1 持久化 2 专门管理
        - 相关概念 DB DBMS SQL
          "DB 数据库，一系列文件
          DBMS 数据库管理系统 
          SQL 结构化查询语言
          
          DBMS分类
          	贡献文件系统的 access
          	基于 C/S 架构的"
        - 默认数据库
          "information_schema 元数据信息
          mysql 用户信息
          performance_schema 性能星系
          test 测试用数据库"
        - 引号问题
          "字符串使用 单引号或双引号
          表名 列名 使用反引号"
      - 查询
        - 单表查询
          - 基本查询 
            "select 列名,.. from 表名"
            - select 'a'+'b';
              "输出 0"
            - select concat("a","b");
              "ab"
          - 条件查询 where
            - 大于小于等于
              "<> 不等于
              
              = null 不可以 ，只能用 is null"
            - 逻辑 and or not
            - like
              "like "%a%"  包含a
              
              \_
              \%
              
              默认转移字符
              
              where name like '$_' escape '$'
              跟换转移字符，查询 _ 开头的name"
              - 题目a like "%%"
                "可以查出  a 为 null 的吗？
                不可以"
            - between and
            - in
              "where name in ('Java','basic')
              
              使用小括号"
            - is null // is not null
            - 高级等于 <=> @Deprecated 
              "可以使用 <=> null"
          - 排序 order by .. asc/desc
            "order by a adc, b desc"
          - 分组查询 group by
          - 分组后筛选 having
            "having 作用于 分组后的表"
          - 起别名 (AS) "alias"
          - 去重 distinct
            "注意位置 select distinct 列名"
        - 多表查询
          - 内连接 inner join
            - 等值连接
              "from t1,t2
              where t1.id=t2.fid"
            - 非等值连接
              "from t1,t2
              where t1.a?t2.b"
            - 自连接
              "from t t1,t t2"
          - 外连接
            "用途：查询表a有但是表b没有的记录
            
            分为 主表 从表，主表中有，但是从表中没有的，用null填充"
            - 左外连接（左表是主表
              "from t1 left join t2 on 连接条件 where 其他条件"
            - 右外连接（右表是主表
            - 全外连接 mysql不支持
          - 交叉连接（就是笛卡尔积） cross join
        - 子查询 2020年5月15日
          - 单行子查询
          - 多行子查询 in any all
            "in 就是 =any
            
            any all 最好改成 max min的单行查询，可读性高"
          - 关联子查询 ⭐
            "一句话：子查询不能单独执行，子查询中包含外部的表
            
            格式
            	select * from a where a.x>(select y from b where a.x=by)
            子查询中用到的表，在子查询的from语句中不存在
            
            
            select * from entries as e1 where e1.lengthMinute > (
            	select avg(e2.lengthMinute)
                from entries as e2
                where e1.name = e2.name
            );  
            
            举例子：以分类聚合作为条件
            例如：
            	查成绩大于本班平均值的学生（有多个班）
            	查时长大于本分组下均值的项目
            "
          - where/having子查询
            "单行
            列名 ? (select..)
            
            多行子查询
            列名 in (select...)
            "
          - select子查询 奇怪的东西
          - from 子查询 需要起别名
          - exists 子查询 相关子查询
            "exists(子查询语句)
            返回值只用两个 1/0
            1 表示子查询结果不为空
            0 表示子查询结果为空
            
            使用较少
            
            举例：查 有员工的部门的名字
            
            "
        - 分页查询 limit offset, size
          "offset 从0开始
          
          size 条目数
          "
        - 联合查询 union 自动去重
          "多个查询结果合并
          
          select ...
          union
          select ...
          
          union all 不去重"
        - 常见问题
          - 细节问题
            - from中给表取别名后，还能用以前的名字吗？
              "不可以"
            - having 后可以用子查询吗？
              "可以"
      - DML 数据操作语言
        - 增 insert into t(r1..) values(v1...)
          "另一种语法 insert into t set r1=v1,...
          
          插入子查询 insert into t select ..."
        - 改 update t set r=v where
        - 删 delete from t where
          "truncate table 表"
          - drop truncate delete 区别
            "delete 一条条删除，可以回滚，不释放空间
            truncate 删全部，只留下表结构，会释放空间，不能回滚
            drop 表结构也删了，没有日志，释放空间
            
            delete删除后，不影响自增
            truncate 删除，自增回到1"
      - DDL 数据定义语言
        - 库管理
        - 表管理 create table t();
          "() 中 列名 类型"
        - create
        - alter
        - drop
        - 复制表 create table a like b （只复制结构）
        - 复制表+数据 create table a select * from b
      - 数据类型 //ANKI
        - 整数
          - 五种
            "Tinyint // byte 1字节
            Smallint // short 2字节
            Mediumint // 3字节
            Int integer // int 4字节
            Bigint // long 8字节"
          - 有符号 & 无符号 // 默认有符号
            "INT UNSIGNED"
          - INT(7) // 这里7不是说7位数而是显示7位，需要配合 ZEROFILL 
            "数值范围不变，只是显示"
        - 定点小数
          - DEC(M,D)
          - DECIMAL(M,D)
        - 浮点数
          - FLOAT(M,D)
          - DOUBLE(M,D)
          - D 小数点后保留位数，多则四舍五入。不影响存储空间
          - M 总位数(整数部分位数+小数部分位数)
          - 例子
            - DOUBLE(4,2) 插入0.128 -> 0.13
            - DOUBLE(4,2) 插入10000 -> 报错 or 99.99
        - 字符串
          - char(m)
          - varchar(m)
          - m 最长字符数，注意是字符，不是字节
            "一个汉字是一个字符"
          - text
        - 二级制
          - binary
          - varbinary
          - blob
        - 枚举 ENUM('a','b','c') SET(集合)
        - 日期
          - DATE
          - TIME
          - DATETIME
            "1000年 - 9999年"
          - TIMESTAMP // 受时区影响
            "1970年 - 2038年"
      - 约束
        - NOT NULL
        - DEFAULT
        - PRIMARY KEY // 唯一 非空
        - UNIQUE // 可空
        - CHECH // MySQL 无效
        - FOREIGN KEY
        - [非约束] AUTO_INCREMENT
          - 一个表只能一个 不一定是主键
      - 函数
        - 单行函数
          - 字符函数
            - concat(a,b)
              "字符串拼接"
            - length(a)
            - upper(a) / lower(a)
            - substr substring
            - instr('abcd','bc') 起始索引
              "2"
            - lpad rpad 左右填充
          - 日期函数
            - now()
            - curdate() //当前日期
            - curtime()
            - year(日期)
            - str_to_date(str,format)
            - date_format
          - ISNULL(e1,e2)
            "若e1为null，输出e2"
        - 聚合函数
          - sum 忽略null
          - avg 忽略null
          - max 忽略null
          - min 忽略null
          - count 忽略null
          - 带上去重 fun(distinct 字段)
          - count(1) count(2) 等效于 count(*)
      - 事务
        - 简单使用
          - 首先要禁用自动提交事务
            "set autocommit=0"
          - 开始事务
            "start transaction"
          - 提交事务
            "commit;"
          - 回滚
            "rollback;"
        - 事务隔离
          - 并发问题 3种
            - 脏读 // 读到未提交的
            - 不可重复读
            - 幻读 // 前后读一个表，行数不同
          - 隔离级别 4种
            - 读未提交
            - 读已提交
            - 可重复读
            - 串行化
      - 其他
        - 上课用表
          - employees 员工表
            "employee_id
            job_id
            department_id
            manager_id  //上级id
            name
            phone
            email
            hiredate"
          - departments 部门表
            "department_id
            name
            manager_id  //领导id
            location_id //位置"
          - locations 位置表
            "location_id
            address
            postcode
            city
            state_province
            country_id"
          - jobs 工种表
            "job_id
            title
            min_salary
            max_salary"
        - 刷题
          "https://www.jianshu.com/p/476b52ee4f1b"
    - MySQL 高级
      - 架构介绍
        - 连接池
        - 服务层
          - 管理服务
          - 连接池
          - SQL 接口
          - 分析器
          - 优化器
          - 缓存
        - 引擎层
          - 可拔插存储引擎
            - innoDB
              "内存、磁盘占用大"
            - MyISAM
              "不支持外键、事务、行锁（表锁）。性能高"
        - 存储层
          - 文件系统 日志
      - sql 执行顺序
        - 手写 slect * from * where * group by * having * order by * limit *
        - 机读 from * where * group by * having * select * order by * limit *
        - 七种 JOIN
      - 索引 ANKIED
        - 简介 ankied
          - 语法
            "create index 名字 on 表(字段,..)
            drop undex name on tab
            show index from tab"
          - 什么是索引？--一种数据结构，便于快速定位表数据
          - 索引影响什么？ 索引影响 where 和 order by
          - B+树 & hash —— 索引两种数据结构
            - B+树（多路搜素树）
          - 优势——高效搜索，提前排序
          - 劣势——占空间、降低更新效率
            "一个表最多建五个索引"
          - 分类
            - 主键索引——就是唯一索引+不可空
            - 单值索引——只包含单个列
            - 唯一索引——索引列值必须唯一、可空
              "create unique index name on tab(col)"
            - 复合索引
          - 结构
            - BTree ⭐ 多路查找树
              "每个节点有多个子树，每个节点占据一整个磁盘块
              
              节点：
              	17	35
              p1        p2        p3
              
              p1指向的节点，都小于17
              p2指向的节点， 17-35
              p3指向的节点，都大于35
              
              树高度一般为3层，可以引上百万数据
              "
            - Hash
            - 全文索引
            - RTree
        - 何时建立索引？ ankied
          - 自动建立索引
            - 主键
          - 需要建立索引
            - 外键
            - 需要查询的字段
            - 需要排序的字段
            - 需要分组的字段
          - 不需要建立
            - 频繁更新的字段
            - 不在where查询条件的字段
            - 表记录太少（记录<100w）
            - 重复值多的字段(国籍、性别)
        - Explain 查看执行计划 ankied
          - 干嘛的？查看 SQL 的执行计划
          - 用法？ explain + sq语句
          - 来自什么？sql查询优化器
          - 目的
            - 表读取顺序
            - 读取数据的操作类型（数据是怎么读取的）
            - 哪些索引可以使用
            - 实际使用的索引
            - 表之间的引用
            - 每张表有多少行被优化器查询
          - 输出结果字段
            - id 查询序列号 表的读取加载顺序
              - id相同 表示执行顺序从上至下
                "如 sql = from t1,t2
                但是 explain 输出
                id  table
                1    t2
                1    t1
                
                表示先读取 t1 再是 t2"
              - id不同 值最大的先执行，如子查询
                "exlain from t1 where id = (select from t2)
                输出
                id  table
                1    t1
                2   t2
                
                id=2先执行，设计t2"
            - select_type 数据读取的操作类型 六种
              - simple 简单查询。即没有子查询、union
              - primary 主查询。如果不是简单查询，则最外层的查询称为 primary
              - subquery select或where中的子查询
                "where id = (select..)
                where 中的子查询"
              - derived 衍生 from中的子查询
                "from (select.. ) as t1
                from 查询中的子查询"
              - union 代表union之后的查询
                "(select..) union (select..)
                前一个 select 是 primary
                后一个是 union
                把结果合起来是 union result"
              - union result 获取union结果，也就是union查询最后一步
                "即 结果集A union 结果集B
                查询类型即 union result"
            - table 数据关于哪张表
              - 真实表名
              - <derivedn>  从id=n序列得到的衍生表
            - type 访问类型 八种 下面按照最优到最差排序
              - system 系统表。表中只有一行记录，const的特例。
              - const 对主键唯一索引的字段进行等值、常量查询
                "where id = 1
                id 有主键索引（即唯一索引）
                = 等值查询
                1 写死的常量"
              - eq_ref 对主键唯一索引的字段进行等值、非常量查询
                "where t1.id = t2.id
                t1.id  t2.id 有主键索引（唯一索引）
                = 等值查询
                不是写死的常量"
              - ref 对非唯一索引的字段进行等值查询
                "where name = 'aaa'
                name 不唯一，但是有索引"
              - fulltext / ref_or_null / index_merge / unique_subquery 略
              - range 对索引字段进行范围/集合查询(between > < in like)
                "where id<3"
              - index 全索引扫描
                "select id"
              - all 全表扫描
                "select *"
            - possible_keys 可能用到的索引
            - key 实际用到的索引
              - null 没有用到索引
              - primary 主键索引
              - 覆盖索引 若出现了覆盖索引，则仅出现在 key 中
                "select a from t1;
                没有where
                a上有普通索引
                则这是 覆盖索引 
                那么 possible_keys = null
                key = index_a
                
                这种查询，可以不查表，查索引够了"
            - key_len 索引字段的最大可能长度，并非实际长度，根据表定义的来，而不是表中数据
              "不损失精确性的情况下，越短越好
              
              复合索引(c1,c2)，只差c1时，len小，查c1,c2时，len长"
            - ref 表示查询索引时，值来自哪里
              "where t1.id= t2.id
              则 关于 t1 表的查询，用到了主键索引，值来自 t2.id"
              - const 表示值来自常量
                "where id = 1"
              - db1.t2.c2 表示值来自db1库的t1表的c1字段
                "where t1.c1 = t2.c2"
            - rows 大致需要读取的行数
            - extra 其他信息
              - using filesort 需要额外的排序，而不是索引的顺序（不好）
                "where c1>5 order by c2
                索引是(c1,c2)
                
                虽然c2有索引，但是在c1之后，所以对c2排序不能借助索引"
              - using temporary 使用了临时表保存中间结果（很差）
                "常见于 排序/分组
                
                where c1>5 group by c2
                索引：(c1,c2)"
              - using index 数据来自索引，不用查表了（索引覆盖）
                "select * 一定不会出现覆盖索引"
              - using where 表示where查询没有用到索引
              - using join buffer 使用了join缓冲区
              - impossible where 表示where条件总是false，无法查到结果
                "where id=1 and id=2"
              - distinct 对distinct优化，找到一个后就停止扫描，而不是扫描全部再去重
        - 性能分析 索引分析 ankied
          - MySQL query optimizer ankied
            "MySQL自带的查询优化器"
            - 根据系统统计信息，自动选择最优的查询计划（不一定实际上最优）
          - 具体情况
            - 单表
              - 建表
                "CREATE TABLE IF NOT EXISTS `article`(
                `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
                `author_id` INT(10) UNSIGNED NOT NULL,
                `category_id` INT(10) UNSIGNED NOT NULL,
                `views` INT(10) UNSIGNED NOT NULL,
                `comments` INT(10) UNSIGNED NOT NULL,
                `title` VARBINARY(255) NOT NULL,
                `content` TEXT NOT NULL
                );
                
                INSERT INTO `article`(`author_id`,`category_id`,`views`,`comments`,`title`,`content`) VALUES
                (1,1,1,1,'1','1'),
                (2,2,2,2,'2','2'),
                (1,1,3,3,'3','3');
                
                select * from article;
                ————————————————
                版权声明：本文为CSDN博主「@zzy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
                原文链接：https://blog.csdn.net/qq_42826747/article/details/106674270"
              - where c1=1 and c2>1 order by c3 desc limit 1;
                - 索引 t(c1,c2,c3)  × 
                  "复合索引中断问题 导致using file sort"
                - 索引 t(c1,c3) √ 
              - 小知识：查询工资最多的人
                "order by 工资 desc limit 1"
              - 小知识 limit n,m // n 是什么？ —— 偏移量
              - 小知识 limit n,m 不偏移则n=？ —— 0
              - 小知识 limit n,m // m 是什么？ —— 记录数目
              - 小知识 limit n // 只有n？—— 获取n条记录
              - 复合索引中断问题
                "索引(c1,c2)，但是对c1进行range查询，会导致c2失效"
            - 两表
              - 建表 class book
                "CREATE TABLE IF NOT EXISTS `class`(
                `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
                `card` INT(10) UNSIGNED NOT NULL,
                PRIMARY KEY(`id`)
                );
                
                CREATE TABLE IF NOT EXISTS `book`(
                `bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
                `card` INT(10) UNSIGNED NOT NULL,
                PRIMARY KEY(`bookid`)
                );
                ————————————————
                版权声明：本文为CSDN博主「@zzy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
                原文链接：https://blog.csdn.net/qq_42826747/article/details/106674270"
              - from t1 left join t2 on t1.c=t2.c
                - 索引 t2(c) √ 索引建在对表上（即左连接，索引加右表。废话）
              - join —— 小表驱动大表
                "即小表先全部加载 ALL，然后大表采用索引 ref"
            - 三表
              - from t1 left join t2 on t1.c=t2.c left join t3 on t1.c=t3.c
                - 索引 t2(c) 和 t3(c)
          - 索引失效的情况
            - 全值匹配我最爱
            - 左前缀法则
              "索引(c1,...) 只要不用c1，索引一定失效"
            - 中间兄弟不能断
              "索引(c1,c2,c3) 查询(c1,c3) 这是只c1部分生效"
            - 不对索引列操作（计算、函数、转型），否则失效
              "如 left(name,4)='july' （name取左边四位）"
              - 字符串不加单引号——失效
                "隐式类型转换"
            - 范围查询，之后的列——失效
              "索引(c1,c2) 查c1>1 and c2.. —— c2失效"
            - 尽可能索引覆盖——少用 select *
            - 使用不等于——失效
            - is null/not null——失效
            - like+通配符开头——失效
              "like '%..'"
              - 如果一定要%开头怎么办？——至少优化到 index 索引覆盖
              - 非通配符开头——不会失效
            - 使用or——失效
          - 索引都有主键
            "id 主键，建立索引 name
            select id where name='a'
            是可以索引覆盖的"
        - 慢查询日志
          - 介绍：MySQL自带。可以记录响应时间慢的sql语句。默认时长10s
          - 使用：需要手动开启，默认不打开，打开会影响MySQL性能
          - show variables like '%slow_query_log%'; // 查看是否开启
          - show variables like '%long_query_time%'; // 查看时长
        - 索引优化 ankied
          - 小表驱动大表 ankied
            - ⭐ in 改成 exitst
              "from a where aid in (select bid form b)
              --->>
              from a where exists (select 1 from b where aid=bid )"
            - from a where aid in (select bid form b) -> b 为小表好
            - from a where exists (select 1 from b where aid=bid ) -> a 为小表好
            - 回顾 exist(subquery) -> 何时true 何时false？
              "子查询结果为空 false"
          - 排序优化 去除 using filesort ankied
            - 索引是有顺序的 c1 asc/desc
              - 索引 c 排序 c asc/desc 都可以用到索引
              - 索引 c1,c2 排序 c1降 c2 升 无法用到索引
            - ⭐ MySQL排序
              - 排序所用的缓冲区设置 sort_buffer
              - 双路排序
                - 算法
                  "第一步：取行指针+需要排序的字段值，进行排序
                  第二步：根据行指针，把其他的数据补上"
                - 优点：占用内存小
                - 缺点：需要两次磁盘IO
              - 单路排序
                - 算法：把全部要用的数据取出来，然后排序
                  "数据 = select 数据 + order by 数据"
                - 优点：一次磁盘IO
                - 缺点：1.占用内存大 2.超过sort_buffer 后，性能骤降，因为会出现外排序
          - 分组优化 group by ankied
            - 情况和 order by 几乎相同
          - 例题 ankied
            - 索引(c1,c2) 查询order by c2
              "索引失效，因为c2的顺序是在c1之下的"
            - 索引(c1,c2) 查询group by (c2,c1)
              "索引失效，而且需要外排序，临时表"
              - 法则：分组暗含排序
            - 组合索引顺序原则？——1. 区分度 2.查询需求（先等值后范围）
        - sql分析 show profile
          - 是什么？分析当前会话中，sq语句执行情况
            "分析一次sql，每一步执行状况（耗时、IO....）"
          - show variables like 'profiling';
          - set profiling=on;
          - show profiles; // 查看最近15条sql耗时
            "# Query_ID, Duration, Query
            '1', '0.00045000', 'SHOW WARNINGS'
            '2', '0.00124025', 'show variables like \'profiling\''
            '3', '0.00019675', 'select * form emp group by id%10'
            '4', '0.00033225', 'select * from emp group by id%10\nLIMIT 0, 1000'
            '5', '0.00026250', 'select * from emp group by id%10 limit 150000'
            '6', '0.00123825', 'show variables like \'sql_mode\''
            '7', '0.00022875', 'select *,id%10 from emp group by id%10 limit 150000'
            '8', '0.00029775', 'select *,id%10 as iid from emp group by iid limit 150000'
            '9', '0.14698925', 'select id%10 as iid from emp group by iid limit 150000'
            '10', '0.00014275', 'select id%10 as iid, * from emp group by iid limit 150000'
            '11', '0.00016600', 'select id%10 as iid  * from emp group by iid limit 150000'
            '12', '0.00023650', 'select id%10 as iid,id from emp group by iid limit 150000'
            '13', '0.13568925', 'select id%10 as iid,count(*) from emp group by iid limit 150000'
            '14', '0.16161275', 'select * from emp where ename like \'%aaa%\'\nLIMIT 0, 1000'
            "
          - show profile cpu,block io for query 14;
            "# Status, Duration, CPU_user, CPU_system, Block_ops_in, Block_ops_out
            'starting', '0.000057', '0.000052', '0.000000', '0', '0'
            'checking permissions', '0.000007', '0.000006', '0.000000', '0', '0'
            'Opening tables', '0.000013', '0.000013', '0.000000', '0', '0'
            'init', '0.000023', '0.000022', '0.000000', '0', '0'
            'System lock', '0.000007', '0.000007', '0.000000', '0', '0'
            'optimizing', '0.000007', '0.000007', '0.000000', '0', '0'
            'statistics', '0.000012', '0.000012', '0.000000', '0', '0'
            'preparing', '0.000009', '0.000009', '0.000000', '0', '0'
            'executing', '0.000004', '0.000004', '0.000000', '0', '0'
            'Sending data', '0.155535', '0.155600', '0.000000', '0', '0'
            'end', '0.000016', '0.000009', '0.000000', '0', '0'
            'query end', '0.000008', '0.000008', '0.000000', '0', '0'
            'closing tables', '0.000008', '0.000008', '0.000000', '0', '0'
            'freeing items', '0.000129', '0.000131', '0.000000', '0', '0'
            'cleaning up', '0.000018', '0.000015', '0.000000', '0', '0'
            。。。"
          - 危险步骤
            - converting heap to myisam 
            - creating tmp table // 创建临时表
            - copying to tmp table // 复制到临时表
            - copying to tmp table to disk
            - locked
        - 全局查询日志
          - 全局变量 global_log
          - 启动后左右的sql都会记录到 system.general_sql 这个表中
        - 插入1000W数据
          "create database bigData;
          use bigData;
          
          CREATE TABLE `dept` (
            `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
            `deptno` mediumint(8) unsigned NOT NULL DEFAULT '0',
            `dname` varchar(20) NOT NULL DEFAULT '',
            `loc` varchar(13) NOT NULL DEFAULT '',
            PRIMARY KEY (`id`)
          ) ENGINE=InnoDB DEFAULT CHARSET=GBK;
          
          CREATE TABLE `emp` (
            `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
            `empno` mediumint(8) unsigned NOT NULL DEFAULT '0',/*编号*/
            `ename` varchar(20) NOT NULL DEFAULT '',/*名字*/
            `job` varchar(9) NOT NULL DEFAULT '',/*工作*/
            `mgr` mediumint(8) unsigned NOT NULL DEFAULT '0',/*上级编号*/
            `hiredate` date NOT NULL,/*入职时间*/
            `sal` decimal(7,2) NOT NULL,/*薪水*/
            `comm` decimal(7,2) NOT NULL,/*红利*/
            `deptno` mediumint(8) unsigned NOT NULL DEFAULT '0',/*部门编号*/
            PRIMARY KEY (`id`)
          ) ENGINE=InnoDB DEFAULT CHARSET=GBK;
          
          
          DELIMITER $$
          CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)
          BEGIN
          	DECLARE char_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
          	DECLARE return_str VARCHAR(255) DEFAULT '';
          	DECLARE i INT DEFAULT 0;
          	WHILE i < n DO
          	SET return_str = CONCAT(return_str,SUBSTRING(char_str,FLOOR(1+RAND()*52),1));
          	SET i = i+1;
          	END WHILE;
          	RETURN return_str;
          END $$
          
          
          DELIMITER $$
          CREATE FUNCTION rand_num() RETURNS INT(5)
          BEGIN
          	DECLARE i INT DEFAULT 0;
          	SET i = FLOOR(100+RAND()*10);
          	RETURN i;
          END $$
          
          
          DELIMITER $$
          CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))
          BEGIN
          	DECLARE i INT DEFAULT 0;
          	SET autocommit = 0;#把自动提交关闭
          	REPEAT
          	SET i = i + 1;
          	INSERT INTO emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES((START+i),rand_string(6),'SALESMAN',0001,CURDATE(),2000,400,rand_num());
          	UNTIL i = max_num
          	END REPEAT;
          	COMMIT;
          END $$
          
          
          DELIMITER $$
          CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))
          BEGIN
          	DECLARE i INT DEFAULT 0;
          	SET autocommit = 0;
          	REPEAT
          	SET i = i + 1;
          	INSERT INTO dept (deptno,dname,loc) VALUES((START+i),rand_string(10), rand_string(8));
          	UNTIL i = max_num
          	END REPEAT;
          	COMMIT;
          END $$
          
          call insert_dept(100,10);
          
          call insert_emp(100001,500000);
          ————————————————
          版权声明：本文为CSDN博主「@zzy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
          原文链接：https://blog.csdn.net/qq_42826747/article/details/106674270"
          - 数据格式
            - dept表 id deptno dname loc
            - emp表 id empno ename job mgr上级 hiredate sal comm红利 deptno
      - 日志 ANKIED
        - mysqldumpslow MySQL提供的日志分析工具
      - 锁机制 ANKIED
        - 锁的目的？——协调多线程访问同一资源 ankied
        - 锁的分类
          - 按照操作——读锁 写锁 ankied
          - 按照粒度——表锁 行锁 页锁 ankied
            - 表锁 基于 MyISam ankied
              "开销小 加锁快 无死锁 粒度大 冲突几率高 并发低"
              - 手动加锁 lock table 表名 read/write
              - 手动解锁 unlock tables
              - 查看表加锁情况 show open tables
              - 对表t加了读锁，当前session写t？——立即返回失败
              - 对表t加了读锁，当前session读t2？——立即返回失败
              - 对表t加了读/写锁，其他session写t？——阻塞
              - 对表t加了写锁，其他session读t？——阻塞
              - 对表t加了写锁，当前session读t？——可以
              - show status like 'table%' —— 查看表锁的情况（加锁次数、竞争次数）
            - 行锁 基于 InnoDB
              "开销大 加锁慢 会有死锁 粒度小 冲突小 并发大"
              - InnoDb 和 MyISam 区别——事务+行锁
                - 回顾 ACID
                  "a-原子性 c-一致性 i-隔离性 d-持久性"
              - set autocommit=0; —— 关闭自动提交
                - 开启自动提交：则单sql自动提交，但是可以用 BEGIN 手动开启事务
                - 关闭自动提交：则默认所有sql需要手动提交
              - 手动开启事务 begin
              - 会话A修改数据未提交，会话B修改同行数据——阻塞
              - 会话A修改数据未提交，会话B修改不同行数据——不阻塞
              - 索引失败行锁升级表锁
                "where a=100，但是a是varchar型，则这个sql会导致表锁"
              - 间隙锁
                - 间隙锁（Gap Lock）是Innodb在可重复读提交下为了解决幻读问题时引入的锁机制
                - 加锁的单位是一段区间
                - 实例：会话A范围修改id=1-9的数据，但实际上id=3不存在，会话B新增id=3，A会让B阻塞
                - 出现条件: 索引、唯一索引、非唯一索引..  已ANKIED
              - show status like 'innodb_row_lock%'
      - 主从复制 ANKIED
        - 原理：slave从master读binlog二进制日志
        - 配置方法（一主一从）
          - 网络通、防火墙配置
          - 主机配置文件
            "[mysqlId]
            server-id=1 // 唯一id
            log-bin=地址 //配置二进制日志
            read-only=0 // 表示主机可以读写
            [可选，错误日志
            [可选，根目录，临时目录，数据目录
            [可选，不需要主从复制的数据库，需要复制的数据库"
          - 从机配置文件
            "[mysqlId]
            服务器id"
          - 主机授权从机
            "grant replication slave on *.* to user@ip indentified by '123';
            flush privileges;
            show master status"
          - 从机配置需要复制的主机
            "change master to master_host=ip
            master_user=user
            master_password=123
            master_log_file='..'
            master_log_pos=321;
            
            show slave status"
          - 停止注册复制：stop slave
      - mycat
    - 常见问题
      - 元查询
        - show databases
        - show tables
        - desc t_name
        - select database(); 查看正在哪个数据库
        - select version(); 查看数据库版本
        - select user();
      - 新建数据库 创建数据库 create database if not exists testAndLearn default character set = 'utf8mb4';
        "utf8mb4 和 utf8 区别
        前者用1-4字节存储，后者为1-3字节
        前者完全兼容后者"
      - char(n) 和 varchar(n) 2020年5月15日
        "char 固定长度，不管用不用完都占用。但是检索效率高
        
        varcahr 节省空间，检索效率低于 char"
    - docker下使用
      - 安装 docker pull mysql //最新版
      - 启动 docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql
        "需要指定ROOT PASSWORD
        ----------------------
        [root@test23 ~]# docker logs a6764e7fdec5
        2020-01-30 08:59:45+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.19-1debian9 started.
        2020-01-30 08:59:45+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'
        2020-01-30 08:59:45+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.19-1debian9 started.
        2020-01-30 08:59:45+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified
                You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD"
      - 指定配置参数 docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
      - 指定配置文件 docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
        "挂载主机的/my/custom 到docker 的 /etc/mysql/conf.d"
      - 尚学堂推荐的运行命令 docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
        "1.utf8与utf8mb4（utf8 most bytes 4）
        MySQL 5.5.3之后增加了utfmb4字符编码
        支持BMP（Basic Multilingual Plane，基本多文种平面）和补充字符
        最多使用四个字节存储字符
        utf8mb4是utf8的超集并完全兼容utf8，能够用四个字节存储更多的字符。
        
        标准的UTF-8字符集编码是可以使用1-4个字节去编码21位字符，这几乎包含了世界上所有能看见的语言。
        MySQL里面实现的utf8最长使用3个字符，包含了大多数字符但并不是所有。例如emoji和一些不常用的汉字，如“墅”，这些需要四个字节才能编码的就不支持。
        
        2.字符集、连接字符集、排序字符集
        utf8mb4对应的排序字符集有utf8mb4_unicode_ci、utf8mb4_general_ci.
        
        utf8mb4_unicode_ci和utf8mb4_general_ci的对比：
        
        准确性：
        utf8mb4_unicode_ci是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序
        utf8mb4_general_ci没有实现Unicode排序规则，在遇到某些特殊语言或者字符集，排序结果可能不一致。
        但是，在绝大多数情况下，这些特殊字符的顺序并不需要那么精确。
        性能
        utf8mb4_general_ci在比较和排序的时候更快
        utf8mb4_unicode_ci在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。
        但是在绝大多数情况下发，不会发生此类复杂比较。相比选择哪一种collation，使用者更应该关心字符集与排序规则在db里需要统一。"
      - 谷粒商城的MySQL
        "docker run -p 23306:3306 --name mysqlGrain \
        -v /var/grainmall/docker/mysql57/mysqlGrain/conf:/etc/mysql \
        -v /var/grainmall/docker/mysql57/mysqlGrain/logs:/var/log/mysql \
        -v /var/grainmall/docker/mysql57/mysqlGrain/data:/var/lib/mysql \
        -e MYSQL_ROOT_PASSWORD=123456 \"
      - 更多配置见 https://registry.hub.docker.com/_/mysql 
    - 其他
      - ideaJ中配置数据库
        "jdbc:mysql://localhost:3306/ichiwan?serverTimezone=Asia/Shanghai"
      - com.mysql.cj.jdbc.Driver 和 com.mysql.jdbc.Driver
        "前者更新，需要制定时区"
  - elastic-search 搜索与分析
    - Q&A 2020年6月8日
      - 问：有了数据库，还有这个干嘛？
        "现在大型网站，数据库 MySQL 仅仅做持久化
        海量数据的搜索，交给 ES 完成
        
        MySQL 单表百万数据 检索满"
      - 问：功能？
        "搜索 分析 监控 数据分析、可视化
        
        电商项目的所有检索都是 ES 完成的"
      - 问：历史？ 2020年6月8日
        "Lucene 的基础上进行封装，暴露restful api"
    - 基础知识 2020年6月8日
      - 索引 index —— insert/database
        "动词：insert 名词：类似database"
      - 类型 type —— table @Deprecated  since 6.0
        "类似 table。一个 index 中有多个 type"
      - 文档 document —— 元组
        "json 格式，类似于表中的内容"
      - 倒排索引 / 倒排索引表 2020年6月8日
        - 分词（把一句话拆成单词，如）
          "1.红海行动 = 红海 + 行动 2.探索红海行动 3.红海特别行动..."
        - 建立倒排索引表(单词, 记录id)
          "红海 1,2,3  /   行动 1,23  /  探索 2  / 特别 3"
        - 检索 -> 相关性得分
          "检索：红海行动。先分词，然后查索引"
        - 总结 2020年6月8日
          "正向索引：id->content
          倒排索引：content->id"
    - 简单使用
      - 安装和运行、ik分词器
        - docker pull elasticsearch:7.4.2
          - 创建本地文件夹&文件
            "mkdir -p /var/grainmall/docker/elasticsearch/config
            mkdir -p /var/grainmall/docker/elasticsearch/data
            
            // 写入配置
            echo "http.host: 0.0.0.0" >> /var/grainmall/docker/elasticsearch/config/elasticsearch.yml"
          - 运行
            "docker run --name elasGrain -p 29200:9200 -p 29300:9300 \
            -e "discovery.type=single-node" \
            -e ES_JAVA_OPTS="-Xms256m -Xmx256m" \
            -v /var/grainmall/docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
            -v /var/grainmall/docker/elasticsearch/data:/usr/share/elasticsearch/data \ 
            -v /var/grainmall/docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
            -d elasticsearch:7.4.2
            
            合并一下
            ----------
            docker run --name elasGrain -p 29200:9200 -p 29300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms1024m -Xmx1024m" -v /var/grainmall/docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /var/grainmall/docker/elasticsearch/data:/usr/share/elasticsearch/data -v /var/grainmall/docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.4.2"
          - 运行失败 使用 docker logs 查看日志
            "ElasticsearchException[failed to bind service]; nested: AccessDeniedException[/usr/share/elasticsearch/data/nodes];
            
            "Caused by: java.nio.file.AccessDeniedException: /usr/share/elasticsearch/data/nodes",
            
            拒绝访问"
          - 授权 chmod -R 777 /var/grainmall/docker/elasticsearch
          - 检查运行情况 http://192.168.2.3:29200/ 
        - docker pull kibana:7.4.2
          "es 的数据可视化"
          - 运行
            "docker run --name kibanaGrain -e ELASTICSEARCH_HOSTS=http://192.168.2.3:29200 -p 25601:5601 -d kibana:7.4.2"
          - 进入 http://192.168.2.3:25601/ 
        - 安装 ik分词器
          "https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip"
          - 解压到挂载的目录 /var/grainmall/docker/elasticsearch/plugins/ik
            "目录下新建 ik 文件夹"
          - chmod -R 777 ../   // 修改权限
          - docker restart  // 重启容器
      - 简单检索
        - _cat
          - GET _cat/nodes 查看所有节点(服务器)
            "127.0.0.1 45 97 2 0.31 0.28 0.31 dilm * 985a3b233e62"
          - GET _cat/health es健康情况
            "1591541390 14:49:50 elasticsearch green 1 1 3 3 0 0 0 0 - 100.0%
            绿色 监控
            集群分片信息"
          - GET _cat/masster 主节点
            "gjYdyTjeR82KB0tibNxapg 127.0.0.1 127.0.0.1 985a3b233e62"
          - GET _cat/indices 所有索引 （show databases
            "green open .kibana_task_manager_1   cJhAuN7VT02oipQItqPUng 1 0 2 0 46.2kb 46.2kb
            green open .apm-agent-configuration yXqf0PrdTLSKKF7W-5SrjA 1 0 0 0   283b   283b
            green open .kibana_1                0OQ4LJy_R8KYKVef1gZoIQ 1 0 8 0 38.2kb 38.2kb"
        - 索引文档（insert）
          - PUT index/type/id
            "index名字 + 类型名字 + 唯一id
            json 数据"
            - 测试 PUT customer/external/1
              "{
               	"name": "John Doe"
              }
              
              --------------
              {
                  "_index": "customer", // 索引
                  "_type": "external", // 类型
                  "_id": "1", // 唯一id
                  "_version": 1, // 版本
                  "result": "created", // 结果
                  "_shards": { // 分片信息
                      "total": 2,
                      "successful": 1,
                      "failed": 0
                  },
                  "_seq_no": 0,
                  "_primary_term": 1
              }"
            - 再发送一次同路径的数据 则变成 update
              "{
                  "_index": "customer",
                  "_type": "external",
                  "_id": "1",
                  "_version": 2,
                  "result": "updated",
                  "_shards": {
                      "total": 2,
                      "successful": 1,
                      "failed": 0
                  },
                  "_seq_no": 1,
                  "_primary_term": 1
              }"
          - POST index/type 可以不指定id
            "不指定则自动生成唯一id"
          - 不带id，则总是新增数据。否则可以更新数据
          - PUT/POST 区别：PUT必须带有id
          - 【乐观锁】并发控制 ?if_seq_no=0&if_primary_term=1
            "冲突
            {
                "error": {
                    "root_cause": [
                        {
                            "type": "version_conflict_engine_exception",
                            "reason": "[1]: version conflict, required seqNo [0], primary term [1]. current document has seqNo [4] and primary term [1]",
                            "index_uuid": "ptAVLUM0Q-mBk-IYJRBHTg",
                            "shard": "0",
                            "index": "customer"
                        }
                    ],
                    "type": "version_conflict_engine_exception",
                    "reason": "[1]: version conflict, required seqNo [0], primary term [1]. current document has seqNo [4] and primary term [1]",
                    "index_uuid": "ptAVLUM0Q-mBk-IYJRBHTg",
                    "shard": "0",
                    "index": "customer"
                },
                "status": 409
            }"
            - 字段_seq_no 控制并发写，每次更新++，用来做乐观锁
            - 字段_primary_term 主分片重新分配，如重启，会变化
          - POST index/type/_bulk // 批量导入数据
            "{"index":{"_id":1}}
            {"name":"John Doe"}
            {"index":{"_id":1}}
            {"name":"Jane Doe"}
                 <- 最后要换行
            
            -------------
            操作对象元数据
            数据
            ...."
            - 测试 POST http://192.168.2.3:29200/customer/external/_bulk 
              "{"index":{"_id":1}}
              {"name":"John Doe"}
              {"index":{"_id":1}}
              {"name":"Jane Doe"}
              
              
              --------------
              {
                  "took": 91,
                  "errors": false,
                  "items": [
                      {
                          "index": {
                              "_index": "customer",
                              "_type": "external",
                              "_id": "1",
                              "_version": 1,
                              "result": "created",
                              "_shards": {
                                  "total": 2,
                                  "successful": 1,
                                  "failed": 0
                              },
                              "_seq_no": 0,
                              "_primary_term": 1,
                              "status": 201
                          }
                      },
                      {
                          "index": {
                              "_index": "customer",
                              "_type": "external",
                              "_id": "1",
                              "_version": 2,
                              "result": "updated",
                              "_shards": {
                                  "total": 2,
                                  "successful": 1,
                                  "failed": 0
                              },
                              "_seq_no": 1,
                              "_primary_term": 1,
                              "status": 200
                          }
                      }
                  ]
              }"
        - 查询文档
          - GET index/type/id
            - 测试 GET PUT customer/external/1
              "{
                  "_index": "customer",
                  "_type": "external",
                  "_id": "1",
                  "_version": 4, // 版本
                  "_seq_no": 3, // 并发控制自动
                  "_primary_term": 1, // 乐观锁相关
                  "found": true, // 找到数据
                  "_source": { // 数据本身
                      "name": "John Doe"
                  }
              }"
        - 更新文档
          - POST index/type/id/_update // 检察源数据
            "JSON格式特殊
            {
                "doc": {
                    "name": "John Doe"
                }
            }"
            - 这种方式更新时，若数据无变化，则不操作 noop ，版本号不变
              "{
                  "_index": "customer",
                  "_type": "external",
                  "_id": "1",
                  "_version": 5, // 版本号不变
                  "result": "noop", // 没有操作
                  "_shards": {
                      "total": 0,
                      "successful": 0,
                      "failed": 0
                  },
                  "_seq_no": 4,
                  "_primary_term": 1
              }"
          - POST/PUT index/type/id
            "数据JSON格式
            {
             	"name": "John Doe"
            }"
        - 删除文档 2020年6月9日
          - DELETE index/type/id
          - DELETE index // 删除整个索引
      - 复杂检索 // 未导入 ANKI
        - 测试数据 https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip 
          "POSY bank/account/_bulk 导入"
        - GET bank/_search
          "{
            "query": {
              "match_all": {}
            },
            "sort": [
              {
                "account_number":"desc" // 按照这个字段降序
              }
            ]
          }"
        - query
          - match_all:{} // 匹配所有
          - match:{field:val} // 查询字段
            "val = "aa bb cc" 时，是把 aa bb cc 分开查询"
          - match_phrase:{field:val} // 短语查询
            "val = "aa bb cc" 时，短语一起查询"
          - field.keyword // 文本精确匹配
          - multi_match:{query:val, fields:[]} // 多字段同条件
            "如对字段 name 和 city 都查询 aaa"
          - term:{field:val} // 查非文本 or 分词
            "用 term 查文本数据时，必须是精确的分词才行"
          - bool{} // 复合条件
            - must:{} // 相当于 sql AND
            - must_not:{} // 相当于 sql NOT
            - should:{} // 能匹配最好，不行也可以
            - filter:{} // 和must一样但是不贡献得分
          - 辨析
            - match_phrase 完整短语 / field.keyword 完整文本 / term 查分词
              "假设存在记录 "a b c","a c"
              
              match_phrase 查 "a b c"，会得到 "a b c"
              match_phrase 查 "a b"，会得到 "a b c"
              完整短语匹配
              
              field.keyword 查 "a b c"，会得到 "a b c"
              field.keyword 查 "a b"，空
              完整文本匹配
              
              term 查 "a b c" ，空
              term 查 "a b" ，空
              分词匹配
              因为记录分词只有 a/b/c，所以 term 有空格一定查不到"
            - 何时用 term？ -- 非文本字段
        - aggs // 聚合 ≈ group by
          - aggs:{name:{method:{}}} // 先对聚合取名，指定方法
          - terms:{field} // 该字段值-频数
            "如 男-10 女-11"
          - avg:{field} // 该字段平均值
          - aggs{name:{aggs}} // 子聚合
            "比如对年龄算频数后，再对工资求均值"
          - 示例 三层聚合
            "GET /bank/_search
            {
              "query": {
                "match_all": {}
              },
              "size": 0,
              "_source": "",
              "aggs": {
                "年龄频数": {
                  "terms": {
                    "field": "age"
                  },
                  "aggs": {
                    "平均工资by年龄": {
                      "avg": {
                        "field": "balance"
                      }
                    },
                    "性别频数by年龄": {
                      "terms": {
                        "field": "gender.keyword",
                        "size": 10
                      },
                      "aggs": {
                        "平均工资by年龄&性别": {
                          "avg": {
                            "field": "balance"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }"
        - sort:[{字段名:asc/desc}] // 排序
        - from:n / size:m // 对结果分页
        - _source:[field] // 返回部分字段
        - 返回结果
          - took 花费毫秒数
          -  _shards 每个节点做的工作情况
          - hits 命中记录
          - max_score 找到的最相关的文档的分数
      - Mapping // 字段属性
        "定义一个 index 的字段 field 是怎么存储的，如 文本字段、数字、日期..
        注意：type 已经废弃了，所以以后 index 即是数据库、也是表"
        - GET index/_mapping // 查询index的字段属性
        - PUT index {mappings} // 创建 index，并指定字段类型
          "{
            "mappings": {
              "properties": {
                "age":    { "type": "integer" },  
                "email":  { "type": "keyword"  }, 
                "name":   { "type": "text"  }     
              }
            }
          }"
        - 可以给 index 添加新的字段，但是不能修改。修改需要建新index然后迁移 reindex
        - 可以控制字段是否可被索引 index:false
        - 字段属性 properties
          - text类型 -> 分词
          - keyword类型 // text 的子类型，不分词
      - 分词
        - 分词器 tokenizer
          "接受字符流，输出分词 tokens 流"
        - POST _analyze // 查看分词情况
          "{
            "analyzer": "standard",
            "text": "The following parameters are accepted by range types"
          }"
        - ik_smart分词器 和 ik_max_word分词器
          "POST _analyze
          {
            "analyzer": "ik_smart",
            "text": "我是中国人"
          }
          
          --------------
          {
            "tokens" : [
              {
                "token" : "我",
                "start_offset" : 0,
                "end_offset" : 1,
                "type" : "CN_CHAR",
                "position" : 0
              },
              {
                "token" : "是",
                "start_offset" : 1,
                "end_offset" : 2,
                "type" : "CN_CHAR",
                "position" : 1
              },
              {
                "token" : "中国人",
                "start_offset" : 2,
                "end_offset" : 5,
                "type" : "CN_WORD",
                "position" : 2
              }
            ]
          }
          
          
          
          ---------
          POST _analyze
          {
            "analyzer": "ik_max_word",
            "text": "我是中国人"
          }
          
          ------------
          {
            "tokens" : [
              {
                "token" : "我",
                "start_offset" : 0,
                "end_offset" : 1,
                "type" : "CN_CHAR",
                "position" : 0
              },
              {
                "token" : "是",
                "start_offset" : 1,
                "end_offset" : 2,
                "type" : "CN_CHAR",
                "position" : 1
              },
              {
                "token" : "中国人",
                "start_offset" : 2,
                "end_offset" : 5,
                "type" : "CN_WORD",
                "position" : 2
              },
              {
                "token" : "中国",
                "start_offset" : 2,
                "end_offset" : 4,
                "type" : "CN_WORD",
                "position" : 3
              },
              {
                "token" : "国人",
                "start_offset" : 3,
                "end_offset" : 5,
                "type" : "CN_WORD",
                "position" : 4
              }
            ]
          }"
        - 自定义分词/词库
          "因为实际中分词效果不是很好，如希望把 尚硅谷 识别为完整单词
          
          修改 ik/config/IKAnalyzer.xml
          <entry key="remote_ext_dict">http://192.168.2.3:20080/es/fenci.txt</entry>
          
          重启es"
          - 前期操作
            - 把 elesticseatch 堆内存调到512M
              "停止、删除容器，然后新建。因为我们映射了文件，所以数据不会丢失"
            - 安装 nginx
            - nginx 的 html 目录下建立 es 文件夹
            - 创建 fenci.txt
              "内容
              -----------
              尚硅谷"
    - Java 操作 es
      "查看文档 https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.7/java-rest-low-usage-requests.html#java-rest-low-usage-request-options"
      - 配置（springboot）
        - elasticsearch-rest-high-level-client
          "<!-- https://mvnrepository.com/artifact/org.elasticsearch.client/elasticsearch-rest-high-level-client -->
          <dependency>
              <groupId>org.elasticsearch.client</groupId>
              <artifactId>elasticsearch-rest-high-level-client</artifactId>
              <version>7.4.2</version>
          </dependency>
          "
        - 如果是 springboot 项目，还要改版本，因为 springboot 已经指定了版本
          "<properties>
              <elasticsearch.version>7.4.2</elasticsearch.version>
          </properties>"
        - 配置Bean
          "@Configuration
          public class GulimallElasticSearchConfig {
              private final static Logger LOGGER = LoggerFactory.getLogger(GulimallElasticSearchConfig.class);
          
              @Bean
              public RestHighLevelClient restHighLevelClient(){
                  return new RestHighLevelClient(
                          RestClient.builder(
                                  new HttpHost("192.168.2.3",29200,"http")
                          )
                  );
              }
          }"
        - 增加默认请求项
          "    public static final RequestOptions COMMON_OPTIONS;
              static {
                  RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();
          //        builder.addHeader("Authorization", "Bearer " + TOKEN);
          //        builder.setHttpAsyncResponseConsumerFactory(
          //                new HttpAsyncResponseConsumerFactory
          //                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));
                  COMMON_OPTIONS = builder.build();
              }"
        - 如果启动时数据库出错
          "@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)"
      - 储存数据 index
        "// 数据
        Map<String, String> data = new HashMap<>();
        data.put("userName", "madokast");
        data.put("age", "14");
        
        // 准备
        IndexRequest indexRequest = new IndexRequest("users"); // 指定 index 名
        indexRequest.id("1"); // 设置 id
        indexRequest.source(JSON.toJSONString(data), XContentType.JSON);
        
        // 保存
        IndexResponse indexResponse = restHighLevelClient.index(indexRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);
        
        LOGGER.info("indexResponse = {}", indexResponse);"
      - 检索数据 search
        "        SearchRequest searchRequest = new SearchRequest();
                searchRequest.indices("bank"); // 指定 index
                SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
                searchSourceBuilder.query(QueryBuilders.termQuery("address","mill"));
        //        searchSourceBuilder.aggregation();
                searchSourceBuilder.from(0);
                searchSourceBuilder.size(5);
                searchRequest.source(searchSourceBuilder);
        
                SearchResponse searchResponse = restHighLevelClient.search(searchRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);
                LOGGER.info("searchResponse = {}", searchResponse);
                SearchHits hits = searchResponse.getHits();
                for (SearchHit hit : hits) {
                    String sourceAsString = hit.getSourceAsString();
                    LOGGER.info("sourceAsString = {}", sourceAsString);
                }
        
        
        
        -------------
        2020-06-10 22:51:42.048  INFO 25604 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : searchResponse = {"took":1,"timed_out":false,"_shards":{"total":1,"successful":1,"skipped":0,"failed":0},"hits":{"total":{"value":4,"relation":"eq"},"max_score":5.4032025,"hits":[{"_index":"bank","_type":"account","_id":"970","_score":5.4032025,"_source":{"account_number":970,"balance":19648,"firstname":"Forbes","lastname":"Wallace","age":28,"gender":"M","address":"990 Mill Road","employer":"Pheast","email":"forbeswallace@pheast.com","city":"Lopezo","state":"AK"}},{"_index":"bank","_type":"account","_id":"136","_score":5.4032025,"_source":{"account_number":136,"balance":45801,"firstname":"Winnie","lastname":"Holland","age":38,"gender":"M","address":"198 Mill Lane","employer":"Neteria","email":"winnieholland@neteria.com","city":"Urie","state":"IL"}},{"_index":"bank","_type":"account","_id":"345","_score":5.4032025,"_source":{"account_number":345,"balance":9812,"firstname":"Parker","lastname":"Hines","age":38,"gender":"M","address":"715 Mill Avenue","employer":"Baluba","email":"parkerhines@baluba.com","city":"Blackgum","state":"KY"}},{"_index":"bank","_type":"account","_id":"472","_score":5.4032025,"_source":{"account_number":472,"balance":25571,"firstname":"Lee","lastname":"Long","age":32,"gender":"F","address":"288 Mill Street","employer":"Comverges","email":"leelong@comverges.com","city":"Movico","state":"MT"}}]}}
        2020-06-10 22:51:42.069  INFO 25604 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : sourceAsString = {"account_number":970,"balance":19648,"firstname":"Forbes","lastname":"Wallace","age":28,"gender":"M","address":"990 Mill Road","employer":"Pheast","email":"forbeswallace@pheast.com","city":"Lopezo","state":"AK"}
        2020-06-10 22:51:42.069  INFO 25604 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : sourceAsString = {"account_number":136,"balance":45801,"firstname":"Winnie","lastname":"Holland","age":38,"gender":"M","address":"198 Mill Lane","employer":"Neteria","email":"winnieholland@neteria.com","city":"Urie","state":"IL"}
        2020-06-10 22:51:42.069  INFO 25604 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : sourceAsString = {"account_number":345,"balance":9812,"firstname":"Parker","lastname":"Hines","age":38,"gender":"M","address":"715 Mill Avenue","employer":"Baluba","email":"parkerhines@baluba.com","city":"Blackgum","state":"KY"}
        2020-06-10 22:51:42.069  INFO 25604 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : sourceAsString = {"account_number":472,"balance":25571,"firstname":"Lee","lastname":"Long","age":32,"gender":"F","address":"288 Mill Street","employer":"Comverges","email":"leelong@comverges.com","city":"Movico","state":"MT"}
        "
      - 聚合检索
        "searchSourceBuilder.aggregation(AggregationBuilders.terms("ageTerms").field("age").size(5));
        
        Terms ageTerms = searchResponse.getAggregations().get("ageTerms");
        List<? extends Terms.Bucket> buckets = ageTerms.getBuckets();
        buckets.forEach(bucket->{
            String keyAsString = bucket.getKeyAsString();
            long docCount = bucket.getDocCount();
            LOGGER.info("keyAsString = {}", keyAsString);
            LOGGER.info("docCount = {}", docCount);
        
        });
        
        -------------------------
        
        2020-06-10 23:10:00.081  INFO 28104 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : keyAsString = 38
        2020-06-10 23:10:00.081  INFO 28104 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : docCount = 2
        2020-06-10 23:10:00.081  INFO 28104 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : keyAsString = 28
        2020-06-10 23:10:00.081  INFO 28104 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : docCount = 1
        2020-06-10 23:10:00.081  INFO 28104 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : keyAsString = 32
        2020-06-10 23:10:00.081  INFO 28104 --- [           main] .a.g.s.c.GulimallElasticSearchConfigTest : docCount = 1"
    - 《Elasticsearch源码分析与优化实践》 张超
      - 第一章 走进 ES
        - 分片 shard
          - 1. index 拆成多个分片; 2. 每个分片有主从之分
          - 分片是读写搜索的基本单元
          - 集群变化时，各节点会迁移分片，保持均匀
          - ⭐搜索1个有n分片的index 和 搜索n个有1分片的index 效率一样
            "所以应该周期性的建立新 index，如site20200612"
          - 分片怎么存在磁盘的？ 1个分片有多个段组成，每个段即一个文件
            "分片存入磁盘后具有不变性"
        - 倒排索引表
          - 倒排索引表以“段”写入文件
          - 倒排索引表一旦写入文件就不变，删除只是标记删除
          - 文件不变性：利于并发读、操作系统缓存
          - 文件未即时写入？ES 会 REDO 日志
        - 集群 - 节点
          - 主节点 master node
            "即 leader，唯一，管理集群"
          - 数据节点 data node
          - 每个节点都知道任一文档所在位置
          - 集群健康 绿-黄-红
          - 集群扩容：分片会重新均匀分配
          - 节点异常：副分片会升级为主分片
        - API
          - 9200 JSON格式
          - 9300 序列化传输
            "理论效率高，但是实测差不多，将被移除"
        - 其他
          - Cuice框架？Google 的轻量依赖注入框架
      - 第二章 环境 略
      - 第三章 集群启动流程
        - 选主
          - bully 算法
            - 向 id 比自己大的节点发送 election
            - 若收到 election 则返回 alive
            - 若没有收到 alive 自己就是 leader
          - 防止脑裂：参选人数需要过半
        - 选元信息
          - leader 收集全部节点的元信息，找到最新的，再下发
        - 确定主、副分片
          - 怎么确定分片？ index+分片id
          - leader 收集全部分片信息，然后确定主分片
        - 恢复数据
          - 两步：主分片的恢复，然后副分片复制主分片
          - 为什么要恢复？
            "有的数据没有即时写入文件，需要从log拿到"
          - 主分片的恢复方法？ REDO LOG
          - 副分片的恢复 两步走
            - 先复制 文件
            - 再重放LOG
      - 第四章 节点的启动和关闭
        - kill ES节点会怎样？
          "会捕获kill信号，执行stop操作"
      - 第五章 选主流程
        - 选举算法有哪些？
          "bullly paxos..."
        - 半数同意原则可以防止脑裂
      - 第六章 数据模型 -- 解决主从分片一致性问题 ankied
        - 典型的一致性策略
          - 写操作被路由到主节点
          - 主节点完成写
          - 把写操作发给所有从节点
          - 从节点写好后，发送确认信号
          - 主节点收到所有确认信号后，回复写成功
        - 异常：有的从节点未回复怎么办？
          "从分片组里面踢出去"
      - 第七章 写流程
        - 写入单个文档：index。多个：bulk
        - 写流程：
          "1. 转发至主分片
          2. 主分片写，并完成
          3. 转发请求到所有副分片，完成后应答
          4. 全部完成，则主分片报告完成"
      - 第八章 GET流程
        - 转发请求到任意一个有次文档的分片的节点
      - 第九章 SEARCH流
        - 转发请求到所有有对应分片的节点
        - 每个分片都执行搜索
        - 汇总结果
      - 第十章 索引恢复
        - 索引恢复是什么？
          "ES启动时，把没有写入磁盘的数据，通过日志重放，恢复数据"
        - 问：副分片恢复时，怎么做到边恢复边提供服务？
          "三步走
          1.先恢复磁盘数据（不阻塞服务）
          2.再重放日志（不阻塞服务）
          3.重放第二步时产生的日志（阻塞）
          "
      - 第十一章 gateway 元数据
      - 第十二章 allocation模块
        - 什么是allocation？——分片指派当节点
      - 第十三章 snapshot模块
      - 第十四章 cluster模块
      - 第十五章 transport模块
      - 第十六章 threadpool模块
      - 第十七章 shrink模块 ankied
        "合并分片"
      - 第十八章 写入速度优化 ankied
        - 每次写操作后 都会日志flush？
          "是的，这样才能恢复数据"
        - 优化：各种请求轮流发给不同的节点
      - 第十九章 搜索速度优化 ankied
        - 应用程序的IO，会被OS缓存？——对的
  - 分布式数据库
    - 一致性问题
      - 为什么会有一致性问题？
        "数据库分了主从。从表的数据没有即时跟上主表"
      - 一致性导致的问题？现象？
        "NBA文字直播，一人声称A赢了，B刷新，却显示比赛未结束
        
        Alice和Bob坐在同一个房间里，盯着各自的手机，关注着2016年NBA总决赛文字直播。在最后时刻，Alice刷新页面，告诉Bob骑士夺冠了。Bob难以置信地刷新了自己的手机，但他的请求被路由到一个落后的数据库上，手机显示比赛仍在进行。"
      - 数据库主从的半同步？
        "指定一个从库，和主库完全同步，另外的从库只是异步更新
        即这个同步的从库，需要主库确认写好后，才提交"
      - 一致性分类
        - 强一致性（线性一致性）
        - 最终一致性
          "主从不是随时同步的，但是等待一段时间，从库最终会赶上并与主库保持一致"
        - 读写一致性
          - 现象：希望A用户留言后，刷新页面能立马看到自己的留言
          - 实现方法：用户搜索自己创造的内容，都是走主库。（或者按时间戳路由）
        - 单调读
          - 现象：A用户刷新页面，不会出现比刚刚还旧的数据
          - 实现方法：让用户总是从同一个节点进行读取（id路由）
        - 因果一致性
          - 现象：如果A、B之间存在因果，则不应出现找到B数据，但是找不到A
    - 共识
      - 解释？——让所有节点就某事达成一致
        "例如：所有节点对事务的结果达成一致：要么全部中止/回滚，要么全部提交。"
      - 全序广播
    - 两阶段提交 ankied
      - 哪两个阶段？——准备阶段 + 提交阶段
      - 两个角色？——参与者 + 协调着
      - 准备阶段
        "协调着询问是否可以提交，参与者回复可以（此时还没有完成提交）"
      - 提交阶段
        "协调者发起提交/归滚，参与者执行"
  - Mybatis
    - 简介
      "原本是 apache 的ibatis ，团队转到 google 的mybatis
      
      持久化层框架
      
      jdbc 操作 jdbcUtils jdbcTemplate
      
      hibernate"
      - mybatis 和 hibernate 不同
        "mybatis —— 把 Java方法 和 sql 关联
        hibernate —— 把 Java对象 和 数据库表关联"
    - 知识点
      - SqlSession 代表和db的会话 线程不安全
    - 基本使用（主xml、mapper-xml）
      - 基本配置
        - 主 xml 配置日志、数据库、mappers
          "<?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
          <configuration>
          
              <settings>
                  <setting name="logImpl" value="SLF4J"/>
              </settings>
          
              <environments default="development">
                  <environment id="development">
                      <transactionManager type="JDBC" />
                      <dataSource type="POOLED">
                          <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                          <property name="url" value="jdbc:mysql://192.168.2.3:13306/mybatis_learn?serverTimezone=Hongkong" />
                          <property name="username" value="root" />
                          <property name="password" value="123456" />
                      </dataSource>
                  </environment>
              </environments>
          
              <mappers>
                  <mapper resource="mapper/class-mapper.xml"/>
              </mappers>
          
          </configuration>"
        - mapper接口
          "package com.zrx.mapper;
          
          import com.zrx.entity.Class;
          
          public interface ClassMapper {
          
              Class getClassById(Integer id);
          
          }"
        - mapper-xml
          "<?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE mapper
                  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
          
          <mapper namespace="com.zrx.mapper.ClassMapper">
              <select id="getClassById" resultType="com.zrx.entity.Class">
                  select `id`,`name` from tb_class where id = #{id}
              </select>
          </mapper>"
        - 使用sqlSession 获取 mapper对象 执行crud
          "InputStream in = Resources.getResourceAsStream("mybatis-config.xml");
          
          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
          
          SqlSession sqlSession = sqlSessionFactory.openSession();
          
          LOGGER.debug(sqlSession.toString());
          
          ClassMapper mapper = sqlSession.getMapper(ClassMapper.class);
          
          Class classById = mapper.getClassById(1);
          
          LOGGER.debug(classById.toString());
          
          sqlSession.close();"
      - select 返回list 时，返回值类型为元素类型
        "方法 List<Class> selectNameLike(String name);
        
        配置
        <select id="selectNameLike" resultType="com.zrx.entity.Class">
            select `id`,`name` from tb_class where `name` like #{name}
        </select>
        
        使用
        
        List<Class> classes = mapper.selectNameLike("%2020%");
         "
      - insert 方法 返回值可以是空，也可以是 int long bool
        "void add(Class c);
        
        <insert id="add">
            insert into tb_class(`name`) values(#{name})
        </insert>
        
         #{} 可以直接从 Class 类中取值"
        - insert 后自动获取主键  useGeneratedKeys="true" keyProperty="id"
          "<insert id="add" useGeneratedKeys="true" keyProperty="id">
              insert into tb_class(`name`) values(#{name})
          </insert>"
      - update 方法 返回值可以是空，也可以是 int long bool
        "    <update id="update" parameterType="cla">
                update tb_class set `name`=#{name} where id=#{id}
            </update>"
      - delete 方法 返回值可以是空，也可以是 int long bool
        "<delete id="deleteById" parameterType="integer">
            delete from tb_class where `id` = #{id}
        </delete>"
      - 手动提交数据 sqlSession.commit();
    - #{}使用方法
      - 方法只有一个简单参数(Integer/String...)时，任意名字
        "方法 fun(int id) 则参数 #{这里随便写}"
      - 方法有多个参数时，会整个封装为 map，使用 #{0} #{1} #{param1} #{param2} 取值 （真垃圾）
        "方法 fun(String a, int b) ，参数只能是 #{0} #{1} #{param1} #{param2}"
      - 方法有多个参数时，使用@Param("key") 注解，对 map 命名
        "方法 fun(@Param("a")String a,@Param("b") int b) ，参数只能是 #{a} #{b}"
      - 方法传入对象pojo时，使用 #{属性名}
      - 方法传入 map，使用 #{key}
      - 方法传入 list，使用 #{list[i]} 
      - 指定规则：javaType、jdbcType(在orcle数据库，null字段需要额外指定jdbcType=Null)、typeHandler
    - 主配置文件
      - properties 属性 引入外部properties文件
        "1. 新建pwd.properties 文件
        db.password=123456
        
        
        2. 
        <!--    可以引入外部properties文件-->
        <!--    resource 类路径-->
            <properties resource="pwd.properties"/>
        
        3. 使用
        <environments default="development">
            <environment id="development">
                <transactionManager type="JDBC" />
                <dataSource type="POOLED">
                    <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                    <property name="url" value="jdbc:mysql://192.168.2.3:13306/mybatis_learn?serverTimezone=Hongkong" />
                    <property name="username" value="root" />
                    <property name="password" value="${db.password}" />
                </dataSource>
            </environment>
        </environments>"
      - settings 设置
        - 日志配置
          "    <settings>
                  <setting name="logImpl" value="SLF4J"/>
              </settings>"
        - 二级缓存 cacheEnabled
        - 懒加载 lazyLoadingEnabled
        - 映射下划线到驼峰命名 mapUnder...
      - type aliases 对类取一个别名
        - 主配置文件
          "<typeAliases>
              <typeAlias type="com.zrx.entity.Class" alias="cla"/>
          </typeAliases>
          
          alias 可以不写，那么就是 全类名中最后一个点.后的单词，小写首字母，即class"
        - 从配置文件
          "<select id="getClassById" resultType="cla">
              select `id`,`name` from tb_class where id = #{id}
          </select>"
        - <package name=""/> 包下类批量别名
        - 已经存在的别名
          - 基本类型的别名，即下划线 _ 加上名字，如 int 的别名 _int
          - 其他的：string、list 等待
      - type handlers 类型处理器 jdbc类型和Java类型的转换
      - object factory 对象工厂
      - plugins 插件
      - environments 环境
        - 配置多个环境 environments default 修改它，可以切换环境
          "<environments default="development">
              <environment id="development">
                  <transactionManager type="JDBC" />
                  <dataSource type="POOLED">
                      <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                      <property name="url" value="jdbc:mysql://192.168.2.3:13306/mybatis_learn?serverTimezone=Hongkong" />
                      <property name="username" value="root" />
                      <property name="password" value="${db.password}" />
                  </dataSource>
              </environment>
              <environment id="test">
                  <transactionManager type="JDBC" />
                  <dataSource type="POOLED">
                      <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                      <property name="url" value="jdbc:mysql://192.168.2.3:13306/mybatis_learn?serverTimezone=Hongkong" />
                      <property name="username" value="root" />
                      <property name="password" value="${db.password}" />
                  </dataSource>
              </environment>
          </environments>"
        - transaction manager 事务管理器
          "jdbc managed （这个不用学，我们最后使用spring的事务管理器）"
        - data source 数据源
          - type即配置dateSource具体实现类：pooled unpooled jndi 也可以使用自定义的dateSource
            "最终使用 spring 的 dateSource ，所以不用管"
      - database provider 数据库厂商标识
        "根据不同数据库厂商，自动调用不同的sql语句"
      - mappers 映射器 配置 mapper.xml 文件
    - 从配置文件
      - resultType 指定返回类型
      - resultMap标签  实现高级结果集映射（关联查询、延迟加载、鉴别器）
        - 自定义名称映射 例如 表中列名为 AA 想封装到Java对象属性的 BB
          "首先配置映射方法
          <resultMap id="ClassMap" type="com.zrx.entity.Class">
              <!--        id 主键-->
              <!--        column 列名-->
              <!--        property pojo 属性名-->
              <id column="id" property="id"/>
              <result column="AA" property="BB"/>
          </resultMap>
          
          然后使用
          <select id="getClassById" resultMap="ClassMap">
              select `id`,`name` from tb_class where id = #{id}
          </select>
          "
        - 级联封装 如 Java员工类中，存在部门属性。（员工和部门都是 pojo）
          "<resultMap id="ClassMap" type="com.zrx.entity.Class">
              <!--        id 主键-->
              <!--        column 列名-->
              <!--        property pojo 属性名-->
              <id column="id" property="id"/>
              <result column="dert_name" property="department.name"/>
          </resultMap>"
        - association 子标签 同样实现上述功能
          "<association property="java属性名" javaType="具体的全类类">
              <id column="" property=""/>
              <result column="" property=""/>
          </association>"
        - association 分布查询 支持延迟加载
          "<association property="java属性名" select="对应的mapper全类名.对应方法" colum="方法参数来自的列名">"
        - 在上述基础上，配置延迟加载 在主配置文件上 settings 加上 lazyLoadXXX=true 和 aggressiveLazyLoad = false
        - 1:1 关联，使用 association 子标签
        - 1:N 关联，使用 collation 子标签
        - 鉴别器（如果是女生，就把部门信息查出来，如果是男生，把name值赋值给email）...
      - flushCache useCache
      - timeout
      - 动态SQL
        - if
        - choose when otherwise
        - trim where when
        - forwach
    - 缓存
      - 一级缓存（本地缓存） sqlSession 级别 无法关闭
        "同一次会话中的缓存
        
        mapper.get(1) == mapper.get(1) √"
        - 失效方法：两次select之间，有过 增删改 方法，缓存失效
        - 手动清除缓存：sqlSession.clearCache()
      - 二级缓存 mapper 级别 默认关闭
        "跨会话级别，两个sqlSession的getMapper ，共享缓存"
        - 开启方法
          "主配置文件 （setters cacheEnabled）
          从配置文件 
          
          <cache eviction="FIFO" 
                 flushInterval="默认不清空，毫秒值" 
                 readOnly="如果设为true，则仅仅缓存引用对象，这样用户修改了对象，则缓存中的对象也变化，false则缓存序列化。默认false" 
                 size="缓存数目"/>
          
          "
        - !! 只有 sqlSession  关闭后，才会把一级缓存数据放到二级缓存
        - 失效：有过 增删改 方法 ，一级二级都会清除
      - 二级缓存，也可以用第三方实现
      - 先使用 二级缓存，不存在再使用一级缓存，再不存在访问数据库
    - 日志（开发mybatis使用）
      - 使用mybatis自己的日志接口 Log
        "import org.apache.ibatis.logging.Log;
        import org.apache.ibatis.logging.LogFactory;"
      - 在主配置xml中指定适配到具体的日志接口（SLF4J 或 COMMONS_LOGGING）（以SLF4J为例）
        "<settings>
            <setting name="logImpl" value="SLF4J"/>
        </settings>"
      - 导入依赖（以 slf4j为例）
        "<!--        slf4j日志-->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.25</version>
        </dependency>
        
        <!-- 添加logback-classic依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
        </dependency>
        <!-- 添加logback-core依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-core</artifactId>
            <version>1.2.3</version>
        </dependency>"
      - demo
        "package com.zrx;
        
        import org.apache.ibatis.logging.Log;
        import org.apache.ibatis.logging.LogFactory;
        
        /**
         * Description
         * Hello
         * 使用 mybatis 自己的日志接口
         * <p>
         * Data
         * 2020/8/3-13:06
         *
         * @author zrx
         * @version 1.0
         */
        
        public class HelloWorld {
            private static final Log LOGGER = LogFactory.getLog(HelloWorld.class);
        
            public static void main(String[] args) {
                LOGGER.debug("hello mybatis");
            }
        }"
    - 工作原理
      - 创建 SqlSessionFactory
        "InputStream in = Resources.getResourceAsStream("mybatis-config.xml");
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
        
        
        根据 XML 创建解析器
        XMLConfigBuilder parser
        
        解析器解析 获取 Configuration
        Configuration parse()
        就是解析主配置文件 
        例如解析 setting settingsElement(settings);
        configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty("autoMappingBehavior", "PARTIAL")));.....
        
        
        例如解析 mappers 会继续解析每个 mapper
        String namespace = context.getStringAttribute("namespace");
        
        mapper 信息也保存在 configuration中
        protected final Map<String, MappedStatement> mappedStatements = new StrictMap<MappedStatement>("Mapped Statements collection");
        
        "
        - 首先从 XML 中读取信息到 configuration （同时解析mapper.xml）
        - configuration 中每个 MappedStatement 即读取的 mapper.xml 中的一个crud信息，如 MappedStatement.sqlSource 还有 MapperRegistry.knownMappers 和创建mapper代理有关
        - 最终利用configuration 创建 DefaultSqlSessionFactory
      - 获取sqlSession = sqlSessionFactory.openSession()  // sqlSession 即封装 executor，所以这一步主要是构建 Executor
        "ExecutorType execType 执行器类型，默认 simple 
        
        private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
          Transaction tx = null;
          try {
        // 环境
            final Environment environment = configuration.getEnvironment();
        // 事务管理器
            final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
            tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
        
        // 创建  Executor  默认 executor = new SimpleExecutor(this, transaction);
        // 还有 ReuseExecutor 可复用  BatchExecutor 可批量
        // 如果开启缓存，则 executor = new CachingExecutor(executor); 包装 executor 
        // 可以有拦截器，可以对 executor 进一步包装 executor = (Executor) interceptorChain.pluginAll(executor);
        
            final Executor executor = configuration.newExecutor(tx, execType);
        
        
        // 默认的 sql session，包含 configuration 和 executor
            return new DefaultSqlSession(configuration, executor, autoCommit);
        
          } catch (Exception e) {
            closeTransaction(tx); // may have fetched a connection so lets call close()
            throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
          } finally {
            ErrorContext.instance().reset();
          }
        }"
        - 创建  Executor  默认 executor = new SimpleExecutor(this, transaction);
        - 如果开启缓存，则 executor = new CachingExecutor(executor); 包装 executor 
        - 可以有拦截器，可以对 executor 进一步包装 executor = (Executor) interceptorChain.pluginAll(executor);
        - 默认返回的 sql session，封装包含 configuration 和 executor
      - 获取mapper = sqlSession.getMapper(XXXMapper.class);
        - 实际调用 configuration.getMapper(type, this);
        - 再跳到 mapperRegistry.getMapper(type, sqlSession);
        - 进入正文，首先获得 proxyFactory =  knownMappers.get(type)
          - knownMappers 是一个 map<Class<?>, MapperProxyFactory<?>>
        - 最后 return proxyFactory.newInstance(sqlSession);
          - 即 return Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
          - 这个jdk代理中，最重要的InvocationHandler，来自 new MapperProxy<T>(sqlSession, mapperInterface, methodCache);
            "cache 即 Map<Method, MapperMethod> methodCache = new ConcurrentHashMap<Method, MapperMethod>();"
          - 最终接口方法执行的是 mapperMethod.execute(sqlSession, args);
          - 实例：如 insert 方法
            "case INSERT: {
            Object param = method.convertArgsToSqlCommandParam(args);
              result = rowCountResult(sqlSession.insert(command.getName(), param));
              break;
            }"
          - 最终交给 Executor 执行
      - 执行方法 select 为例
        - sqlSession.selectOne(command.getName(), param);
        - selSession.<T>selectList(str statement, obj parameter).get(0)
          "再看 selectList"
        - 由str的statement获得 MappedStatement ms = configuration.getMappedStatement(statement);
        - 交给 Executor.query(MappedStatement ms, Object parameter)
          - 这里，由 MappedStatement.getBoundSql(parameter); 即 MappedStatement  中获取 BoundSql
            "BoundSql 代表查询sql像信息"
        - 二级、一级缓存没有，则 Executor.queryFromDatabase(MappedStatement ms, Object parameter
        - 交由  Executor.doQuery(MappedStatement ms, Object parameter)
        - 在 doQuery 方法中，构建 StatementHandler
          "PreparedStatementHandler "
          - 这里 StatementHandler 会被拦截器包装
          - 同时构建 parameterHandler，也会被包装
        - 利用 prepareStatement 方法，构建 Statement ，这是 jdbc 对象了
        - sql的参数设置，通过 parameterHandler 完成，底层是 TypeHandler 
        - 查询结构，使用 resultHandler 处理，底层也是 TypeHandler 
    - 插件
      - 插件可以拦截的位置
        - Executor
          - update
          - query
          - flushStatements
          - commit
          - rollback
          - getTransaction
          - close / isClosed
        - ParameterHandler 设置sql参数
          - getParameterObject
          - setParameters
        - ResultSetHandler 封装结果
          - handleResultSet
          - handleOutputParameters
        - StatementHandler
          - prepare
          - parameterize
          - batch
          - update
          - query
      - 简单使用
        - 实现 org.apache.ibatis.plugin.Interceptor 类
          "@Intercepts({
                  /*
                   * 拦截 StatementHandler 对象的 parameterize 方法，参数是 {Statement.class}
                   */
                  @Signature(type = StatementHandler.class, method = "parameterize", args = {Statement.class})
          })
          public class MyFirstInterceptor implements Interceptor {
          
              private final Log LOGGER = LogFactory.getLog(MyFirstInterceptor.class);
          
              /**
               * 拦截目标方法
               */
              @Override
              public Object intercept(Invocation invocation) throws Throwable {
                  LOGGER.debug("intercept(invocation)" + invocation.toString());
                  Object[] args = invocation.getArgs();
                  Object target = invocation.getTarget();
                  Method method = invocation.getMethod();
          
                  LOGGER.debug("args = {}" + Arrays.toString(args));
                  LOGGER.debug("method = {}" + method);
                  LOGGER.debug("target = {}" + target);
                  
          
                  Object ret = invocation.proceed();
                  LOGGER.debug("执行 invocation.proceed()" + ret);
                  return ret;
              }
          
              /**
               * 包装目标对象
               */
              @Override
              public Object plugin(Object target) {
                  LOGGER.debug("包装要代理对象" + target.toString());
                  Object wrapped = Plugin.wrap(target, this);
                  LOGGER.debug("wrapped = " + wrapped.toString());
                  return wrapped;
              }
              
              @Override
              public void setProperties(Properties properties) {
                  //setProperties 拿到配置信息{username=123456}
                  LOGGER.debug("setProperties 拿到配置信息" + properties.toString());
              }
          }"
        - 主配置.xml
          "<plugins>
              <plugin interceptor="com.zrx.plugins.MyFirstInterceptor">
                  <property name="username" value="123456"/>
              </plugin>
          </plugins>"
      - 两个插件拦截同一方法
        "按照配置文件顺序依次包装（多层代理），而拦截顺序是反的。洋葱圈"
    - 其他
      - ${} 使用常见：分表查询时、排序升序降序...
      - Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略
- 缓存
  - 通用知识
    - 缓存三大问题 ankied
      - 穿透
        "查不存在的数据(如id=-1)，null不缓存，结果恶意分子并发查-1
        
        解决：存空对象"
      - 击穿
        "高并发查某个数据，同时打到数据库上了，导致数据奔溃
        
        解决：加锁
        
        怎么加锁？分布式锁。双重检查锁"
      - 雪崩
        "大量缓存同时过期，于是都打到数据库上了
        
        解决：过期时间取随机值"
  - Redis
    - 《Redis》深度历险 核心原理与应用实战 前文品 ankied
      - 基础&应用 ankied
        - 使用场景
          - 快速变化的数据（点击量）
          - 缓存--数据库压力大
          - 分布式锁
          - 分布式主键
        - 数据结构
          - 种类 - 5种
          - 可以设置过期时间？ 对
            "expire key num(s)"
          - string（key value）
            - 底层：可扩容数组（StringBuilder）
            - 插入 set k v
            - 获取 get k
            - 是否存在 exists k
            - 删除 del k
            - [数字] 当 v 是数字时，有自增操作
          - list
            - 底层：快速链表 quickList
              "数组 + 链表混合"
              - 压缩链表 zipList 成链
                "ZL<->ZL<->ZL<->ZL"
              - zipList？一个数组+前后指针
            - 左右插入 lpush/rpush k v
            - 左右取出 lpop/rpop k
            - 长度 llen
          - hash（key field value）
            - 底层：类似 HashMap（数组+桶挂链表）
            - 和 Java hashMap 区别？ rehash 操作
              "Java rehash 一次性完成
              redis 的 rehash 渐进完成，中途存在新旧两个 map，这是查询会同时访问两个map"
            - 放入 hset k f v
            - 长度 hlen
            - 查找 hget k f
            - 全部 hgetall k
            - 当 v 是整数时，支持自增
          - set（key value）
            - 底层：value 全是 null 的 hash
            - 插入 sadd k v
            - 全部 smembers k
            - 是否存在 sismember k v
            - 取出任意一个 spop k
            - [可选参数]
              - nx 不存在 k 时才会设置
              - ex 5  指定5秒过期
          - zset（key score value）
            - 底层：跳跃链表
              "一个节点有多个指针
              L0 指向下一个节点
              L1 下2个节点
              L2 指向下4个节点"
            - score 的数据类型？ double
            - 插入 zadd k s v
            - 获取范围内数据 zrange k i j
            - 范围是 0 -1，表示获取全部
            - 逆序范围获取 zrevrange k i j
            - 获取分数 zscore k v
            - 排名 zrank k v
            - 按分数范围获取 zrangebyscore k 0. 5.
            - 删除 zrem k v
          - 容器规则 - 看看
            - 插入元素时，若容器不存在，则创建
            - 删除元素后，若容器为空，则删除整个容器
        - 分布式锁
          - 痛点：同时对db的一个数据修改，会出现数据不一致
            "如同时对金额+10，可能最终只+10"
          - 方法：进入临界区前，先 set k v nx，出临界区 del k
            - nx 表示 if not exists ，不存在才会设置
          - 问题：异常时锁没有释放怎么办？
            "ex 5"
          - 怎么构建可重入锁？利用ThreadLocal<Map<Str,Int>>
            "Str 为锁名称，加锁时若锁存在，则Int++
            释放时，Int--，若Int=0则删除 Str"
        - 延时队列
          - 一句话：希望消息能t时间后再被消费
          - 使用场景
            - 订单 30min 不支付自动取消
          - 实现
            - Java 原生API DelayQueue
            - 利用 redis 的 zset
              - 存入时 score = 当前时间 + 延迟时间
              - 取出时 zrangebyscore 小于当前时间、最早的消息
        - 位图
          - redis 存在位图存储结构？——对的
          - 底层原理——就是 k v + 位操作
          - 使用场景
            - 记录用户一年签到情况
        - hyperLogLog
          - 是什么？基数估计算法
            "https://www.jianshu.com/p/55defda6dcd2
            
            一个流，输入元素，要能实时告诉我输入元素的基数
            
            什么是基数？可重复集合，去重后元素个数，如[1,1,2]基数=2
            
            这是一个估计算法"
          - 使用场景
            - 网页UV 统计
              "需要统计不同ip访问情况，不需要精确"
          - 核心算法
            "遍历元素，求hash，m = max(低位连续0数目)
            则数目 = 2^m
            
            为了降低不确定性，使用 桶+均值"
        - 布隆过滤器
          - 一句话：判断一个元素是否在集合中
          - 误判：若不存在，一定不存在；若存在，可能实际上不存在
          - 原理 hash + 位数组
            "利用不同的hash算法，对元素计算hash，位数组 hash%len 对应位置 1
            例如，使用3个hash算法，一般就会有三个位置1
            
            查询元素时，一样hash，查看3个对应位置是不是都是 1"
          - 使用场景
            - 新闻app刷新首页，不能出现重复
          - 使用方法
            "需要估计元素数目，以及设定错误率，就可以得到需要的位数组长度
            
            举例：9亿数据，0.1%错误率，需要1.5GB空间
            对比：9亿int数据，大小3.2GB"
        - 用户行为限流 ankied
          - 场景——贴吧回帖，5分钟内只允许回帖5次
          - 方法——有界队列
          - 漏斗限流
            - cl.throttle
        - GeoHash
          - 场景：查附近的人
          - 算法
            "把经纬度分别二分，变成字符串
            若两个位置的字符串，前序相同越多，就越靠近"
          - redis 提供 geo hash
        - 关于redis的key ankied
          - key 是字符串
          - 底层：所有的key都存在一个map中
            "不管 value 是 hash set zset..."
          - scan 命令
            "按照正则表达式，查找所有的key"
          - 要遍历一个hashMap，本质是？
            "遍历其中的 table 数组"
          - 希望遍历hashMap时，hash还可以扩容，扩容后，遍历可以继续，且不会遍历到重复的元素
            "按照 高位进位加法 遍历数据"
          - 高位进位加法？
            "000
            100
            010
            110
            001
            ...
            
            每次加100，向低位进位"
          - 希望能查找大key
            - 什么是大key，就是这个key的value占用空间大。业务中应避免产生大key
            - redis 提供了算法搜素大key
      - 原理篇 ankied
        - 线程IO模型
          "Redis 单线程 —— 多路复用IO"
        - IO协议
          "Redis 自己的文本协议 RESP"
        - 持久化
          - 三种方法——快照/日志/混合
          - 快照——对内存所有数据备份到磁场
            - 问1：制作快照时，redis还可以写吗？
              "答案：可以，运用了操作系统的COW copy on write"
            - 问2：什么是操作系统的 copy on write？
              "启动后，所有数据页设为 read only，这样CPU进行写时，会触发异常，操作系统此时把要写的页复制一份，之后的写操作就在复制的页上进行。（不影响内存快照）
              快照制作完毕后，把旧页释放即可。"
          - 日志——记录日志，恢复数据时重放即可
            - 日志可以瘦身？ 对。如果一个key被写两次，那就可以删除前一个日志
            - 日志可靠性——崩溃时，日志会不会还来不及写到磁盘中，而缺失？
              "答：如果flush了就不会，但是flush到磁盘这个操作很耗时，不可能每个写操作都flush，redis默认1s flush一次"
          - 混合——快照+增量日志
        - 事务
          - redis有事务吗？——有个半吊子事务。可以让多个指令不打断的执行，但是不能回滚
            "multi exec discard"
          - 原理：因为redis是单线程的，所有仅仅是连续执行这串指令
        - 乐观锁
          - redis 提供watch 一个key，实现乐观锁
            "watch后，对key操作，会查看"
      - 集群篇 ankied
      - 拓展篇 ankied
        - redis集群下的分布式锁
          - 问题：加锁后，锁所在节点挂了，且还没有同步到从节点，怎么办？
            "redlock 算法，多个节点加锁，少数服从多数"
        - 过期策略 两种
          - 懒过期
            "访问这个key时，发现过期，就删除"
          - 扫描
            "每秒10次扫描过期字典，每次扫20个，发现过期率高，就继续扫描"
        - 内存不够 策略
          - 停止写服务
          - LRU是Least Recently Used的缩写，即最近最少使用
            "淘汰最久没有使用的"
      - 源码篇 ankied
        - redis 字符串可变吗？——可
- web
  - Nginx
    - 简单安装
      - 随便启动一个实例 只是为了复制出配置文件
        "docker run -p 1111:1111 --name nginx -d nginx:1.10"
      - 建立要挂载的目录，并进入
        "/var/grainmall/docker/nginx/conf"
      - 从容器中复制文件
        "docker container cp nginx:/etc/nginx ../
        这一步不太好，把 conf 文件夹删除，把同级的 nginx 文件夹改名为 conf
        
        
        复制后
        ---------------
        conf.d  fastcgi_params  koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params  uwsgi_params  win-utf"
      - 停止并删除这个容器
      - 运行 nginx
        "docker run -p 20080:80 --name nginxGrain \
        -v /var/grainmall/docker/nginx/html:/usr/share/nginx/html \
        -v /var/grainmall/docker/nginx/logs:/var/log/nginx \
        -v /var/grainmall/docker/nginx/conf:/etc/nginx \
        -d nginx:1.10
        
        "
      - 测试 http://192.168.2.3:20080/ 
    - 配置学习
      - 总配置文件 nginx.conf
        "// 全局块。用户组、进程 pid
        user  nginx;
        worker_processes  1;
        
        error_log  /var/log/nginx/error.log warn;
        pid        /var/run/nginx.pid;
        
        // events 块
        events {
            worker_connections  1024;
        }
        
        // http 块
        http {
            include       /etc/nginx/mime.types;  // 支持的 web 类型
            default_type  application/octet-stream; // 默认返回数据类型
        
            log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                              '$status $body_bytes_sent "$http_referer" '
                              '"$http_user_agent" "$http_x_forwarded_for"'; // 日志格式
        
            access_log  /var/log/nginx/access.log  main; // 访问日志位置
        
            sendfile        on;
            #tcp_nopush     on;
        
            keepalive_timeout  65;
        
            #gzip  on; // 是否开启压缩
        
            include /etc/nginx/conf.d/*.conf; // 包含其他配置文件
        }
        "
      - 默认配置文件 conf.d/default.conf
        "包含到总配置文件中
        
        // server 块 虚拟主机相关信息
        server {
            listen       80; // 监听 80 端口
            server_name  localhost; // 利用域名监听。这个是利用 HTTP 请求头 HOST中读出来的
        
            #charset koi8-r;
            #access_log  /var/log/nginx/log/host.access.log  main; // 日志
        
            location / { // 请求映射
                root   /usr/share/nginx/html;
                index  index.html index.htm;
            }
        
            #error_page  404              /404.html; // 404页面 等
        
            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   /usr/share/nginx/html;
            }
        
            # proxy the PHP scripts to Apache listening on 127.0.0.1:80
            #
            #location ~ \.php$ {
            #    proxy_pass   http://127.0.0.1;
            #}
        
        
            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
            #
            #location ~ \.php$ {
            #    root           html;
            #    fastcgi_pass   127.0.0.1:9000;
            #    fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    include        fastcgi_params;
            #}
        
            # deny access to .htaccess files, if Apache's document root
            # concurs with nginx's one
            #
            #location ~ /\.ht {
            #    deny  all;
            #}
        }"
    - 反向代理 conf.d/gulimall.conf
      "server {
          listen       80; 
          server_name  gulimall.com; 
      
          #charset koi8-r;
          #access_log  /var/log/nginx/log/host.access.log  main;
      
          location / {
              proxy_pass http://192.168.2.13:35200;
          }
      
          error_page   500 502 503 504  /50x.html;
          location = /50x.html {
              root   /usr/share/nginx/html;
          }
      }"
    - 负载均衡
      - http/upstream
        "总配置文件 http 块下 upstream 块
        
        upstream gulimall {
            server 192.168.2.13:20088;
        }"
      - server/location/proxy_pass
        "server {
            listen       80; 
            server_name  gulimall.com; 
        
            #charset koi8-r;
            #access_log  /var/log/nginx/log/host.access.log  main;
        
            location / {
                proxy_pass http://gulimall;
            }
        
            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   /usr/share/nginx/html;
            }
        }"
    - 动静分离
      "server 块  
        location /static/ {
              root   /usr/share/nginx/html;
          }"
    - nginx 会默认丢弃很多请求头 丢请求头怎么办？
      "以 host 头为例
      server/location/proxy_set_header Host $host;"
  - 压力测试
    - 知识点
      - 目的：内存泄漏 并发
      - 指标
        - 响应时间
          - 最大响应时间
          - 最少响应时间
          - 90% 响应时间
        - 吞吐量
          - QPS 每秒查询数
          - HPS 每秒点击数
          - TPS 每秒交易数
            "互联网商城 TPS 一百万"
        - 错误率
    - JMeter的使用
      - jmeter.bat 启动
      - 创建测试计划
      - 添加线程（即用户）
        - 线程数目 200
        - ramp-up 1 表示1秒内启动200线程
        - 循环次数 100 每个线程发100个请求
      - 添加取样器 HTTP请求
      - 添加监听器 用于获取测试结果
        - 查看结果树
        - 汇总报告
        - 聚合报告
  - HTML & CSS
    - pink老师基础班教学(PC端基础知识->购物网站)
      "https://www.bilibili.com/video/av80149248"
      - HTML标签(上)
        "骨架
        常用标签"
      - HTML标签(下)
      - CSS层叠样式表 一
      - CSS 第二天
        - 简易小米侧边栏
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>简单小米侧边栏</title>
          </head>
          <style>
            .left-tab{
              width: 264px;
              background-color: #464646;
              color: white;
            }
            .left-tab .item{
              height: 50px;
              line-height:50px;
              cursor:pointer;
              color: white;
              text-align: left;
            }
            .left-tab .item:hover{
              background-color: orange;
            }
            .left-tab .left,.left-tab .right{
              width: 100px;
              float: left;
            }
            .left-tab .right{
              text-align: right;
              padding-right: 32px;
            }
            .left-tab .left{
              padding-left: 32px;
            }
          </style>
          <body>
          <div class="left-tab">
            <div class="item">
              <div class="left">手机 电话卡</div>
              <div class="right">&gt;</div>
            </div>
            <div class="item">
              <div class="left">电视 盒子</div>
              <div class="right">&gt;</div>
            </div>
            <div class="item">
              <div class="left">笔记本 平板</div>
              <div class="right">&gt;</div>
            </div>
            <div class="item">
              <div class="left">出行 穿戴</div>
              <div class="right">&gt;</div>
            </div>
            <div class="item">
              <div class="left">智能 路由器</div>
              <div class="right">&gt;</div>
            </div>
            <div class="item">
              <div class="left">健康 儿童</div>
              <div class="right">&gt;</div>
            </div>
          </div>
          </body>
          </html>
          "
        - 不要全部用div 用有语义的东西
        - margin padding 根据实际情况来用
      - 学成在线网页练习 - 累啊累啊累啊
        "http://www.like.bj.cn/#"
        - HTML
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>学成在线首页</title>
            <link rel="stylesheet" href="./style.css">
          </head>
          <body>
          <div class="header w">
            <div class="logo">
              <img src="http://www.like.bj.cn/images/logo.png" alt="学成在线log">
            </div>
            <div class="nav">
              <ul>
                <li><a href="#">首页</a></li>
                <li><a href="#">课程</a></li>
                <li><a href="#">职业规划</a></li>
              </ul>
            </div>
            <div class="search">
              <form method="get" action="javascript:void(0);">
                <input class="input" type="text" name="search" placeholder="请输入关键词">
                <input class="button" type="submit" value="🔍">
              </form>
            </div>
            <div class="user">
              <div class="img"></div>
              <div class="name">qq-lilei</div>
            </div>
          </div>
          <div class="banner">
            <div class="core w">
              <div class="subnav">
                <ul>
                  <li><a href="#">前端开发<span>&gt;</span></a></li>
                  <li><a href="#">后端开发<span>&gt;</span></a></li>
                  <li><a href="#">移动开发<span>&gt;</span></a></li>
                  <li><a href="#">人工智能<span>&gt;</span></a></li>
                  <li><a href="#">商业预测<span>&gt;</span></a></li>
                  <li><a href="#">云计算&amp;大数据<span>&gt;</span></a></li>
                  <li><a href="#">运维&amp;测试<span>&gt;</span></a></li>
                  <li><a href="#">UI设计<span>&gt;</span></a></li>
                  <li><a href="#">产品<span>&gt;</span></a></li>
                </ul>
              </div>
              <div class="course">
                <h2>我的课程表</h2>
                <div class="bd">
                  <ul>
                    <li><h4>继续学习 程序设计语言</h4><p>正在学习-使用对象</p></li>
                    <li><h4>继续学习 程序设计语言</h4><p>正在学习-使用对象</p></li>
                    <li><h4>继续学习 程序设计语言</h4><p>正在学习-使用对象</p></li>
                  </ul>
                  <a href="#">全部课程</a>
                </div>
              </div>
            </div>
          </div>
          <div class="goods w">
            <h3>精品推荐</h3>
            <ul>
              <li>JQuery</li>
              <li>JQuery</li>
              <li>JQuery</li>
              <li>JQuery</li>
              <li>JQuery</li>
            </ul>
            <a href="#">修改兴趣</a>
          </div>
          <div class="box w">
            <div class="box-hd">
              <h3>精品推荐</h3>
              <a href="#">查看全部</a>
            </div>
            <div class="box-bd">
              <ul class="clearfix">
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
                <li>
                  <img src="http://www.like.bj.cn/images/pic1.png" alt="item">
                  <h4>Think PHP 5.0 博客系统实战项目演练</h4>
                  <div class="info">
                    <span>高级</span>&nbsp;·&nbsp;1125人在学习
                  </div>
                </li>
          
          
              </ul>
            </div>
          </div>
          <div class="footer clearfix">
            <div class="button w">
              <div class="copyright">
                <img src="http://www.like.bj.cn/images/logo.png" alt="学成在线log">
                <p>文字文字文字文字文字文字文字文字文字文<br />文字文字文字文字文字文字文字文字文字文字文字文</p>
                <a href="#">下载APP</a>
              </div>
              <div class="links">
                <dl>
                  <dt>关于学成网</dt>
                  <dd>关于</dd>
                  <dd>关于aaaa</dd>
                  <dd>关于</dd>
                  <dd>关于</dd>
                </dl>
                <dl>
                  <dt>关于学成网</dt>
                  <dd>关于</dd>
                  <dd>关于aaaa</dd>
                  <dd>关于</dd>
                  <dd>关于</dd>
                </dl>
                <dl>
                  <dt>关于学成网</dt>
                  <dd>关于</dd>
                  <dd>关于aaaa</dd>
                  <dd>关于</dd>
                  <dd>关于</dd>
                </dl>
              </div>
            </div>
          </div>
          <div class="offset"></div>
          </body>
          </html>"
        - CSS
          "* {
              margin: 0;
              padding: 0;
          }
          
          body{
              background-color: #f3f5f7;
              /*height: 3000px;*/
          }
          
          .clearfix:before,.clearfix:after{
              content: "";
              display: table;
          }
          
          .clearfix:after{
              clear: both;
          }
          
          .clearfix{
              *zoom:1;
          }
          
          
          /*w->可视区域1200px，居中*/
          .w {
              width: 1200px;
              margin: auto;
          }
          
          li {
              /*整体清楚li的黑点*/
              list-style-type: none;
          }
          
          a {
              text-decoration: none;
          }
          
          /*-------------------------------------------头部区域------------------------------------*/
          
          .header {
              height: 42px;
              /*这里会覆盖w中的margin*/
              margin: 30px auto;
              /*background-color: pink;*/
          }
          
          .header .logo {
              float: left;
              width: 198px;
              height: 42px;
          }
          
          .header .nav {
              float: left;
              margin-left: 80px;
          }
          
          .header .nav ul li {
              float: left;
          
          }
          
          .header .nav ul li a {
              display: block;
              height: 26px;
              padding: 0 5px;
              line-height: 22px;
              margin: 10px 5px;
              font-size: 18px;
              color: #333;
          }
          
          .header .nav ul li a:hover {
              border-color: #00a4ff;
              border-style: solid;
              border-width: 0 0 1px 0;
              color: #00a4ff;
          }
          
          .search {
              display: block;
              float: left;
              /*width: 412px;*/
              height: 40px;
              margin: 1px 0 10px 80px;
              background-color: skyblue;
              border: 0;
          }
          
          .search .input {
              outline: none;
              float: left;
              width: 360px;
              height: 40px;
              border-style: solid;
              border-color: #00a4ff;
              border-width: 1px 0 1px 1px;
              font-size: 14px;
              padding-left: 14px;
          }
          
          .search .input:focus {
              outline: none;
              border-style: solid;
              border-color: #1ae4ff;
              border-width: 1px 0 1px 1px;
          }
          
          
          .search .button {
              outline: none;
              float: left;
              width: 42px;
              height: 42px;
              background-color: #00a4ff;
              border-style: solid;
              border-color: #00a4ff;
              border-width: 1px;
              font-size: 14px;
              color: white;
          }
          
          .search .button:hover {
              outline: none;
              cursor: pointer;
              background-color: #1ae4ff;
              border-color: #1ae4ff;
          }
          
          .user {
              float: right;
              height: 22px;
              margin: 10px 0 10px 50px;
          }
          
          .user .img {
              float: left;
              height: 22px;
              width: 22px;
              border-radius: 50%;
              background-color: red;
          }
          
          .user .name{
              float: left;
              margin-right: 40px;
              margin-left: 15px;
              height: 22px;
              font-size: 14px;
              line-height: 22px;
          }
          
          .user .img:hover{
              cursor: pointer;
              background-color: #ff5113;
          }
          
          .user .name:hover{
              cursor: pointer;
              color: #00a4ff;
          }
          
          /*-------------------------------------------banner------------------------------------*/
          .banner{
              height: 421px;
              background-color: #1c036c;
          }
          
          .banner .core{
              height: 421px;
              background-image: url("http://www.like.bj.cn/images/banner.jpg");
              background-repeat: no-repeat;
              background-position: top center;
          }
          
          .banner .subnav{
              float: left;
              height: 421px;
              width: 190px;
              background-color: rgba(0,0,0,0.3);
          
          }
          
          .banner .subnav ul li{
              line-height: 46px;
              height: 46px;
              padding: 0 20px;
          }
          
          .banner .subnav ul li a{
              font-size: 14px;
              color: white;
          }
          
          .banner .subnav ul li a:hover{
              color: #00a4ff;
          }
          
          .banner .subnav ul li a span{
              float: right;
          }
          
          .banner .course{
              float: right;
              width: 230px;
              height: 300px;
              margin-top: 50px;
              background-color: #fff;
          
          }
          
          .banner .course h2{
              height: 48px;
              background-color: #9bceea;
              line-height: 48px;
              font-size: 18px;
              color: white;
              text-align: center;
          }
          
          .banner .course .bd{
              padding: 0 20px;
              background-color: #fff;
          
          }
          
          .banner .course .bd ul li{
              padding: 15px 0;
              border-bottom: 1px solid #ccc;
          }
          
          .banner .course .bd ul li h4{
              font-size: 16px;
              color: #4e4e4e;
          
          }
          .banner .course .bd ul li p{
              font-size: 12px;
              color: #a5a5;
          }
          
          .banner .course .bd a{
              display: block;
              height: 38px;
              border: 1px solid #00a4ff;
              color: #00a4ff;
              background-color: white;
              line-height: 38px;
              text-align: center;
              font-size: 16px;
              font-weight: 700;
          }
          
          /*--------------------------------精品推荐1---------------------------*/
          
          .goods{
              height: 60px;
              margin-top: 10px;
              background-color: #fff;
              box-shadow: 0 2px 3px 3px rgba(0,0,0,0.1);
              line-height: 60px;
          }
          
          .goods h3{
              float: left;
              margin-left: 30px;
              margin-right: 30px;
              font-size: 16px;
              color: #00a4ff;
          
          }
          
          .goods ul{
              float: left;
          }
          .goods ul li{
              margin: 22px 0;
              line-height: 16px;
              float: left;
              padding: 0 30px;
              font-size: 16px;
              color: #050505;
              border-left: 1px solid gray;
          }
          
          
          .goods a{
              float: right;
              margin-right: 30px;
              font-size: 14px;
              color: #00a4ff;
          }
          
          /*--------------------------------精品推荐2---------------------------*/
          
          .box{
              margin-top: 30px;
          }
          .box .box-hd{
              height: 40px;
          }
          .box .box-hd h3{
              float: left;
              font-size: 20px;
              color: #494949;
          }
          .box .box-hd a{
              float: right;
              margin-top: 10px;
              margin-right: 30px;
              font-size: 12px;
              color: #a5a5a5;
          }
          .box .box-bd ul{
              width: 1300px;
          }
          .box .box-bd ul li{
              float: left;
              margin-right: 15px;
              margin-bottom: 15px;
              width: 228px;
              height: 270px;
              background-color:white;
          }
          
          .box .box-bd ul li img {
              width: 100%;
          }
          
          .box .box-bd ul li h4{
              margin: 20px 20px 20px 25px;
              font-size: 14px;
              color: #050505;
              font-weight: 400;
              line-height: 20px;
          }
          
          .box .box-bd ul li .info{
              margin: 0 20px 0 25px;
              /*text-align: center;*/
              color: #999;
              font-size: 12px;
          }
          .box .box-bd ul li .info span{
              color: #f2dc;
          }
          
          /*--------------------------------footer---------------------------*/
          .footer{
              /*height: 415px;*/
              background-color: white;
              margin-top: 30px;
          }
          
          .offset{
              height: 50px;
              background-color: white;
          }
          
          .footer .button{
              padding-top: 35px;
          }
          
          .footer .button .copyright{
              float: left;
          }
          
          .footer .button .copyright p{
              font-size: 12px;
              color: #666666;
              margin: 20px 0 15px 0;
          }
          
          .footer .button .copyright a{
              display: block;
              width: 118px;
              height: 33px;
              border: 1px solid #00a4ff;
              line-height: 33px;
              text-align: center;
              color: #00a4ff;
              font-size: 16px;
          
          }
          
          .footer .button .links{
              float: right;
          }
          .footer .button .links dl{
              float: right;
              margin-left: 100px;
          }
          
          .footer .button .links dl dt{
              margin-bottom: 5px;
              font-size: 16px;
              color: #333;
          }
          
          .footer .button .links dl dd{
              margin-bottom: 3px;
              font-size: 12px;
              color: #333;
          }
          
          
          
          
          "
      - H5C3
      - 品优购项目
        - 图片分类存放
          "样式类图片 -> images 文件夹
          产品图片 ->upload"
    - pink老师流式布局
      "https://www.bilibili.com/video/av83389484
      https://www.bilibili.com/video/av85991493"
    - 知识点总结
      - HTML
        - 骨架<!DOCTYPE、lang、charset
          - <!DOCTYPE html>
            "<!--文档类型声明标签，告诉HTML版本，这个代码表示版本是5-->
            <!--写在第一行-->"
          - <html lang="en">
            "<!--lang="en" 告诉搜索引擎，网页的语言-->"
          - <meta charset="UTF-8">
            "<!--  字符集-->"
        - 标题标签<h1>~<h6> 块级标签
        - 段落标签<p>
        - 换行标签<br />
        - 文本格式化标签<加粗b/strong><斜线i/em><下划线u/ins><删除线s/del>
        - 盒子<div><span>
        - 图像<img src="url" ⭐alt="替换文本" title="鼠标于上显示" width=px height=px border=边框粗细px>
          "width 和 height 只修改一个，会等比例缩放"
        - 超链接<a href="url" target="⭐">
          "target -> 网页打开的未知
          默认值 "_self" 
          "_blank" 在新窗口打开
          
          tip
          --------
          a 是anchor 锚"
          - 锚点链接
            "<锚点 id="abc">
            <a href="#abc">"
        - 表格
          - 基本<table><tr><td>
          - 表头<th> （默认加粗居中）
          - <thead> 头部区域 -> 注意和<th>区分
            "<table>
            <thead>
            <tr><th>XXXX<th><th>XXXX<th></tr>
            </thead>
            </table>"
          - <tbody> 主体区域
          - 属性 @Deprecated (以后用CSS实现) 写在<table>
            "align = left right center
            border 1
            cellpadiing
            cellspacing
            witdth"
        - 列表
          - 无序<ul><li>
          - 有序<ol><li>
          - 自定义列表<dl><dt><dd>
            "<dl>
              <dt>主题</dt>
              <dd>解释1</dd>
              <dd>解释2</dd>
              <dt>主题</dt>
              <dd>解释1</dd>
              <dd>解释2</dd>
            </dl>"
        - 表单
        - 特殊字符
          "空格 &npsP;
          大于小于 &lt; &gt;"
      - CSS 层叠样式表
        "层叠性
        继承性 - 特殊 行高的继承 1.5 可以继承行高为文字的1.5倍，可以继承
        优先级 数字化...复合选择器权重叠加"
        - 选择器
          "HTML标签——直接写
          类——.类名
          
          基本选择器
          复合选择器
          
          后代选择器（常用）：选择父元素下的各代子元素
          	ol li{} // 空格隔开	
          	可以继续往后走 a b c
          
          子代选择器：只选择第一代孩子（不选孙子）
          	ol > li {} // 只选择第一代孩子
          
          并集选择器（常用）：选择多个元素
          	div, 
          	p {} //一般竖着写
          
          "
          - 伪类选择器: ⭐注意顺序
            "a:lick {} //未访问
            a:visited {}
            a:hover {}
            a:active {} //鼠标按下未弹起
            ⭐四个顺序不能变 LVHA
            
            a 元素的样式，不会继承父元素
            
            ------------
            悬浮变色
            div:hover{color: red;}"
            - 开发中a标签常用写法
              "a {
                color: #333;
                text-decoration: none;
              }
              
              a:hover {
                color: #369;
              }"
            - :focus 获取焦点的表单元素
            - cursor 鼠标样式
              "default 默认交投
              pointer 小手
              move 移动 十字键头
              text 文字 一个I字母
              not-allowed 禁止 红色"
        - 文字
          - font-size: 12px 大小 (默认像素16px)
          - font-family: 字体
          - font-weight: bold/lighter 字体粗细 也可以用数字 bold=700 normal=400 
          - font-style: italic 斜体 -> 开发中用的少
          - color 颜色 rgb0() rgb()
          - text-align: center 水平对齐  仅仅水平
          - text-decoration: 下划线underline、line-through删除线、上划线
            "一般用于取消a标签的下划线"
          - text-indent: 10px/2em文本缩进 (em->当前文字大小作为单位)
          - line-height: 行间距 行间距=文字高度+上间距+下间距
          - 文字阴影 text-shadow
            "水平距离
            垂直距离
            模糊距离
            颜色"
          - 溢出文字省略号
            - 一行文本溢出 三步走
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>溢出</title>
                <style>
                  .single{
                    width: 200px;
                    /*强制文字不换行*/
                    white-space: nowrap;
                    /*超出部分隐藏*/
                    overflow: hidden;
                    /*超出文字省略号*/
                    text-overflow: ellipsis;
                  }
                </style>
              </head>
              <body>
              <div class="single">一行文字踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩从</div>
              </body>
              </html>"
            - 多行文本溢出 (两行溢出) 不兼容! 推荐后台来做
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>溢出</title>
                <style>
                  .single{
                    width: 200px;
              
                    display: -webkit-box;
              
                    -webkit-line-clamp: 2;
              
                    -webkit-box-orient: vertical;
              
                    /*超出部分隐藏*/
                    overflow: hidden;
                    /*超出文字省略号*/
                    text-overflow: ellipsis;
                  }
                </style>
              </head>
              <body>
              <div class="single">一行文字踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩从一行文字踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩踩从</div>
              </body>
              </html>"
        - 表格
          - border 表格边框
          - border-collapse: 合并相邻的边框
            "防止边框相连导致过粗"
        - 表单 轮廓×
          - 轮廓线 outline: none; 一般都设置不要
          - 文本域textarea防止拖拽 resize: none; 
        - 盒子
          "块元素 默认宽度：所在盒子的宽度
          行内元素 高度宽度的设置无效
          
          行内块元素 img input td 具有行和块的元素 可以设置高度宽度 "
          - 把行元素转化为块元素
            "display: block; 反向转化display: inline 行内块元素 display: inline-block;
            -------------
            a {
              width: 200px;
              height: 50px;
              background-color: yellow;
              display: block;
            }"
          - 背景相关
            - 背景颜色 background-color: blue;  默认transparent 同名
            - CSS3 背景颜色半透明 
            - 背景图片 background-image: url("/") //平铺、位置、附着
              "常用 因为容器控制位置 精灵图？
              
              背景图片平铺 background-repeat: no-repeat;
              
              图片位置 background-position: center right; // 也可以精确单位px
              
              附着 background-attachment: scroll fixed//视差滚动
              
              
              rgba(0,0,0,0.3) ->颜色透明"
            - 背景图片大小 background-size: xpx ypx;//只写一个等比缩放、也可以用%
              "cover 完全覆盖，等比缩放 （可能会超出）
              contain 完全包含，等比缩放（可能会有空白）"
          - 盒子模型⭐div的width&height指内容大小
            - 单个盒子 margin border padding 圆角 阴影
              - 外边距 margin-
              - 边框 border-
                "width
                style 样式 solid
                color"
              - 内边距 padding-
                "就上下左右"
              - 关于margin: auto / margin:0 auto
                "auto：水平（默认）书写模式下，margin-top/margin-bottom计算值为0，margin-left/margin-right取决于可用空间。
                
                ------------------
                margin:auto=margin:auto auto auto auto，表示上下左右都为auto；margin:0 auto=margin:0 auto 0 auto，表示上下为0，左右为auto；
                
                margin:auto表示横竖都居中，margin: 0 auto表示横居中，竖不居中；"
              - 圆角边框 border-radius: 10px;
                "圆形：
                width: 50px;
                height: 50px;
                border-radius: 50%; = 25px"
              - 盒子阴影 box-shadow
                "div{
                  box-shadow: 10px 10px 10px 10px rgba(0,0,0,0.3) ;
                //水平阴影位置
                //垂直阴影位置
                //模糊距离
                //阴影尺寸
                //颜色
                }"
            - 浮动 float —— 用于PC段排版
              "PC端传统布局方式：
              	普通流/标准流/文档流
              	浮动
              	定位
              
              浮动元素
              	脱离标准流(脱标)，不再保留原来的位置
              	不浮动的元素会占据位置，压住浮动的盒子
              	不影响前面的标准流
              
              	浮动的元素，会紧紧贴一起。顶端对齐
              	浮动元素具有行内块元素特性
              
              	浮动元素经常和标准流的父亲搭配使用 ⭐
              	父盒子的高度一般不给，让子孩子撑起来
              	高度坍塌？ ——啊!?
              	父盒子不给高度，而子盒子浮动但是不占位置。最后父盒子高度为0，就会影响下面的标注流
              
              小知识：浮动最开始的目的是为了文字围绕图片
              
              
              占据
              -----------
              <!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>float</title>
                <style>
                  div{
                    width: 200px;
                    height: 200px;
                    background-color: pink;
                  }
                  .left{
                    float: left;
                  }
                  .right{
                    float: right;
                  }
                  .fixed{
                    width: 500px;
                    height: 500px;
                    background-color: yellow;
                  }
                </style>
              </head>
              <body>
              <div class="left">left1</div>
              <div class="left">left2</div>
              <div class="right">right3</div>
              <div class="right">right4</div>
              <div class="fixed">不浮动</div>
              </body>
              </html>"
              - 回顾：普通流/标准流/文档流
                "块元素占一行
                行元素 遇到父元素边界换行"
              - float: left / right 左右开始流动
                "<!DOCTYPE html>
                <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <title>float</title>
                  <style>
                    div{
                      width: 200px;
                      height: 200px;
                      background-color: pink;
                    }
                    .left{
                      float: left;
                    }
                    .right{
                      float: right;
                    }
                  </style>
                </head>
                <body>
                <div class="left">left1</div>
                <div class="left">left2</div>
                <div class="right">right3</div>
                <div class="right">right4</div>
                </body>
                </html>"
              - 清除浮动，防止高度坍塌 clear: both;
                "父盒子的高度一般不给，让子孩子撑起来
                	高度坍塌？ ——啊!?
                	父盒子不给高度，而子盒子浮动但是不占位置。最后父盒子高度为0，就会影响下面的标注流
                	这时需要清楚浮动，清楚浮动对标注流的影响"
                - 高度坍塌示例代码
                  "<!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>clear</title>
                    <style>
                      .fa{
                        width: 1000px;
                        background-color: pink;
                        margin: 20px auto;
                      }
                      .so{
                        float: left;
                        width: 200px;
                        height: 200px;
                        background-color: red;
                        margin: 20px;
                      }
                      .next{
                        width: 1000px;
                        height: 500px;
                        background-color: black;
                        margin: 20px auto;
                      }
                    </style>
                  </head>
                  
                  <body>
                  <div class="fa">
                    <div class="so">1</div>
                    <div class="so">2</div>
                  </div>
                  <div class="next">next</div>
                  </body>
                  </html>"
                - 额外标签法//书写方便 有无意义标签 @Deprecated 
                  "在最后一个元素 + 空div标签
                  样式clear: both
                  
                  代码
                  -------------
                  <!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>clear</title>
                    <style>
                      .fa{
                        width: 1000px;
                        background-color: pink;
                        margin: 20px auto;
                      }
                      .so{
                        float: left;
                        width: 200px;
                        height: 200px;
                        background-color: red;
                        margin: 20px;
                      }
                      .next{
                        width: 1000px;
                        height: 500px;
                        background-color: black;
                        margin: 20px auto;
                      }
                      .extra{
                        clear: both;
                      }
                    </style>
                  </head>
                  
                  <body>
                  <div class="fa">
                    <div class="so">1</div>
                    <div class="so">2</div>
                    <div class="extra"></div>
                  </div>
                  <div class="next">next</div>
                  </body>
                  </html>"
                - 父元素 overflow 简洁，但是溢出隐藏
                  "hidden wuto scroll 均可
                  
                  代码
                  -----------------------
                  <!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>clear</title>
                    <style>
                      .fa{
                        /*overflow: auto;*/
                        /*overflow: hidden;*/
                        /*overflow: scroll;*/
                        width: 1000px;
                        background-color: pink;
                        margin: 20px auto;
                      }
                      .so{
                        float: left;
                        width: 200px;
                        height: 200px;
                        background-color: red;
                        margin: 20px;
                      }
                      .next{
                        width: 1000px;
                        height: 500px;
                        background-color: black;
                        margin: 20px auto;
                      }
                    </style>
                  </head>
                  
                  <body>
                  <div class="fa">
                    <div class="so">1</div>
                    <div class="so">2</div>
                  </div>
                  <div class="next">next</div>
                  </body>
                  </html>"
                - 父元素 :after伪元素 百度/淘宝 都是用这个办法
                  "代码
                  --------------------
                  <!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>clear</title>
                    <style>
                      .fa{
                        width: 1000px;
                        background-color: pink;
                        margin: 20px auto;
                      }
                      .fa:after{
                        content: "";
                        display: block;
                        height: 0;
                        clear: both;
                        visibility: hidden;
                      }
                      .so{
                        float: left;
                        width: 200px;
                        height: 200px;
                        background-color: red;
                        margin: 20px;
                      }
                      .next{
                        width: 1000px;
                        height: 500px;
                        background-color: black;
                        margin: 20px auto;
                      }
                    </style>
                  </head>
                  
                  <body>
                  <div class="fa">
                    <div class="so">1</div>
                    <div class="so">2</div>
                  </div>
                  <div class="next">next</div>
                  </body>
                  </html>"
                - 双伪元素 小米/腾讯使用
                  "代码
                  -------------
                  <!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>clear</title>
                    <style>
                      .fa{
                        width: 1000px;
                        background-color: pink;
                        margin: 20px auto;
                      }
                      .fa:after,.fa:before{
                        content: "";
                        display: block;
                        height: 0;
                        clear: both;
                        visibility: hidden;
                      }
                      .so{
                        float: left;
                        width: 200px;
                        height: 200px;
                        background-color: red;
                        margin: 20px;
                      }
                      .next{
                        width: 1000px;
                        height: 500px;
                        background-color: black;
                        margin: 20px auto;
                      }
                    </style>
                  </head>
                  
                  <body>
                  <div class="fa">
                    <div class="so">1</div>
                    <div class="so">2</div>
                  </div>
                  <div class="next">next</div>
                  </body>
                  </html>"
            - 定位 = 模式position + 边偏移(上下左右)
              "为了让盒子可以自由的固定在某个位置
              还可以压住其他盒子
              
              将盒子定在某个位置"
              - position: static; 默认状态=无定位=不脱离标准流
              - position: relative; 相对于自己原来的位置移动 保留原来位置->不脱标->下一个元素认为它还在原地
                "如top:100px则相对于原来位置下移100px"
                - 示例
                  "<!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>定位</title>
                    <style>
                      .d01{
                        position: relative;
                        top: 50px;
                  
                  
                        height: 100px;
                        width: 100px;
                        background-color: pink;
                      }
                      .d02{
                        height: 200px;
                        width: 200px;
                        background-color: red;
                      }
                    </style>
                  </head>
                  <body>
                  
                  <div class="d01"></div>
                  <div class="d02"></div>
                  
                  </body>
                  </html>"
              - position: absolute; 脱离标准流、子绝父相
                - 没有父元素or父元素没有定位->以body为准对齐 @Deprecated 
                - 父元素有定位->安装父元素为准对齐
                  "<!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>定位</title>
                    <style>
                      body{
                        height: 3000px;
                        background-color:gray;
                      }
                      .fa{
                        position: relative;
                        height: 500px;
                        width: 500px;
                        background-color: pink;
                      }
                      .son{
                        position: absolute;
                        width: 100px;
                        height: 100px;
                        bottom: 10px;
                        right: 10px;
                        background-color: red;
                      }
                    </style>
                  </head>
                  <body>
                  
                  <div class="fa">
                    <div class="son"></div>
                  </div>
                  
                  </body>
                  </html>"
                - 绝对定位元素的居中
                  "left: 50%;
                  margin-left: -width/2; //负数走回来"
              - position: fixed; 固定在屏幕上->脱标
                "以浏览器可视窗口作为定位"
                - 小技巧：固定在版心右侧，不贴屏幕右侧
                  "left: 50%;
                  margin-left: 1200/2px;"
              - position: sticky;  ->fixed+relative 但是一般用JS完成
                "首先可以动，到了边缘就不动了"
                - 示例
                  "<!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>粘性定位</title>
                    <style>
                      body{
                        height: 3000px;
                      }
                      div{
                        position: sticky;
                        height: 100px;
                        /*width: 300px;*/
                        top: 0;
                        margin: 0 auto;
                        background-color: pink;
                      }
                      h1{
                        text-align: center;
                      }
                    </style>
                  </head>
                  <body>
                  <h1>..............大标题..............</h1>
                  <div>我先动动，然后停在顶部</div>
                  <h2>其他内容1</h2>
                  <h2>其他内容2</h2>
                  <h2>其他内容3</h2>
                  <h2>其他内容4</h2>
                  <h2>其他内容5</h2>
                  <h2>其他内容6</h2>
                  <h2>其他内容7</h2>
                  <h2>其他内容8</h2>
                  <h2>其他内容9</h2>
                  <h2>其他内容10</h2>
                  <h2>其他内容11</h2>
                  <h2>其他内容12</h2>
                  <h2>其他内容13</h2>
                  <h2>其他内容14</h2>
                  <h2>其他内容15</h2>
                  <h2>其他内容16</h2>
                  <h2>其他内容17</h2>
                  <h2>其他内容18</h2>
                  <h2>其他内容19</h2>
                  <h2>其他内容20</h2>
                  </body>
                  </html>"
              - top/bottom 距离父元素上/下
              - left/right 距离父元素左/右
              - z-index 叠放顺序
            - 隐藏
              - display: none 脱标->后来元素会占用
                "<!DOCTYPE html>
                <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <title>Title</title>
                  <style>
                    div{
                      height: 500px;
                      width: 500px;
                    }
                
                    .d0{
                      display: none;
                      background-color:greenyellow;
                    }
                
                    .d1{
                      background-color: purple;
                    }
                  </style>
                </head>
                <body>
                <div class="d0"></div>
                <div class="d1"></div>
                </body>
                </html>"
                - 神代码：父元素hovere 子元素显示
                  ".fa:hover .son{
                    display: block;
                  }"
              - visibility: hidden/visible; 占用位置->后续元素不会上去 (用得少)
                "<!DOCTYPE html>
                <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <title>Title</title>
                  <style>
                    div{
                      height: 500px;
                      width: 500px;
                    }
                
                    .d0{
                      /*display: none;*/
                      visibility: hidden;
                      background-color:greenyellow;
                    }
                
                    .d1{
                      background-color: purple;
                    }
                  </style>
                </head>
                <body>
                <div class="d0"></div>
                <div class="d1"></div>
                </body>
                </html>"
              - overflow
                - overflow: visible; 默认情况，会超出盒子
                  "<!DOCTYPE html>
                  <html lang="en">
                  <head>
                    <meta charset="UTF-8">
                    <title>溢出</title>
                    <style>
                      div{
                        width: 200px;
                        height: 200px;
                        border: 2px solid red;
                        margin: 50px auto;
                  
                        overflow: visible;
                      }
                    </style>
                  </head>
                  <body>
                  
                  <div>
                    四川省地震局快速贯彻，立即召开紧急会议部署落实，指派当地有关部门和群测群防人员深入震区调查了解震情灾情，组织专家进行震情紧急分析会商，派出由一名副局长带队的现场工作队连夜出发前往震区协同当地政府抗震救灾。
                  
                    据了解，截至目前，震区尚无人员死亡情况报告，交通、通讯情况正常。
                  
                    凌晨，有多少成都人的睡梦被一场地震惊醒？
                  
                    2月3日0点5分，一阵剧烈的摇晃之后，“地震了”的消息瞬间刷爆朋友圈。成都人“肉测”出这场地震的震级“应该不低”。
                  
                    随后，来自中国地震台网的测定更让不少人感到吃惊。根据测定，此次地震发生在青白江区，震级5.1级，震源深度21千米，震中位于北纬30.74度，东经104.46度。
                  
                    这里怎么会发生地震呢？根据四川省地震局深夜发布的消息，此次地震发生在龙泉山断裂带，震中距离金堂县城14公里，距离青白江城区25公里，距离成都市区38公里。
                  
                    随着地震的发生，一场极速响应的应急行动也随之展开了。
                  </div>
                  
                  </body>
                  </html>"
                - overflow: auto; 需要时盒子内生成滚动条 (不好用)
                - overflow: scroll; 生成滚动条 (不好用)
                - overflow: hidden; 超出部分隐藏
        - CSS高级
          - 精灵图 sprites
            "把一堆小图片放到大图片中，这样可以防止频繁请求服务器
            减少发送请求的次数
            
            王者荣耀网站的精灵图
            https://game.gtimg.cn/images/yxzj/web201706/images/comm/index.png
            
            之后得div得background-position 就可以显示需要的部分了
            一般往上往左移动 是负数"
            - 示例
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>精灵图</title>
                <style>
                  .box{
                    width: 60px;
                    height: 60px;
                    /*background-color: pink;*/
                    margin: 100px auto;
                    background-image: url("https://game.gtimg.cn/images/yxzj/web201706/images/comm/index.png");
                    background-repeat: no-repeat;
                    background-position: -182px 0;
                  }
                </style>
              </head>
              <body>
              
              <div class="box"></div>
              <hr>
              <img src="https://game.gtimg.cn/images/yxzj/web201706/images/comm/index.png" alt="精灵图">
              
              </body>
              </html>"
          - 字体图标 iconfont
            "就是文字一行中显示一个小图片，类似
            🔍搜索
            
            看上去像图片，但是用起来像文字
            
            -----------------------------------
            第一步：
            https://icomoon.io/
            下载
            
            第二步：
            把其中fonts文件夹复制到网页同级目录
            
            第三步：
            CSS 加入：
                @font-face {
                  font-family: 'icomoon';/*名字可以自己取*/
                  src: url('fonts/icomoon.eot?7kkyc2');
                  src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
                  url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
                  url('fonts/icomoon.woff?7kkyc2') format('woff'),
                  url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
                  font-weight: normal;
                  font-style: normal;
                }
            
            使用时用，加入 font-family: 'icomoon';
            注意真实的文字可以从下载的demo.html中复制 ：
            
            使用
            -----------------
            <!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>Title</title>
              <style>
                @font-face {
                  font-family: 'icomoon';/*名字可以自己取*/
                  src: url('fonts/icomoon.eot?7kkyc2');
                  src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
                  url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
                  url('fonts/icomoon.woff?7kkyc2') format('woff'),
                  url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
                  font-weight: normal;
                  font-style: normal;
                }
            
                .icon{
                  color: red;
                  font-family: 'icomoon';
                }
              </style>
            </head>
            <body>
            <div>
              <span class="icon"></span><span>&lt;-这是字体图标？</span>
            </div>
            </body>
            </html>
            ------------------
            "
          - 三角形 ▲ 真的强 -> 然后父相子绝就可以定位了
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>三角形</title>
              <style>
                .box{
                  width: 0;
                  height: 0;
                  /*border: 10px solid pink;*/
                  border-style: solid;
                  border-width: 10px;
                  border-color: pink red blue orange;
                }
              </style>
            </head>
            <body>
            <div class="box">
            
            </div>
            </body>
            </html>"
            - 直角三角形
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>04-直角三角形</title>
                <style>
                  div{
                    height: 0;
                    width: 0;
                    border-top: 100px solid red;
                    border-right: 50px solid pink;
                    border-bottom: 0 solid black;
                    border-left: 50px solid orange;
                  }
                </style>
              </head>
              <body>
              
              <div>
              </div>
              
              </body>
              </html>"
          - vertical-align: middle; 行内块/行元素的垂直居中
            "一般用于图片和文字同一行
            
            默认基线对齐"
          - CSS 初始化
            "以京东首页为例
            -----------
            * {
                margin: 0;
                padding: 0;
            }
            
            em,
            i {
                font-style: normal;
            }
            
            img {
                border: 0;
                /*取消图片底部有空隙的问题*/
                vertical-align: middle;
            }
            
            li {
                list-style-type: none;
            }
            
            button {
                cursor: pointer;
            }
            
            a {
                color: #666;
                text-decoration: none;
            }
            
            a:hover {
                color: red;
            }
            
            button,
            input {
                /*//*/
            }
            
            body {
                /*文字抗锯齿*/
                -webkit-font-smoothing: antialiased;
                background-color: #fff;
                font: 12px/1.5 "Microsoft YaHei UI";
                color: #666;
            }
            
            .hide,
            .none {
                display: none;
            }
            
            .clearfix:after {
                visibility: hidden;
                clear: both;
                display: block;
                content: "";
                height: 0;
            }
            
            .clearfix {
                *zoom: 1;
            }
            
            
            "
      - HTML 5
        - 语义化标签 （移动端常用）
          "header 头部
          nav 导航
          article 内容
          section 文档某区域
          aside 侧边栏
          footer 尾部"
        - 多媒体标签
          - audio 尽量使用mp3格式
          - video 尽量使用mp4格式
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>video</title>
              <style>
                video {
                  width: 50%;
                }
              </style>
            </head>
            <body>
            
            <div>
              <video src="http://i1.mifile.cn/f/i/2019/mi9pro/video-03.mp4"
                     autoplay="autoplay" muted="muted"
                     controls="controls"
              ></video>
            </div>
            
            </body>
            </html>"
        - input新类型 限制用户输入视频 —— 移动端也可以
          - type="search" 语义上好一些
          - email url date time month week number tel color。。。
          - required 属性 必须填写
          - autofocus 打开页面获得焦点
          - autocomplete = off 不要记录输入历史
      - CSS 3 (移动端支持很好)
        - 新的选择器
          - 属性选择器 标签[属性] -> 表示选择"标签"中包含"属性"的
            "E[attr] 包含属性
            E[attr='value'] 有属性且值是
            E[]"
          - 结构伪类选择器 选择子元素（第几个...）
            "E:first-child/last-child
            E:last-of-type
            nth-child(n/2n/5n/2n+1/n+5/-n+5)"
          - 伪元素选择器 利用CSS新建标签 从而简化HTML结构
            "创建的元素在DOM里面找不到 所以称为伪元素"
            - ::before 在元素内部的前面插入内容
              "（尽量使用双冒号::）"
            - ::after 在元素内部的后面插入内容(float: right?)
            - 示例
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>伪元素</title>
                <style>
                  div{
                    position: relative;
                    height: 100px;
                    width: 200px;
                    background-color: pink;
                    margin: 0 auto;
                  }
              
                  div::before{
                    content: "before";
                    position: absolute;
                    top: 50%;
                    margin-top: -10px;
                    background-color: gray;
                    display: block;
                    width: 80px;
                    height: 20px;
                    font-size: 16px;
                    line-height: 20px;
                    text-align: center;
                  }
              
                  div::after{
                    content: "after";
                    position: absolute;
                    top: 50%;
                    margin-top: -10px;
                    right: 0;
                    background-color: greenyellow;
                    display: block;
                    width: 80px;
                    height: 20px;
                    font-size: 16px;
                    line-height: 20px;
                    text-align: center;
                  }
                </style>
              </head>
              <body>
              <div>father</div>
              </body>
              </html>"
            - 选择 E:hover::before
        - 盒子模型 box-sizing
          - box-sizing: border-box;
            "盒子边框可以算在宽高之中
            这样防止设置宽高增大盒子
            
            示例：
            -------------------------
            <!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>box-size</title>
              <style>
                div{
                 box-sizing: border-box;
                  width: 100px;
                  height: 100px;
                  border: 5px solid gray;
                  background-color: pink;
                }
              </style>
            </head>
            <body>
            <div></div>
            </body>
            </html>"
          - width: calc
        - 图片模糊 filter: blur(5px)
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>blur</title>
            <style>
              img{
                filter: blur(2px);
                width: 200px;
              }
              img:hover{
                filter: blur(0);
              }
            </style>
          </head>
          <body>
          <img src="https://pic1.zhimg.com/v2-a8a0de37812e5470d509e915927dc34c_540x450.png" alt="模糊">
          </body>
          </html>"
        - 计算 width: calc(100% - 80px) -> 永远比父盒子小80px
        - 过渡(补间动画) transition: 要过度的属性 时长/s 曲线 何时开始
          - 曲线：变化的速度
            "linear 匀速
            ease 先快后慢
            ease-in 一直加速
            ease-out 先快后面
            ease-in-out 先加速后减速"
          - 全部过度all/多个过度 "要过度的属性 时长, 要过度的属性 时长.."
            "逗号分隔"
          - 颜色变化 - 示例
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>Title</title>
              <style>
                div{
                  width: 200px;
                  height: 100px;
                  background-color:pink;
                  transition: background-color 0.5s;
                }
                div:hover{
                  background-color: red;
                }
              </style>
            </head>
            <body>
            <div></div>
            </body>
            </html>"
          - 大小变化 - 示例
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>Title</title>
              <style>
                div{
                  width: 200px;
                  height: 100px;
                  background-color:pink;
                  transition: width 0.5s;
                }
                div:hover{
                  width: 400px;
                }
              </style>
            </head>
            <body>
            <div></div>
            </body>
            </html>"
          - 进度条 完美效果
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>12-进度条</title>
              <style>
                .bar {
                  position: relative;
                  width: 150px;
                  height: 15px;
                  border: 1px solid red;
                  border-radius: 7px;
                  padding: 1px 0 1px 0;
                  background-color: transparent;
                }
            
                .bar-in {
                  position: absolute;
                  top: -1px;
                  left: -1px;
                  width: 20%;
                  height: 100%;
                  border: 1px solid transparent;
                  border-radius: 7px 0 0 7px;
                  background-color: #ff5f44;
                  transition: width 0.5s ease 0s, border-radius 0.3s ease 0.2s;
                  z-index: -1;
                }
            
                .bar:hover .bar-in{
                  width: calc(100% - 1px);
                  border-radius: 7px;
                }
              </style>
            </head>
            <body>
            <div class="bar">
              <div class="bar-in"></div>
            </div>
            </body>
            </html>"
          - 弹幕 文字飞过 - 示例 overflow: hidden; + 父相子绝
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>文字飞过</title>
              <style>
                .window{
                  position: relative;
                  height: 30px;
                  width: 60px;
                  border: 1px solid pink;
                  margin: 20px auto;
                  overflow: hidden;
                }
            
                .window .info{
                  position: absolute;
                  height: 30px;
                  width: 300px;
                  left: 0;
                  white-space: nowrap;
                  border: 1px solid transparent;
                  top: -1px;
                  line-height: 30px;
                  transition: left 2s;
                  font-size: 10px;
                }
            
                .window:hover .info{
                  left: -240px;
                }
              </style>
            </head>
            <body>
            <div class="window">
              <div class="info">文字飞过文字飞过文字飞过</div>
            </div>
            </body>
            </html>"
        - 2D 转换 transform (移动translate 旋转rotate 缩放scale)
          - 不会影响其他盒子、可以配合动画transition
          - transform: translate(x px,y px);
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>2D位移</title>
              <style>
                div{
                  height: 100px;
                  width: 100px;
                  background-color: pink;
                }
            
                div:hover{
                  transform: translate(10px,10px);
                }
              </style>
            </head>
            <body>
            <div></div>
            </body>
            </html>"
            - 参数：50% 表示盒子的自身宽高的50%
          - transform: rotate(30deg); 正值顺时针(和数学相反)
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>2D位移</title>
              <style>
                div{
                  height: 100px;
                  width: 100px;
                  background-color: pink;
                  transition: all 0.2s;
                }
            
                div:hover{
                  transform: rotate(30deg);
                }
              </style>
            </head>
            <body>
            <div></div>
            <h1>文字</h1>
            </body>
            </html>"
          - transform: scale(x倍率, y倍率);
            - 框框内文字放大
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>scale</title>
                <style>
                  .box{
                    position: relative;
                    margin: 100px;
                    height: 20px;
                    width: 40px;
                    border: 1px solid pink;
                    overflow: hidden;
                    z-index: 2;
                  }
              
                  .clearfix:before,.clearfix:after{
                    content: "";
                    display: table;
                  }
              
                  .clearfix:after{
                    clear: both;
                  }
              
                  .clearfix{
                    *zoom:1;
                  }
              
                  .info{
                    font-size: 16px;
                    line-height: 20px;
                    position: absolute;
                    /*top:5px;*/
                    transition: all 0.5s;
                    /*border: 1px black dashed;*/
                    z-index: 1;
                  }
              
                  .box:hover .info{
                    transform: scale(1.5,1.5);
                  }
                </style>
              </head>
              <body>
              <div class="box clearfix">
                <div class="info">文字</div>
              </div>
              </body>
              </html>"
        - 动画 ->定义 + 使用
          - @keyframes name{0%{}...} + animation-name: name; + animation-duration: 2s;
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>动画</title>
              <style>
                @keyframes move {
                  0%{
                    transform: scale(1);
                  }
                  50%{
                    transform: scale(1.5);
                  }
                  100%{
                    transform: scaleX(1);
                  }
                }
            
                div{
                  height: 200px;
                  width: 200px;
                  background-color: pink;
                  margin: 100px auto;
                  animation-name: move;
                  animation-duration: 2s;
                }
              </style>
            </head>
            <body>
            <div></div>
            </body>
            </html>"
          - 重复：animation-iteration-count: infinite
          - 速度曲线 timing-function
          - 开始事件 delay
          - 案例：热点图
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>热点图</title>
              <style>
                @keyframes large {
                  0%{
                    transform: scale(0.1,0.1);
                    border-color: transparent;
                  }
            
                  50%{
                    transform: scale(1,1);
                    border-color: red;
                  }
            
                  100%{
                    transform: scale(2,2);
                    border-color: transparent;
                  }
                }
            
                .box{
                  position: relative;
                  background-image: url("https://pic1.zhimg.com/v2-a8a0de37812e5470d509e915927dc34c_540x450.png");
                  width: 500px;
                  height: 300px;
                }
            
                .hot, .hot2{
                  position: absolute;
                  width: 50px;
                  height: 50px;
                  top:40%;
                  left:40%;
                  border: 1px transparent solid;
                }
            
                .hot2{
                  top:20%;
                  left:60%;
                }
            
                .point{
                  margin: 24px;
                  width: 4px;
                  height: 4px;
                  border-radius: 2px;
                  background-color: red;
                }
            
                .circle,.circle2{
                  margin: -32px 20px 20px 20px ;
                  width: 10px;
                  height: 10px;
                  border-radius: 50%;
                  border-color: red;
                  border-style: solid;
                  animation-name: large;
                  animation-duration: 1s;
                  animation-iteration-count: infinite;
                  animation-timing-function: linear;
                }
            
                .circle2{
                  animation-delay: 0.5s;
                }
            
            
              </style>
            </head>
            <body>
            
            <div class="box">
              <div class="hot">
                <div class="point"></div>
                <div class="circle"></div>
                <div class="circle2"></div>
              </div>
              <div class="hot2">
                <div class="point"></div>
                <div class="circle"></div>
                <div class="circle2"></div>
              </div>
            </div>
            
            </body>
            </html>"
        - 3D 转换
          "多一个z轴，屏幕外正值，屏幕里面负值"
          - 3D 位移 translate3d(x,y,z px)
            "多了一个移动方向 z
            需要借助透视才能看到移动"
            - 示例
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>3d</title>
                <style>
                  body{
                    perspective: 500px;
                  }
                  div{
                    width: 200px;
                    height: 200px;
                    background-color: pink;
                    transform: translate3d(0,0,2px);
                  }
                </style>
              </head>
              <body>
              <div></div>
              </body>
              </html>"
          - 3D 旋转 rotateXYZ(n deg) 沿着某个轴(中轴)
            - rotate(x, y, z, n deg) 沿着某个矢量
            - 示例
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>3d</title>
                <style>
                  /*body{*/
                  /*  perspective: 500px;*/
                  /*}*/
                  div{
                    width: 200px;
                    height: 200px;
                    background-color: pink;
                    font-size: 50px;
                    transition: all 1s;
                  }
              
                  div:hover{
                    transform: rotateX(360deg);
                  }
                </style>
              </head>
              <body>
              <div>文字</div>
              </body>
              </html>"
          - 透视 perspective: n px; //眼睛到屏幕距离。单位像素，写在父元素上
            "产生3D效果
            视距"
          - 3D 呈现 transform-style 子元素是否开启3D 默认不开启
            - 示例
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>rotate</title>
                <style>
                  body{
                    /*perspective: 500px;*/
                  }
                  .box:hover{
                    transform: rotateY(-45deg);
                  }
                  .box{
                    position: relative;
                    width: 200px;
                    height: 200px;
                    margin: 100px auto;
                    transition: all 1s;
                    transform-style: preserve-3d;
                  }
                  .blue, .green{
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                  }
              
                  .blue{
                    background-color: blue;
                  }
              
                  .green{
                    background-color: green;
                    transform: rotateX(45deg);
                  }
                </style>
              </head>
              <body>
              <div class="box">
                <div class="blue">
                  <div>info</div>
                </div>
                <div class="green"></div>
              </div>
              </body>
              </html>"
          - 示例代码
            - 背对背 前后翻转(180度)
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>反转</title>
                <style>
                  .box {
                    position: relative;
                    width: 300px;
                    height: 300px;
                    margin: 100px auto;
                    transform-style: preserve-3d;
                    transition: all 1s;
                  }
              
                  .box:hover{
                    transform: rotateY(180deg);
                  }
              
                  .front,
                  .back{
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    border-radius: 50%;
                    font-size: 100px;
                    line-height: 300px;
                    text-align: center;
                  }
              
                  .front{
                    background-color: pink;
                    z-index: 1;
                  }
              
                  .back{
                    background-color: purple;
                    transform: rotateY(180deg);
                  }
                </style>
              </head>
              <body>
              <div class="box">
                <div class="front">前</div>
                <div class="back">后</div>
              </div>
              </body>
              </html>"
            - 立方体
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>Title</title>
                <style>
                  .room,
                  .room2,
                  .room3,
                  .room4 {
                    float: left;
                    position: relative;
                    transform-style: preserve-3d;
                    margin: 100px;
                  }
              
                  .room2 {
                    transform: rotateY(-45deg) rotateX(30deg);
                  }
              
                  .room3 {
                    transform: rotateY(45deg) rotateX(30deg);
                  }
              
                  .room4 {
                    transform: rotateY(85deg);
                  }
              
                  .front,
                  .up,
                  .down,
                  .back {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100px;
                    height: 50px;
                    font-size: 30px;
                    line-height: 50px;
                    text-align: center;
                  }
              
                  .front,
                  .up,
                  .down,
                  .back,
                  .left,
                  .right {
                    animation-duration: 5s;
                    animation-timing-function: linear;
                    animation-iteration-count: infinite;
                  }
              
                  @keyframes front {
                    0% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(180deg);
                    }
              
                    100% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(540deg);
                    }
                  }
              
                  .front {
                    background-color: pink;
                    animation-name: front;
                  }
              
                  @keyframes up {
                    0% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(-90deg);
                    }
              
                    100% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(270deg);
                    }
                  }
              
                  .up {
                    background-color: blue;
                    animation-name: up;
                  }
              
                  @keyframes down {
                    0% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(90deg);
                    }
              
                    100% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(450deg);
                    }
                  }
              
                  .down {
                    background-color: green;
                    animation-name: down;
                  }
              
                  @keyframes back {
                    0% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(0deg);
                    }
              
                    100% {
                      transform-origin: 0 25px 25px;
                      transform: rotateX(360deg);
                    }
                  }
              
                  .back {
                    background-color: green;
                    animation-name: back;
                  }
              
                  .left,
                  .right {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 50px;
                    height: 50px;
                    font-size: 30px;
                    line-height: 50px;
                    text-align: center;
                  }
              
                  @keyframes left {
                    0% {
                      transform-origin: 25px 25px 25px;
                      transform: rotateY(90deg) rotateZ(0deg);
                    }
                    100% {
                      transform-origin: 25px 25px 25px;
                      transform: rotateY(90deg) rotateZ(360deg);
                    }
                  }
              
                  .left {
                    top: 0px;
                    left: 0px;
                    background-color: red;
                    animation-name: left;
                  }
              
                  @keyframes right {
                    0% {
                      transform-origin: 25px 25px 25px;
                      transform: rotateY(-90deg) rotateZ(0deg);
                    }
                    100% {
                      transform-origin: 25px 25px 25px;
                      transform: rotateY(-90deg) rotateZ(-360deg);
                    }
                  }
              
                  .right {
                    top: 0px;
                    left: 50px;
                    background-color: yellow;
                    animation-name: right;
                  }
                </style>
              </head>
              <body>
              <div class="room">
                <div class="front">A</div>
                <div class="up">B</div>
                <div class="down">C</div>
                <div class="back">D</div>
                <div class="left">E</div>
                <div class="right">F</div>
              </div>
              <div class="room2">
                <div class="front">A</div>
                <div class="up">B</div>
                <div class="down">C</div>
                <div class="back">D</div>
                <div class="left">E</div>
                <div class="right">F</div>
              </div>
              <div class="room3">
                <div class="front">A</div>
                <div class="up">B</div>
                <div class="down">C</div>
                <div class="back">D</div>
                <div class="left">E</div>
                <div class="right">F</div>
              </div>
              <div class="room4">
                <div class="front">A</div>
                <div class="up">B</div>
                <div class="down">C</div>
                <div class="back">D</div>
                <div class="left">E</div>
                <div class="right">F</div>
              </div>
              </body>
              </html>"
            - 跑马灯 暂停选老婆
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>走马灯</title>
                <style>
                  body{
                    transform-style: preserve-3d;
                    transform: rotateX(-10deg);
                    perspective: 1000px;
                  }
              
                  @keyframes rotate {
                    0%{
                      transform: rotateY(0);
                    }
              
                    100%{
                      transform: rotateY(360deg);
                    }
                  }
              
                  section{
                    position: relative;
                    width: 300px;
                    height: 200px;
                    margin: 100px auto;
                    transform-style: preserve-3d;
                    animation: rotate 0.5s infinite linear;
                  }
              
                  section:hover{
                    animation-play-state: paused;
                  }
              
                  section div{
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background:url("https://www.baidu.com/img/pc_1c6e30772d5e4103103bd460913332f9.png") no-repeat;
                  }
              
                  section div:nth-child(1){
                    background: url("https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1730972108,1165243449&fm=15&gp=0.jpg");
                    transform: translateZ(300px);
                  }
              
                  section div:nth-child(2){
                    background: url("https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3971616964,499771020&fm=15&gp=0.jpg");
                    transform: rotateY(60deg) translateZ(300px);
                  }
              
                  section div:nth-child(3){
                    background: url("https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4125359766,548355094&fm=15&gp=0.jpg");
                    transform: rotateY(120deg) translateZ(300px);
                  }
              
                  section div:nth-child(4){
                    background: url("https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1007622432,4145488829&fm=26&gp=0.jpg");
                    transform: rotateY(180deg) translateZ(300px);
                  }
              
                  section div:nth-child(5){
                    background: url("https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3142070763,3091120336&fm=26&gp=0.jpg");
                    transform: rotateY(240deg) translateZ(300px);
                  }
              
                  section div:nth-child(6){
                    background: url("https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3792440307,1916464521&fm=15&gp=0.jpg");
                    transform: rotateY(300deg) translateZ(300px);
                  }
                </style>
              </head>
              <body>
              <section>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
              </section>
              </body>
              </html>"
        - 浏览器私有前缀
          "-moz- Firefox私有属性
          -ms- ie私有属性
          -webkit- safari私有属性 chrome私有属性
          -o- opera私有属性"
      - 移动WEB开发
        "<meta name="viewport"
              content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"/>
        
        基础、视口、二倍图、调试、技术、布局方式
        
        移动端浏览器，都是来自webkit，发展晚，所以兼容好"
        - 基础知识
          - 视口 (浏览器显示的屏幕区域)
            "布局视图 - 手机用于显示PC-web页码，默认视口分辨率936px，所以看pc网页时，显示不全、文字特别小
            
            视觉视图 手机的宽度，网页常显示不全，要左右滑动
            
            理想视图 布局试图和视觉视图一致时（布局试图的宽度 == 视觉视图宽度）
            
            实现方式
            <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no" />
            宽度=设备宽度
            初始缩放比
            
            --------------
            移动端的布局不同于pc端，首先我们要知道在移动端中，css中的1px并不等于物理上的1px，因为手机屏幕的分辨率已经越来越高，高像素但是屏幕尺寸却没有发生太大变化，那就意味着一个物理像素点实际上塞入了好几个像素。
            
            在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。但是要注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西。
            "
          - 二倍图 - 图片准备一个大的，然后缩小，解决手机上高分屏看起来模糊的问题
            "物理像素 物理像素比
            CSS 的 1px 不等于 1物理像素
            有时 1px = 2物理像素
            
            视网膜屏幕
            
            图片 50px * 50px 在视网膜屏幕下会显示模糊
            所以需要50*50的图片，最好使用100*100或更多倍数，然后手动缩小为50*50"
          - 技术选型 * 2
            "单独制作移动端
            	国内大多是这个
            响应式PC+ WEB 二合一（我要这个
            	制作麻烦，需要花很大精力调整兼容问题
            
            常见页面布局
            	流式布局 百分比布局% 非固定像素布局
            	flex弹性布局 √
            	媒体查询
            	bootstarp
            	混合布局"
          - normalize.css 初始化推荐
          - 移动端tips
            - box-sizing: border-box; 盒子大小可以固定了，不用减去了
            - 清除点击高亮 a{-webkit-tap-highlight-color: transparent;}
            - 按钮输入框自定义样式 -webkit-appearance: none;
            - 禁止长按弹出菜单 -webkit-touch-callout: none;
        - https://necolas.github.io/normalize.css/8.0.1/normalize.css
          "/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */
          
          /* Document
             ========================================================================== */
          
          /**
           * 1. Correct the line height in all browsers.
           * 2. Prevent adjustments of font size after orientation changes in iOS.
           */
          
          html {
            line-height: 1.15; /* 1 */
            -webkit-text-size-adjust: 100%; /* 2 */
          }
          
          /* Sections
             ========================================================================== */
          
          /**
           * Remove the margin in all browsers.
           */
          
          body {
            margin: 0;
          }
          
          /**
           * Render the `main` element consistently in IE.
           */
          
          main {
            display: block;
          }
          
          /**
           * Correct the font size and margin on `h1` elements within `section` and
           * `article` contexts in Chrome, Firefox, and Safari.
           */
          
          h1 {
            font-size: 2em;
            margin: 0.67em 0;
          }
          
          /* Grouping content
             ========================================================================== */
          
          /**
           * 1. Add the correct box sizing in Firefox.
           * 2. Show the overflow in Edge and IE.
           */
          
          hr {
            box-sizing: content-box; /* 1 */
            height: 0; /* 1 */
            overflow: visible; /* 2 */
          }
          
          /**
           * 1. Correct the inheritance and scaling of font size in all browsers.
           * 2. Correct the odd `em` font sizing in all browsers.
           */
          
          pre {
            font-family: monospace, monospace; /* 1 */
            font-size: 1em; /* 2 */
          }
          
          /* Text-level semantics
             ========================================================================== */
          
          /**
           * Remove the gray background on active links in IE 10.
           */
          
          a {
            background-color: transparent;
          }
          
          /**
           * 1. Remove the bottom border in Chrome 57-
           * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
           */
          
          abbr[title] {
            border-bottom: none; /* 1 */
            text-decoration: underline; /* 2 */
            text-decoration: underline dotted; /* 2 */
          }
          
          /**
           * Add the correct font weight in Chrome, Edge, and Safari.
           */
          
          b,
          strong {
            font-weight: bolder;
          }
          
          /**
           * 1. Correct the inheritance and scaling of font size in all browsers.
           * 2. Correct the odd `em` font sizing in all browsers.
           */
          
          code,
          kbd,
          samp {
            font-family: monospace, monospace; /* 1 */
            font-size: 1em; /* 2 */
          }
          
          /**
           * Add the correct font size in all browsers.
           */
          
          small {
            font-size: 80%;
          }
          
          /**
           * Prevent `sub` and `sup` elements from affecting the line height in
           * all browsers.
           */
          
          sub,
          sup {
            font-size: 75%;
            line-height: 0;
            position: relative;
            vertical-align: baseline;
          }
          
          sub {
            bottom: -0.25em;
          }
          
          sup {
            top: -0.5em;
          }
          
          /* Embedded content
             ========================================================================== */
          
          /**
           * Remove the border on images inside links in IE 10.
           */
          
          img {
            border-style: none;
          }
          
          /* Forms
             ========================================================================== */
          
          /**
           * 1. Change the font styles in all browsers.
           * 2. Remove the margin in Firefox and Safari.
           */
          
          button,
          input,
          optgroup,
          select,
          textarea {
            font-family: inherit; /* 1 */
            font-size: 100%; /* 1 */
            line-height: 1.15; /* 1 */
            margin: 0; /* 2 */
          }
          
          /**
           * Show the overflow in IE.
           * 1. Show the overflow in Edge.
           */
          
          button,
          input { /* 1 */
            overflow: visible;
          }
          
          /**
           * Remove the inheritance of text transform in Edge, Firefox, and IE.
           * 1. Remove the inheritance of text transform in Firefox.
           */
          
          button,
          select { /* 1 */
            text-transform: none;
          }
          
          /**
           * Correct the inability to style clickable types in iOS and Safari.
           */
          
          button,
          [type="button"],
          [type="reset"],
          [type="submit"] {
            -webkit-appearance: button;
          }
          
          /**
           * Remove the inner border and padding in Firefox.
           */
          
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner {
            border-style: none;
            padding: 0;
          }
          
          /**
           * Restore the focus styles unset by the previous rule.
           */
          
          button:-moz-focusring,
          [type="button"]:-moz-focusring,
          [type="reset"]:-moz-focusring,
          [type="submit"]:-moz-focusring {
            outline: 1px dotted ButtonText;
          }
          
          /**
           * Correct the padding in Firefox.
           */
          
          fieldset {
            padding: 0.35em 0.75em 0.625em;
          }
          
          /**
           * 1. Correct the text wrapping in Edge and IE.
           * 2. Correct the color inheritance from `fieldset` elements in IE.
           * 3. Remove the padding so developers are not caught out when they zero out
           *    `fieldset` elements in all browsers.
           */
          
          legend {
            box-sizing: border-box; /* 1 */
            color: inherit; /* 2 */
            display: table; /* 1 */
            max-width: 100%; /* 1 */
            padding: 0; /* 3 */
            white-space: normal; /* 1 */
          }
          
          /**
           * Add the correct vertical alignment in Chrome, Firefox, and Opera.
           */
          
          progress {
            vertical-align: baseline;
          }
          
          /**
           * Remove the default vertical scrollbar in IE 10+.
           */
          
          textarea {
            overflow: auto;
          }
          
          /**
           * 1. Add the correct box sizing in IE 10.
           * 2. Remove the padding in IE 10.
           */
          
          [type="checkbox"],
          [type="radio"] {
            box-sizing: border-box; /* 1 */
            padding: 0; /* 2 */
          }
          
          /**
           * Correct the cursor style of increment and decrement buttons in Chrome.
           */
          
          [type="number"]::-webkit-inner-spin-button,
          [type="number"]::-webkit-outer-spin-button {
            height: auto;
          }
          
          /**
           * 1. Correct the odd appearance in Chrome and Safari.
           * 2. Correct the outline style in Safari.
           */
          
          [type="search"] {
            -webkit-appearance: textfield; /* 1 */
            outline-offset: -2px; /* 2 */
          }
          
          /**
           * Remove the inner padding in Chrome and Safari on macOS.
           */
          
          [type="search"]::-webkit-search-decoration {
            -webkit-appearance: none;
          }
          
          /**
           * 1. Correct the inability to style clickable types in iOS and Safari.
           * 2. Change font properties to `inherit` in Safari.
           */
          
          ::-webkit-file-upload-button {
            -webkit-appearance: button; /* 1 */
            font: inherit; /* 2 */
          }
          
          /* Interactive
             ========================================================================== */
          
          /*
           * Add the correct display in Edge, IE 10+, and Firefox.
           */
          
          details {
            display: block;
          }
          
          /*
           * Add the correct display in all browsers.
           */
          
          summary {
            display: list-item;
          }
          
          /* Misc
             ========================================================================== */
          
          /**
           * Add the correct display in IE 10+.
           */
          
          template {
            display: none;
          }
          
          /**
           * Add the correct display in IE 10.
           */
          
          [hidden] {
            display: none;
          }"
        - 布局模式  -<ANKI 2020年2月24日
          - 流式布局 百分比布局% 非固定像素布局 —— https://m.jd.com/
            "宽度：百分比
            设定最小宽度、最大宽度
            max-width: 980px;
            min-width: 320px;"
            - 简单示例
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>流式布局</title>
                <style>
                  *{
                    margin: 0;
                    padding: 0;
                  }
                  section{
                    width: 100%;
                    max-width: 980px;
                    min-width: 320px;
                    margin: 0 auto;
                  }
                  section div{
                    float: left;
                    box-sizing: border-box;
                    width: 50%;
                    height: 400px;
                  }
              
                  section div:nth-child(1){
                    background-color:pink;
                  }
              
                  section div:nth-child(2){
                    background-color:red;
                  }
                </style>
              </head>
              <body>
              <section>
                <div>左</div>
                <div>右</div>
              </section>
              </body>
              </html>"
            - 关键点 body的宽度100% 然后设定最大最小宽度和居中
            - jd 第一行 示例
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>jd</title>
                <link rel="stylesheet" href="https://necolas.github.io/normalize.css/8.0.1/normalize.css">
                <style>
                  body{
                    margin: 0 auto;
                    min-width: 320px;
                    max-width: 540px;
                    background: #fff;
                    font-size: 14px;
                    font-family: -apple-system,Helvetica,sans-serif;
                    line-height: 1.5;
                    color: #666;
                    -webkit-text-size-adjust: 100%!important;
                    padding-bottom: env(safe-area-inset-bottom);
                  }
                  div{
                    box-sizing: border-box;
                  }
                  .close{
                    width: 100%;
                    height: 45px;
                    border-radius: 5px;
                    overflow: hidden;
                  }
                  .close div:nth-child(1){
                    float: left;
                    width: 8%;
                    line-height: 45px;
                    background-color: #333;
                    color: gray;
                    text-align: center;
                  }
                  .close div:nth-child(1):hover{
                    color: white;
                    cursor: pointer;
                  }
                  .close div:nth-child(2){
                    float: left;
                    width: 10%;
                    height: 45px;
                    background-color: #333;
                    background-image: url("jd.png");
                    background-repeat: no-repeat;
                    background-position: 5px 5px;
                    background-size: 35px 35px;
                  }
              
                  .close div:nth-child(3){
                    float: left;
                    width: 57%;
                    line-height: 45px;
                    background-color: #333;
                    color: #f5edd6;
                    text-align: center;
                  }
              
                  .close div:nth-child(4){
                    float: left;
                    width: 25%;
                    line-height: 45px;
                    background-color: #ff4a16;
                    color: #f5edd6;
                    text-align: center;
                  }
              
                </style>
              </head>
              <body>
              <div class="close">
                <div>X</div>
                <div></div>
                <div>打开京东APP，购物更轻松</div>
                <div>立即打开</div>
              </div>
              </body>
              </html>"
          - flex弹性布局 - 方便 (手机携程网)
            "https://www.bilibili.com/video/av76873727"
            - 入门 / 原理
              "传统布局 兼容性好，但是繁琐
              flex布局 书写方面，但是在PC端支持差
              
              flex布局 和 float布局矛盾，不能同时使用
              
              通过给父元素添加flex属性，来flex排列子元素
              父元素：容器
              子元素：项目
              
              主轴：x轴
              附轴：y轴"
            - 父元素(容器)常用属性
              - flex-direction 设置主轴(元素放入方向)
                "默认主轴方向为 x方向，侧轴默认 y轴
                
                row 默认值 从左到右
                row-reverse 从右到左
                column 从上到下
                column-reverse 从下到上"
              - justify-content 设置主轴上元素排列方式
                "flex-start 默认，从起点一个个排列
                flex-end 从尾部开始
                center 居中
                space-around 平分布局
                space-between 左右贴两边，然后平分 ⭐"
              - flex-wrap 设置子元素是否换行
                "默认不换行，超出了就缩小元素
                nowrap 不换行
                wrap 换行"
              - align-items 设置侧轴上元素排列方式(单行)
                "flex-start 默认
                flex-end 反向
                center 侧轴居中
                stretch 拉伸"
                - 垂直水平都居中
                  "align-items: center;
                  justify-content: center;"
              - align-content 设置侧轴上元素排列方式(多行)
                "flex-start 默认，从起点一个个排列
                flex-end 从尾部开始
                center 居中
                space-around 平分布局
                space-between 左右贴两边，然后平分 ⭐
                stretch 拉伸"
            - 子元素 常用属性
              - flex 子项目占用份数
                - 左右宽度固定，中间自适应 代码
              - align-self 元素自己的排列方式
              - order 排列顺序
            - 我写的图片展示(换行后扩展到满) 代码
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <meta name="viewport"
                      content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"/>
                <title>05-whatINeed</title>
                <style>
                  * {
                    margin: 0;
                    padding: 0;
                  }
                  li{
                    list-style-type: none;
                  }
              
                  /*这是整个页面*/
                  .content {
                    display: flex;
                    width: 98%;
                    box-sizing: border-box;
                    margin: 0 1%;
                  }
              
                  /*页面左边一行宽度固定*/
                  .content .info {
                    width: 150px;
                    background-color: gray;
                    line-height: 40px;
                  }
              
                  /*页面右边显示图片，占用剩余宽度*/
                  /*所以父元素.content采用flex布局*/
                  /*而子元素.images使用flex-grow: 1*/
                  /*就可以占用全部宽度*/
                  /*另外.images 也是弹性容器，设置换行、主轴和附轴都是从头开始*/
                  .content .images {
                    display: flex;
                    flex-wrap: wrap;
                    justify-content: flex-start;
                    align-content: flex-start;
                    flex: 1;
                    background-color: #fffc90;
                  }
              
                  /*装有图片的盒子，设置一个最小宽度用于显示足够信息，并提供换行信号*/
                  /*同时flex: 1; 表示吃满整个一行*/
                  .images .contain,
                  .images .empty{
                    min-width: 100px;
                    box-sizing: border-box;
                    flex: 1;
                  }
              
                  /*展示图片，设置宽度，等比缩放，且和父盒子.contain走*/
                  .images .contain img {
                    width: 98%;
                  }
              
                  /*点睛之笔，最后一行元素个数不够，却flex: 1;，会导致最后一行元素大小和前面的不一样*/
                  /*所以后面补上高度为零的空盒子*/
                  .images .empty{
              
                  }
              
                </style>
              </head>
              <body>
              <div class="content">
                <div class="info">
                  <ul>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                    <li>这一栏宽度固定</li>
                  </ul>
                </div>
                <div class="images">
              
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
                  <div class="contain"><img src="./jd.png" alt="图片"></div>
              
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
                  <div class="empty"></div>
              
              
                </div>
              </div>
              </body>
              </html>"
          - rem适配布局 (苏宁首页)
            "ren单位 媒体查询 less"
            - 入门：痛点
              "痛点：
              1. 文字可以随屏幕变化吗？
              2. 盒子的高度设置问题
              3. 高度宽度等比缩放"
            - 什么是rem？em？ html的font-size
              "什么是rem
              rem是一个单位 root em
              em 是父元素字体大小 (font-size: 12px)
              rem html元素的字体大小
              
              font-size: 12px
              10 em = 120 rem
              
              于是所有的元素尺寸都用rem单位
              然后修改html的font-size就可以整体控制所有元素"
            - 媒体查询 @media
              "查询屏幕尺寸
              可以针对不同的屏幕尺寸，设置不同的样式
              
              格式：
              @media mediatype and且|not|only (meia feature){
              	//css-code
              }
              
              "
              - 媒体类型
                "all 所有设备
                print 打印机
                screen 屏幕"
              - 根据屏幕尺寸改变背景颜色 实例
                "/*设备是屏幕 and 最大宽度800px(800px以下)*/
                @media screen and (max-width: 800px) {
                  body{
                    background-color: pink;
                  }
                }
                
                /*500px一下再改变样式*/
                @media screen and (max-width: 500px) {
                  body{
                    background-color: purple;
                  }
                }"
          - 响应式布局 (bootstrap)
            "一般分PC IPAD IPHONE三个尺寸
            媒体查询进行响应式导航
            bootstrap"
            - 设备区分
              "宽度 <768px 手机 宽度=100%
              768~1200 平板 宽度750
              >1200 PC 宽度1170"
              - 代码
                "<!DOCTYPE html>
                <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <meta name="viewport"
                        content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"/>
                  <title>06-响应式布局</title>
                  <style>
                    .container {
                      height: 150px;
                      background-color: pink;
                      margin: 0 auto;
                    }
                
                    @media screen and (max-width: 767px) {
                      .container {
                        width: 100%;
                      }
                    }
                
                    @media screen  and (min-width: 768px) {
                      .container {
                        width: 750px;
                      }
                    }
                
                    @media screen  and (min-width: 992px) {
                      .container {
                        width: 970px;
                      }
                    }
                
                    @media screen  and (min-width: 1200px) {
                      .container {
                        width: 1170px;
                      }
                    }
                  </style>
                </head>
                <body>
                <div class="container">
                
                </div>
                </body>
                </html>"
            - 开发步骤
              "指定大盒子布局容器，尺寸不同改变子元素的布局"
            - 简单的响应式导航栏
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <meta name="viewport"
                      content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"/>
                <title>06-响应式布局</title>
                <style>
                  *{
                    margin: 0;
                    padding: 0;
                  }
              
                  .container {
                    height: 30px;
                    box-sizing: border-box;
                    margin: 0 auto;
                  }
              
                  li{
                    list-style-type: none;
                  }
              
                  .container ul li{
                    display: block;
                    float: left;
                    color: white;
                    height: 30px;
                    width: 89px;
                    font-size: 25px;
                    line-height: 30px;
                    text-align: center;
                    background-color: green;
                  }
              
                  @media screen and (max-width: 767px) {
                    .container {
                      width: 100%;
                    }
                    .container ul li{
                      width: 33%;
                    }
                  }
              
                  @media screen  and (min-width: 768px) {
                    .container {
                      width: 750px;
                    }
                  }
              
                  @media screen  and (min-width: 992px) {
                    .container {
                      width: 750px;
                    }
                  }
              
                  @media screen  and (min-width: 1200px) {
                    .container {
                      width: 750px;
                    }
                  }
                </style>
              </head>
              <body>
              <div class="container">
                <ul>
                  <li>导航1</li>
                  <li>导航2</li>
                  <li>导航3</li>
                  <li>导航4</li>
                  <li>导航5</li>
                  <li>导航6</li>
                  <li>导航7</li>
                  <li>导航8</li>
                </ul>
              </div>
              </body>
              </html>"
      - Emmet 语法
        - 快速HTML标签
          "名称+tab
          html.className + tab
          ul>li
          html{innerText} + tab
          $ 自增符号
          "
        - 快速生成CSS标签
          "首字母
          w100 -> width: 100px;
          h100 -> height: 100px;"
      - 常见问题解决办法
        - 文字显示
        - 文本显示
          - div内文字上下居中(垂直居中)
            "设置行高=组件高度
            height: 32px;
            line-height:32px;"
          - 不换行
            " white-space: nowrap;"
        - 伪类相关 鼠标显示
          - 非<a>标签但是鼠标悬浮会变成手型
            "cursor:pointer;"
          - 鼠标变成想要的图片 cursor
          - 去除input元素选中focus后的边框
            "outline: none;"
        - 盒子排布
          - div 已知宽度 水平居中
            "1. 指定了宽度
            2. 左右margin = auto
            
            margin: 0 auto;"
          - 清楚内外边距——CSS第一行代码
            "* {
            margin: 0;
            padding: 0;
            }"
          - 盒子高度=宽度，而宽度自适应
            "神奇得不能再神奇
            ---------------------------
            padding-top: 100%"
        - 导航栏 li+a
          "不要直接用链接<a>
          而是li+a的做法
          这样语义清晰
          
          而且如果直接用<a>，搜索引擎容易认为有堆砌关键字的嫌疑，会降低搜索排名"
        - 响应式
          - flex响应式图片容器
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>响应式图片布局</title>
              <style>
                *{
                  margin: 0;
                  padding:0;
                }
                li{
                  list-style-type: none;
                }
                h2{
                  text-align: center;
                }
            
                /*--------------------响应式图片布局------------------------*/
                .images {
                  display: flex;
                  flex-wrap: wrap;
                  justify-content: space-between;
                  align-content: flex-start;
                  flex: 1;
                  background-color: #fff9dc;
                }
            
                /*装有图片的盒子，设置一个最小宽度用于显示足够信息，并提供换行信号*/
                /*同时flex: 1; 表示吃满整个一行*/
                .images .contain,
                .images .empty{
                  min-width: 250px;
                  padding: 2px;
                  box-sizing: border-box;
                  flex: 1;
            
                  display: flex;
                  justify-items: center;
                  align-items: center;
                }
            
                /*展示图片，设置宽度，等比缩放，且和父盒子.contain走*/
                .images .contain img {
                  width: 100%;
                  max-height: 250px;
                  object-fit:contain;
                }
            
                /*点睛之笔，最后一行元素个数不够，却flex: 1;，会导致最后一行元素大小和前面的不一样*/
                /*所以后面补上高度为零的空盒子*/
                .images .empty{
            
                }
              </style>
            </head>
            <body>
            <h2>响应式图片布局</h2>
            <div class="contain">
              <div class="images">
            
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./width.jpg" alt="图片"></div>
                <div class="contain"><img src="./height.jpg" alt="图片"></div>
                <div class="contain"><img src="./small.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
            
            
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
              </div>
            </div>
            </body>
            </html>"
          - flex响应式图片容器 侧边栏占领
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>响应式图片布局</title>
              <style>
                *{
                  margin: 0;
                  padding:0;
                }
                li{
                  list-style-type: none;
                }
                h2{
                  text-align: center;
                }
                .contain{
                  display: flex;
                }
                .over{
                  display: none;
                }
            
                @keyframes occupy {
                  100%{
                    width: 500px;
                  }
                }
            
                .occupy{
                  width: 0;
                  background-color: pink;
                  overflow: hidden;
                  white-space: nowrap;
                  animation-name: occupy;
                  animation-iteration-count: infinite;
                  animation-duration: 2s;
                  animation-direction: alternate;
                  animation-timing-function: linear;
                }
            
                /*--------------------响应式图片布局------------------------*/
                .images {
                  display: flex;
                  flex-wrap: wrap;
                  justify-content: space-between;
                  align-content: flex-start;
                  flex: 1;
                  background-color: #fff9dc;
                }
            
                /*装有图片的盒子，设置一个最小宽度用于显示足够信息，并提供换行信号*/
                /*同时flex: 1; 表示吃满整个一行*/
                .images .contain,
                .images .empty{
                  min-width: 250px;
                  padding: 2px;
                  box-sizing: border-box;
                  flex: 1;
            
                  display: flex;
                  justify-items: center;
                  align-items: center;
                }
            
                /*展示图片，设置宽度，等比缩放，且和父盒子.contain走*/
                .images .contain img {
                  width: 100%;
                  max-height: 250px;
                  object-fit:contain;
                }
            
                /*点睛之笔，最后一行元素个数不够，却flex: 1;，会导致最后一行元素大小和前面的不一样*/
                /*所以后面补上高度为零的空盒子*/
                .images .empty{
            
                }
              </style>
            </head>
            <body>
            <h2>响应式图片布局</h2>
            <span>occupy形式</span>
            <div class="contain">
              <div class="over">
                <ul>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                </ul>
              </div>
              <div class="occupy">
              <ul>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
              </ul>
            </div>
              <div class="images">
            
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./width.jpg" alt="图片"></div>
                <div class="contain"><img src="./height.jpg" alt="图片"></div>
                <div class="contain"><img src="./small.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
            
            
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
              </div>
            </div>
            </body>
            </html>"
          - flex响应式图片容器 侧边栏悬浮
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>响应式图片布局</title>
              <style>
                *{
                  margin: 0;
                  padding:0;
                }
                li{
                  list-style-type: none;
                }
                h2{
                  text-align: center;
                }
                .contain{
                  /*display: flex;*/
                  position: relative;
                }
            
                @keyframes over {
                  100%{
                    left: 100px;
                  }
                }
            
                .over{
                  position: absolute;
                  width: 200px;
                  top: 0;
                  left: -200px;
                  color: #333;
                  background-color: rgba(70, 70, 70, 0.5);
                  animation-name: over;
                  animation-iteration-count: infinite;
                  animation-duration: 2s;
                  animation-direction: alternate;
                  animation-timing-function: linear;
                  z-index: 5;
                }
            
                @keyframes occupy {
                  100%{
                    width: 500px;
                  }
                }
            
                .occupy{
                  display: none;
                  width: 0;
                  background-color: pink;
                  overflow: hidden;
                  white-space: nowrap;
                  animation-name: occupy;
                  animation-iteration-count: infinite;
                  animation-duration: 2s;
                  animation-direction: alternate;
                  animation-timing-function: linear;
            
                  z-index: 2;
                }
            
                /*--------------------响应式图片布局------------------------*/
                .images {
                  position: absolute;
                  top: 0;
                  left: 0;
                  display: flex;
                  flex-wrap: wrap;
                  justify-content: space-between;
                  align-content: flex-start;
                  flex: 1;
                  background-color: #fff9dc;
                }
            
                /*装有图片的盒子，设置一个最小宽度用于显示足够信息，并提供换行信号*/
                /*同时flex: 1; 表示吃满整个一行*/
                .images .contain,
                .images .empty{
                  min-width: 250px;
                  padding: 2px;
                  box-sizing: border-box;
                  flex: 1;
            
                  display: flex;
                  justify-items: center;
                  align-items: center;
                }
            
                /*展示图片，设置宽度，等比缩放，且和父盒子.contain走*/
                .images .contain img {
                  width: 100%;
                  max-height: 250px;
                  object-fit:contain;
                }
            
                /*点睛之笔，最后一行元素个数不够，却flex: 1;，会导致最后一行元素大小和前面的不一样*/
                /*所以后面补上高度为零的空盒子*/
                .images .empty{
            
                }
              </style>
            </head>
            <body>
            <h2>响应式图片布局</h2>
            <span>over形式</span>
            <div class="contain">
              <div class="over">
                <ul>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                  <li>列表</li>
                </ul>
              </div>
              <div class="occupy">
              <ul>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
                <li>列表</li>
              </ul>
            </div>
              <div class="images">
            
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./width.jpg" alt="图片"></div>
                <div class="contain"><img src="./height.jpg" alt="图片"></div>
                <div class="contain"><img src="./small.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./big.jpg" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
                <div class="contain"><img src="./jd.png" alt="图片"></div>
            
            
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
                <div class="empty"></div>
              </div>
            </div>
            </body>
            </html>"
        - CSS 属性书写顺序规范 & 版面布局
          - 顺序
            "布局定位——display position float
            自身属性——宽高，边框
            文本
            其他"
          - 布局 (PC-webpage)
            "先结构后样式
            
            一行一行来做，做完一行再做下一行
            
            确认版心（可视区），确认宽度 1226px?
            分析行模块，再分析行模块中的列模块"
    - Less CSS 预处理语言
      "变量、混入、运算、函数"
      - 安装 先安装node.js 然后 npm install -g less
      - 查看版本 lessc -v
      - 定义变量
        "@bgColor: pink; //@变量名 : 值;
        
        body{
          background-color: @bgColor;
        }"
      - 嵌套 孩子写里面
        "div{
          background-color: red;
          div{
            background-color: white;
          }
        }"
      - 运算
  - JS
    - reduce (总数, 当前值)
      "books.reduce((p, c) => p += c.price * c.count, 0)"
    - ES6
      - 箭头函数 - this指代什么？
        "引用的最近作用域的this
        向外层作用域中一层层查找，直到有this的定义"
      - promise
        - then(f).catch(f)形式
          "new Promise(((resolve, reject) => {
            //这里发送网络请求
            //请求结束后，调用resolve(data)，就会跳到then
            setTimeout(()=>reject('hello world!!!err'),1000);
          })).then((data)=>{
            //这里处理请求的结果
            console.log(data);
          }).catch(err=>{
            //处理失败
            console.log(err);
          });"
        - then(f,f)形式
          "new Promise(((resolve, reject) => {
            setTimeout(()=>{
              // resolve('H');
              reject('HH');
            },1000)
          })).then(data=>{
            console.log(data)
          },err=>{
            console.log(err);
          });"
        - 链式调用 一
          "new Promise(resolve => {
            let data = 'aaa';
            resolve(data);
          }).then(data => {
            console.log(data);
            return new Promise(resolve => {resolve(data + '111')});
          }).then(data=>{
            console.log(data);
            return new Promise(resolve => {resolve(data + 'bbb')});
          }).then(data=>{
            console.log(data);
            return new Promise(resolve => {resolve(data + 'bbb')});
          }).then(data=>{
            console.log(data);
          });"
        - 链式调用 简写 第一次resolve()
          "new Promise(resolve => {
            console.log("简单链式调用");
            resolve('zzz');
          }).then(data => {
            console.log(data);
            return data + 'qqq';
          }).then(data => {
            console.log(data);
            return data + 'qqq';
          }).then(data => {
            console.log(data);
            return data + 'qqq';
          }).then(data => {
            console.log(data);
          });"
        - Promise.all([])实现同步
          "Promise.all([
            new Promise(resolve => resolve('两个网络请求')),
            new Promise(resolve => resolve('同步关系的实现'))
          ]).then(results=>console.log(results));"
      - 对象结构
        "const obj = {
        name:'a',
        age:1
        }
        
        const {age, name} = obj"
      - 正则表达式 判断是否全是数字
        " /^[\d]+$/"
  - websocket
    - 简介和原理
      "* 1. web socket 协议
      * -- H5 协议，实现 浏览器 和 服务器 全双工通信，由单个TCP实现
      * -- 可以双方同时发信
      * -- 基础知识：半双工，指的是同时只有一方能发信，如对讲机
      * -- 基础知识：全双工，可同时发信，如车辆对开
      * <p>
      * -- 推拉技术
      * -- 推送：服务器主动发信
      * -- 拉取：客户机主动请求信息
      * <p>
      * -- 优势：以前需要使用 HTTP轮询 和 TCP长链接 实现
      * -- 因为以前的 HTTP 是 <strong>无状态的</strong>。效率低下
      * <p>
      * -- websocket 是一种长链接，一次请求，然后通信都在这个 TCP 上进行
      * -- 原理图
      * -- 第一步：进行 opening handshake 打开握手
      * -- -- 客户端 发送 handshake request
      * -- -- 服务器 返回 handshake response
      * -- 第二步：双方通过 data frame 通信
      * -- 第三步：进行 closing handshake
      * -- -- 客户端 发送 closing handshake request 关闭握手
      * -- -- 服务器 发送 closing handshake response
      * <p>
      * -- 打开 和 关闭 都是 客户端 主动进行的？
      * -- 答： 分手 双方都可以
      * <p>
      * -- ⭐ 打开 和 关闭 的协议是基于 HTTP 的，发送的是 HTTP 格式的消息
      * -- upgrade: websocket 表示 请求 websocket
      * -- 具体报文略
      *
      * 2. 对比
      * -- H5 和 websocket -- -- websocket 是 H5 的一部分
      * -- socket 和 websocket -- -- socket 是为了更方便的使用底层 TCP/UDP 协议，而提供的抽象。websocket 是一套标准
      * -- websocket 中 建立/关闭 是基于HTTP协议的请求相应机制（底层还是socket）
      * -- websocket 中 通信 是基于 socket 的
      * -- socket 更灵活。 websocket 更方便
      *
      * 3. 客户端不支持 websocket 怎么办？
      * -- 答：可以用 JS 模拟，有一个叫 SockJS 的东西
      *
      * 4. 服务器 使用 websocket，tomcat 7+ 以上版本"
    - JS 代码
      - 创建实例
        "const socket = new WebSocket('ws://192.168.2.13:2234/' + user.name);"
      - 发送消息 socket.send(msg)
        "一般发json JSON.stringify(dara)"
      - 收消息 socket.onmessage = function (event){...}
        "一般是收 JSON 消息 JSON.parse(event.data)
        "
        - 消息内容在 event.data 中
      - 主动关闭连接 socket.close()
        "一般是
        if(socket!=null){
        socket.close();
        socket = null;
        }"
      - 被动关闭连接 socket.onclose = function (event){...}
  - Vue
    - 学习笔记 @Deprecated 
      - 基本数据绑定和标签
        - {{}}标记
          "<div id="app">
              <h2>{{message}}</h2>
              <p>{{name}}</p>
          </div><!--入门-->
          
          const app = new Vue({
              el: '#app', // 要管理的元素
              data: { // 定义数据
                  message: 'hello, vue',
                  name: '段落内容'
              }
          });
          
          "
        - v-for 展示列表
          "<ul>
              <li v-for="item in movies">{{item}}</li>
          </ul>"
        - v-on:事件 事件监听 简写@
          - @click="fun(obj)" 点击事件
        - v-bind:field="" 动态属性 简写:
          - :class="{active: actives[index]} class绑定是使用json
          - :style="{color: color,fontSize:fontSize+'px'}"
          - 属性可以使用数据，不用引号默认绑定数据
        - 计算属性 computed 缓存
          "computed:{
              //计算属性.性能高一点
              fullName:function () {
                  return this.firstName+" "+this.lastName;
              },
          
              totalPrice:function () {
                  return this.books.reduce((total,item)=>total+=item.price,0);
              }
          }"
          - 计算属性内部是set和get
            "computed: {
              fullName: {
                set: function (newValue) {
                  //一般没有set方法
                  console.log(newValue);
                },
                get: function () {
                  console.log(this);
                  return this.firstName + " " + this.lastName;
                }
              }
            }"
        - v-if / v-else / v-show 显示
          - v-if
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
            
            <div @click="toggle=!toggle" id="app">
                <p v-if="toggle">{{message}}</p>
                <p v-else>{{elseMessage}}</p>
            </div>
            
            <script src="../js/vue.js"></script>
            <script>
                const app =new Vue({
                    el:'#app',
                    data:{
                        message:'hello',
                        elseMessage:'其他',
                        toggle:true
                    },
                    methods:{
                    }
                });
            
                setInterval(()=>app.toggle=!app.toggle,100);
            </script>
            
            </body>
            </html>"
          - v-show
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
            
            <div id="app">
                <p>{{message}}</p>
                <p v-show="true">{{message}}</p>
                <p v-show="false">{{message}}</p>
            
            </div>
            
            <script src="../js/vue.js"></script>
            <script>
                const app = new Vue({
                    el:'#app',
                    data:{
                        message:'hello'
                    },
                    methods:{
            
                    }
                })
            </script>
            
            </body>
            </html>"
        - v-modal 表单双向绑定
        - watch 变量改变钩子
          "<!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <title>Title</title>
          </head>
          <body>
          
          <div id="app">
              <p>{{message}}</p>
              <p @click="num++">{{num}}</p>
          </div>
          
          <script src="../js/vue.js"></script>
          <script>
              const app = new Vue({
                  el:'#app',
                  data:{
                      message:'hello',
                      num:1,
                  },
                  methods:{
          
                  },
                  watch:{
                      num(newValve,oldValue){
                          console.log("钩子检测到num改变");
                          this.message='钩子检测到num改变从'+oldValue+'到'+newValve;
                      }
                  }
              })
          </script>
          
          </body>
          </html>"
        - 购物车练习
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Title</title>
          </head>
          <body>
          
          <div id="app">
            <p>{{message}}</p>
            <table v-if="books.length>0">
              <thead>
              <th></th>
              <th>书籍名称</th>
              <th>出版日期</th>
              <th>价格</th>
              <th>数量</th>
              <th>操作</th>
              </thead>
              <tr v-for="(e,i) in books">
                <th>{{i}}</th>
                <th>{{e.name}}</th>
                <th>{{e.date}}</th>
                <th>{{e.price | showPrice}}</th>
                <th>
                    <button :disabled="e.count<=1" @click="e.count--">-</button>
                    {{e.count}}
                    <button @click="e.count++">+</button>
                </th>
                <th><button @click="books.splice(i,1)">移除</button></th>
              </tr>
            </table>
              <p v-if="books.length<=0">购物车为空</p>
            <p>总价:￥{{totalPrice}}</p>
          </div>
          
          <script src="../js/vue.js"></script>
          <script>
            const dateForm = function f(date) {
              return date.getFullYear() + '-' + (date.getMonth() + 1);
            };
          
            const app = new Vue({
              el: '#app',
              data: {
                message: 'hello',
                books: [
                  {
                    id: 0,
                    name: '算法导论',
                    date: dateForm(new Date(2006, 9)),
                    price: 85,
                    count: 1
                  }, {
                    id: 1,
                    name: 'UNIX编程艺术',
                    date: dateForm(new Date(2006, 2)),
                    price: 59,
                    count: 1
                  }, {
                    id: 2,
                    name: '算法珠玑',
                    date: dateForm(new Date(2008, 10)),
                    price: 39,
                    count: 1
                  }, {
                    id: 3,
                    name: '代码大全',
                    date: dateForm(new Date(2006, 3)),
                    price: 128,
                    count: 1
                  },
                ]
              },
              methods: {},
              computed: {
                totalPrice() {
                  return this.books.reduce((p, c) => p += c.price * c.count, 0);
                }
              },
                filters:{
                  showPrice(price){
                      return '￥'+price.toFixed(2);
                  }
                }
            })
          </script>
          
          </body>
          </html>"
      - 组件
        - 入门
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>组件化</title>
          </head>
          <body>
          
          <div id="app">
            <!--  组件名字和位置-->
            <cpn></cpn>
          </div>
          <script src="../js/vue.js"></script>
          <script>
            const myComponent = Vue.extend({
              template:`<div>
          <h2>标题</h2>
          <p>内容</p>
          <p>内容</p>
          </div>`
            });
          
            // Vue.component('my-cpn',myComponent);
          
            let app = new Vue({
              el:'#app',
              components:{
                cpn:myComponent
              }
            });
          
          
            //组件化
            //页面拆分成小功能块
          
            //组件构造器 Vue.extends
            //注册 Vue.component
            //使用
          </script>
          </body>
          </html>"
        - 父子组件 components
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>组件化</title>
          </head>
          <body>
          
          <div id="app">
            <cpn1></cpn1>
            <cpn2></cpn2>
            <script>
              const cpnC1 = Vue.extend({
                template:`
              <div>
              <h2>标题1</h2>
              <p>内容1</p>
          </div>
              `
              });
          
              const cpnC2 = Vue.extend({
                template:`
              <div>
              <cpn1></cpn1>
              <h2>标题2</h2>
              <p>内容2</p>
          </div>
              `,components:{
                  cpn1: cpnC1
                }
              });
          
              const app = new Vue({
                el:'#app',
                components:{
                  // cpn1:cpnC1,
                  cpn2:cpnC2
                }
              });
          
            </script>
          </div>
          <script src="../js/vue.js"></script>
          </body>
          </html>"
        - 组件 数据data(){return {};}
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Title</title>
          </head>
          <body>
          
          <div id="app">
            <p>{{message}}</p>
            <count></count>
            <count></count>
            <count></count>
          </div>
          <template id="count">
            <div>
              <p>当前计数：{{counter}}</p>
              <button @click="increment">+</button>
              <button @click="decrement">-</button>
            </div>
          </template>
          <script src="../js/vue.js"></script>
          <script>
          
          
            const app = new Vue({
              el: '#app',
              data() {
                return {
                  message: 'hello'
                };
              },
              methods: {},
              components: {
                count: {
                  template: '#count',
                  data() {
                    return {
                      counter: 1
                    };
                  },
                  methods: {
                    increment() {
                      this.counter++;
                    },
                    decrement() {
                      this.counter--;
                    }
                  }
                }
              }
            })
          </script>
          
          </body>
          </html>"
        - <template id="cpn">
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Title</title>
          </head>
          <body>
          
          <div id="app">
            <p>{{message}}</p>
            <cpn1></cpn1>
            <cpn1></cpn1>
            <cpn1></cpn1>
            <cpn1></cpn1>
          </div>
          <template id="cpn1">
            <p>语法糖</p>
            <p>{{title}}</p>
          </template>
          <script src="../js/vue.js"></script>
          <script>
          
          
            const app = new Vue({
              el: '#app',
              data: {
                message: 'hello'
              },
              methods: {},
              components: {
                cpn1: {
                  template: '#cpn1',
                  data() {
                    return {
                      title: '我是标题'
                    };
                  }
                }
              }
            })
          </script>
          
          </body>
          </html>"
        - props 父传子
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Title</title>
          </head>
          <body>
          
          <div id="app">
            <p>{{message}}</p>
            <cpn :receivedata="givetoson"></cpn>
            <cpn></cpn>
            <!--  <cpn :givetoson="receivedata"></cpn>-->
          </div>
          
          <template id="cpn">
            <div>
              <p>{{son}}</p>
              <p>{{receivedata}}</p>
            </div>
          </template>
          
          <script src="../js/vue.js"></script>
          <script>
            const cpn = {
              template: '#cpn',
              props: {
                receivedata: {
                  type: String,
                  default: 'aaaaaaaa'
                }
              },
              data: () => {
                return {
                  son: '子组件'
                }
              }
            };
          
            const app = new Vue({
              el: '#app',
              data: {
                message: 'hello',
                givetoson: '给子组件的数据',
                required: true
              },
              methods: {},
              components: {
                cpn
              }
            });
          
          
            //props
            //父组件 子组件
          </script>
          
          </body>
          </html>"
          - 练习
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
            
            <div id="app">
                <p>{{message}}</p>
                <cpn :c-message="message"></cpn>
            </div>
            <template id="cpn">
                <div>
                    <p>子组件得到{{cMessage}}</p>
                </div>
            </template>
            <script src="../js/vue.js"></script>
            <script>
                const cpn = {
                    template:'#cpn',
                    props:{
                        cMessage:{
                            type:String,
                            default:'null'
                        }
                    }
                };
            
                const app = new Vue({
                    el:'#app',
                    data:{
                        message:'hello'
                    },
                    methods:{
            
                    },
                    components:{
                        cpn
                    }
                })
            </script>
            
            </body>
            </html>"
        - $emit 子传父
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Title</title>
          </head>
          <body>
          
          <div id="app">
            <p>父组件：{{message}}</p>
            <p>父组件收到子组件信息：{{fromSon}}</p>
            <cpn :c-from="message" @item-click="cpnClick"></cpn>
          </div>
          <template id="cpn">
            <div>
              <p>子组件:{{cMessage}}</p>
              <p>子组件:{{cFrom}}</p>
              <p>当前显示的是：{{currentName}}</p>
              <button v-for="item in categories"
                      @click="btnClick(item)">{{item.name}}
              </button>
            </div>
          </template>
          <script src="../js/vue.js"></script>
          <script>
            const cpn = {
              template: '#cpn',
              data() {
                return {
                  cMessage: '子组件自己的东西',
                  categories: [
                    {id: 'aaa', name: '热门推荐'},
                    {id: 'bbb', name: '手机数码'},
                    {id: 'ccc', name: '家用家电'},
                    {id: 'ddd', name: '电脑办公'}
                  ],
                  currentItem: 'aaa'
                };
              },
              computed: {
                currentName() {
                  return this.categories.find(v => v.id === this.currentItem).name;
                }
              },
              methods: {
                  btnClick(item){
                      this.currentItem=item.id;
                      //传递事件给父组件
                      this.$emit('item-click',item);
                  }
              },
              props: {
                cFrom: {
                  type: String,
                  required: true
                }
              }
            };
          
            const app = new Vue({
              el: '#app',
              data: {
                message: '父组件信息',
                  fromSon:'null'
              },
              methods: {
                  cpnClick(item){
                      console.log("子组件发生事件itemClick ", item);
                      this.fromSon = item.id;
                  }
              },
              components: {
                cpn
              }
            })
          
            //子组件发生事件
            //需要告诉父组件
          </script>
          
          </body>
          </html>"
        - ref 父访问子
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Title</title>
          </head>
          <body>
          
          <div id="app">
            <p @click="pclick">{{message}}</p>
            <button @click="pclick">XX</button>
            <cpn ref="cpn-1"></cpn>
            <cpn ref="cpn-2"></cpn>
            <cpn></cpn>
            <cpn></cpn>
          </div>
          <template id="cpn">
            <div>
              <p>子组件:{{cinfo}}</p>
            </div>
          </template>
          <script src="../js/vue.js"></script>
          <script>
            const app = new Vue({
              el: '#app',
              data: {
                message: 'hello'
              },
              methods: {
                pclick() {
                  this.message = '111';
                  console.log("父组件被点击");
                  // console.log(this.$children[0]);
                  // this.$children[0].showMessage();
          
                    this.$refs['cpn-2'].showMessage();
                }
              },
              components: {
                cpn: {
                  template: '#cpn',
                  methods: {
                    showMessage() {
                      console.log("子组件函数执行");
                      this.cinfo++;
                    }
                  },
                  data() {
                    return {
                      cinfo: 1
                    };
                  }
                }
              }
            })
          </script>
          
          </body>
          </html>"
      - 插槽
        - 无名插槽
          "<!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <title>Title</title>
          </head>
          <body>
          
          <div id="app">
              <p>{{message}}</p>
              <cpn>
                  <button>anniu</button>
              </cpn>
              <cpn>
                  <span>haha</span>
              </cpn>
              <cpn></cpn>
              <cpn></cpn>
              <cpn></cpn>
          </div>
          <template id="cpn">
              <div>
                  <h2>我是组件</h2>
                  <p>aaaaaaaaaaaaaaaaa</p>
                  <slot><button>默认值</button></slot>
              </div>
          </template>
          <script src="../js/vue.js"></script>
          <script>
              const app = new Vue({
                  el:'#app',
                  data:{
                      message:'hello'
                  },
                  methods:{
          
                  },
                  components:{
                      cpn:{
                          template:'#cpn'
                      }
                  }
              })
          
              //插槽 slot
              //扩展性
              //组件里面的插槽
              //可以由外部决定 而不是写死
          </script>
          
          </body>
          </html>"
        - 有名字插槽
          "<!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <title>Title</title>
          </head>
          <body>
          
          <div id="app">
              <p>{{message}}</p>
              <cpn></cpn>
              <cpn><span slot="center">标题</span></cpn>
              <cpn><button slot="left">-<</button></cpn>
          </div>
          <template id="cpn">
              <div>
                  <slot name="left"><span>左边</span></slot>
                  <slot name="center"><span></span>中间</slot>
                  <slot name="right"><span></span>右边</slot>
              </div>
          </template>
          <script src="../js/vue.js"></script>
          <script>
              const app = new Vue({
                  el:'#app',
                  data:{
                      message:'hello'
                  },
                  methods:{
          
                  },
                  components:{
                      cpn:{
                          template:'#cpn'
                      }
                  }
              })
          
              //插槽 slot
              //扩展性
              //组件里面的插槽
              //可以由外部决定 而不是写死
          </script>
          
          </body>
          </html>"
        - 编译作用域
          "<!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <title>Title</title>
          </head>
          <body>
          
          <div id="app">
              <p>{{message}}</p>
              <cpn v-show="isShow"></cpn>
          </div>
          <template id="cpn">
              <div>
                  <h2>我是子组件</h2>
                  <p>我是内容哈哈哈</p>
                  <button v-show="isShow">按钮</button>
              </div>
          </template>
          <script src="../js/vue.js"></script>
          <script>
              const app = new Vue({
                  el:'#app',
                  data:{
                      message:'hello',
                      isShow:true
                  },
                  methods:{
          
                  },
                  components:{
                      cpn:{
                          template:'#cpn'
                      },
                      data(){
                          return{
                              isShow: false
                          };
                      }
                  }
              })
          
              //编译作用域
              //<cpn v-show="isShow"></cpn>
              //这里面读到的是父组件的isShow
              //模板中的 <button v-show="isShow">按钮</button>
              //作用于在组件定义的data()中
          </script>
          
          </body>
          </html>"
        - 作用域插槽 slot.data
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Title</title>
          </head>
          <body>
          
          <div id="app">
            <p>{{message}}</p>
              <cpn></cpn>
            <cpn>
                <template slot-scope="slot">
                    <span>{{slot.send.join(" - ")}}</span>
                </template>
            </cpn>
            <cpn>
                <template slot-scope="slot">
                    <span v-for="item in slot.send">{{item}} * </span>
                </template>
            </cpn>
          </div>
          <template id="cpn">
            <div>
              <slot :send="pLang">
                <ul>
                  <li v-for="item in pLang">{{item}}</li>
                </ul>
              </slot>
            </div>
          </template>
          <script src="../js/vue.js"></script>
          <script>
            const app = new Vue({
              el: '#app',
              data: {
                message: 'hello',
              },
              methods: {},
              components: {
                cpn: {
                  template: '#cpn',
                  data() {
                    return {
                      pLang: ['Java', 'C', 'python']
                    };
                  }
                },
              }
            })
          
            //父组件想改变子组件内数据的显示方法
            //首先需要知道数据
          </script>
          
          </body>
          </html>"
      - 模块化开发
        - JS ES6的模块化
          - html
            "<!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>Title</title>
            </head>
            <body>
            <script src="aaa.js" type="module"></script>
            <script src="bbb.js" type="module"></script>
            </body>
            </html>"
          - aaa.js
            "let name = 'xiaoming';
            let age = 18;
            let flag = true;
            
            const ADDRESS = '北京市';
            
            if(flag){
              console.log(name);
            }
            
            export {
              flag,
              age
            };
            
            export default ADDRESS;"
          - bbb.js
            "import {flag} from "./aaa.js";
            
            if(flag){
              console.log("小明是天才");
            }
            
            import ADDR from "./aaa.js"
            
            console.log(ADDR);
            
            import * as AAA from "./aaa.js";
            
            console.log(AAA.age);"
        - 按照步骤
          - 首先按照node.js 其中自带npm
          - 安装webpack cmd：npm install webpack@3.6.0 -g
            "-g 全局按照"
      - 路由
        - 定义
          "数据从源到目的地的路径
          本质是一个映射表
          
          前端渲染 前后端分离 后端渲染
          
          后端路由
          后端处理url和页面的关系
          
          前后端分离
          	网页运行效率不高
          
          前端路由 - 单页面富应用 SPA
          整个网站只有一个HTML页面
          前端路由 配置映射关系 url还是会变化，但是请求静态资源
          
          -----------------
          
          前端路由实现方式：
          	改变url，页面不要全部刷新
          方法一： location.hash = 'aaa'
          	注意：改 location.href 会刷新
          方法二：history.pushState({},'','home')
          	history.back() 退栈
          	history.forward()
          	history.go(-1)
          方法三：history.replaceState({},'','aaa')
          "
          - vue-router
            "适合构建单页面应用
            首先安装 "
        - 初步使用
          - 创建两个组件
            - Home.vue
              "<template>
                <div>
                  <h2>我是首页</h2>
                </div>
              </template>
              
              <script>
                export default {
                  name: "Home"
                }
              </script>
              
              <style scoped>
              div{
                color: blue;
              }
              </style>"
            - About.vue
              "<template>
                <div>
                  <h2>我是关于</h2>
                </div>
              </template>
              
              <script>
                export default {
                  name: "About"
                }
              </script>
              
              <style scoped>
              div{
                color: red;
              }
              </style>"
          - 修改路由配置文件src/router/index.js
            "import Vue from 'vue'
            import Router from 'vue-router'
            import Home from '../components/Home'
            import About from '../components/About'
            
            Vue.use(Router)
            
            export default new Router({
              //配置映射关系
              routes: [
                {
                  path: '/home',
                  component: Home
                },
                {
                  path: '/about',
                  //这里是component 不是components
                  component: About
                }
              ]
            })"
          - 在App.vue中使用router-link和router-view
            "<template>
              <div id="app">
                <h2>头信息</h2>
                <div>
                  <router-link to="/home">首页</router-link>
                  <router-link to="/about">关于</router-link>
                  <router-view/>
                </div>
                <h2>尾巴信息</h2>
              </div>
            </template>
            
            <script>
            export default {
              name: 'App'
            }
            </script>
            
            <style>
              
            </style>"
          - main.js中Vue的{}中加入index.js导出的router
            "import Vue from 'vue'
            import App from './App'
            import router from './router'
            
            Vue.config.productionTip = false
            
            /* eslint-disable no-new */
            new Vue({
              el: '#app',
              //使用路由
              router,
              render: h => h(App)
            })"
        - 路由相关
          - 默认路由设置 redirect
            "在index.js中假入
            {
              path:'',//首页
              redirect:'/home'//重定向到/home
            }"
          - hash路由改html5历史路由 mode:'history'
            "index.js
            
            export default new Router({
              //配置映射关系
              routes: [...],
              //默认是hash路由，这里改成html5的历史栈
              mode:'history'
            })"
          - 动态路由 /user/:id
            "如/user/zhangsan
            
            index.js
            ---------
            {
              path:'/user/:userId',
              component:User
            }
            
            
            router-link
            --------------
            <router-link :to="/user/+userId" tag="button" replace>用户</router-link>
            
            组件内使用id
            -------------------------------
            <template>
            <div>
              <h2>我是{{userId}}</h2>
            </div>
            </template>
            
            <script>
              export default {
                name: "User",
                computed:{
                  userId(){
                    return this.$route.params.userId;
                  }
                }
              }
            </script>"
          - <router-link> replace 禁止返回
          - 嵌套路由 routers children[]  注意相对路径的写法
            "首先/home显示首页信息 
            其中再有/home/news在首页div内部显示news
            
            方法：
            建立要显示的额组件HomeNews.vue
            -------------------------------------------
            <template>
              <p>我是home下的news</p>
            </template>
            
            <script>
              export default {
                name: "HomeNews"
              }
            </script>
            
            <style scoped>
            
            </style>
            
            
            index.js 中 children数组
            --------------------------
            {
              path: '/home',
              component: Home,
              children:[
                {
            //注意，没有/标记
                  path:'news',
                  component:HomeNews
                }
              ]
            },
            
            
            在Home组件中配置<router->，注意是完整路径
            ---------------------
            <template>
              <div>
                <h2>我是首页</h2>
                <router-link to="/home/news">新闻</router-link>
                <router-link to="/home/message">消息</router-link>
                <router-view/>
              </div>
            </template>
            
            <script>
              export default {
                name: "Home"
              }
            </script>
            
            <style scoped>
            div{
              color: blue;
            }
            </style>"
          - 嵌套路由的默认路由
            "{
              path: '/home',
              component: Home,
              children:[
                {
                  path:'',
                  component:HomeNews
                }
                ,{
                  path:'news',
                  component:HomeNews
                },
                {
                  path: 'message',
                  component:HomeMessage
                }
              ]
            },"
          - 导航守卫 - 监听跳转的过程 router.beforeEach()
            "//前置钩子 to-目的路径 from-来自路径 next-跳转函数，不用就不会跳转
            router.beforeEach(((to, from, next) => {
              document.title=to.matched[0].meta.title;
              next();//跳转过程
            }));
            
            ------------------
            在每个route中的meta对象中可以放信息
            {
              path: '/about',
              //这里是component 不是components
              component: About,
              meta:{
                title:'关于'
              }
            },
            {
              path:'/user/:userId',
              component:User,
              meta:{
                title:'用户'
              }
            },"
            - 目的：修改标题 document.title
            - 还有组件、路由独享守卫
        - 渲染/信息传递相关
          - 活跃<router-link>类：router-link-active
            "可以设置属性
            
            可以修改：
            <router-link> 中active-class="XXX"
            或者index.js
            
            //默认是hash路由，这里改成html5的历史栈
            mode:'history',
            //活跃组件的类
            //linkActiveClass:'aaa'
            "
          - <router-link> tag属性修改渲染组件
            "<router-link to="/home" tag="button">首页</router-link>
            <router-link to="/about" tag="button">关于</router-link>"
          - 两种参数传递
            - 拿到当前路由(路径/url)
              "this.$route.pat"
            - params => /user/id
              - 拿到动态路由参数 :userId
                "this.$route.params.userId
                
                前面设置：
                index.js
                ---------
                {
                  path:'/user/:userId',
                  component:User
                }
                
                router-link
                --------------
                <router-link :to="/user/+userId" tag="button" replace>用户</router-link>
                
                "userId"就是data属性内
                "
            - query => /user?id=id
              "第一步，router-link的to属性设为对象
              <router-link :to="profileObj" tag="button" replace>档案</router-link>
              
              第二步，对象内部为：path和query对象
              profileObj: {
                path: '/profile',
                query: {
                  name: 'mdk',
                  height: '1.52',
                  age: 12
                }
              }
              
              第三步，在组件中使用$route.query.xxx获得信息
              <template>
                <div>
                  <h2>我是新的用户界面profile</h2>
                  <p>我是{{$route.query.name}}</p>
                  <p>{{$route.query.height}}</p>
                  <p>{{$route.query.age}}</p>
                </div>
              </template>"
          - $route 和 $router 区别
            "当前路径，可以拿params 和 query
            路由控制器，包含全部的路由"
          - keep-alive 组件缓存 - 不然每次都会新建组件
            "keep-alive包裹的组件，会缓存
            这样生命周期是actived/deactivated
            而不是created/destroy
            
            exclude="Profile" 表示 profile组件不会缓存
            -----------------------
            <keep-alive exclude="Profile">
              <router-view/>
            </keep-alive>"
        - 路由懒加载 - 打包一起的js文件拆开 - 防止加载文件太大
          "把index.js中import改为
          
          // import Home from '../components/Home'
          // import About from '../components/About'
          // import User from '../components/User'
          
          const Home = ()=>import('../components/Home');
          const About = ()=>import('../components/About');
          const User = ()=>import('../components/User');"
        - 踩坑 - <router-view>不显示
          "这里的数组应该是routes而不是routers
          --------------------------------
          const router  = new VueRouter({
            routes:["
      - Vuex - 全局变量
        - 简单配置&实用
          - 安装 npm install vuex --save
          - 在src下创建store文件夹，内创建index.js
            "import Vue from "vue";
            import Vuex from "vuex"
            
            //安装插件
            Vue.use(Vuex);
            
            //创建对象
            const store = new Vuex.Store({
              state:{
                counter:100
              },
              mutations:{
            
              },
              actions:{
            
              },
              getters:{
            
              },
              modules:{
            
              }
            });
            
            //导出
            export default store;"
          - 在main.js中加入store
            "import Vue from 'vue'
            import App from './App'
            
            Vue.config.productionTip = false;
            
            import store from "./store";
            
            /* eslint-disable no-new */
            new Vue({
              el: '#app',
              store,
              render: h => h(App)
            })"
          - 在组件中的使用方法：$store.state.XX变量名
        - 使用变量：this.$store.state.XXX
        - 改变变量：两步走 mutations + commit
          "首先在store/index.js中增加：mutations
          -------------------------
          import Vue from "vue";
          import Vuex from "vuex"
          
          //安装插件
          Vue.use(Vuex);
          
          //创建对象
          const store = new Vuex.Store({
            state:{
              counter:100
            },
            mutations:{
              //定义方法
              counter_increment(state){
                state.counter++;
              },
              counter_decrement(state){
                state.counter--;
              },
            },
            actions:{
          
            },
            getters:{
          
            },
            modules:{
          
            }
          });
          
          //导出
          export default store;
          
          
          然后使用commit
          -----------------------------
          methods:{
            add(){
              this.$store.commit('counter_increment');
            },
            sub(){
              this.$store.commit('counter_decrement');
            }
          }"
        - 详细介绍
          - state 单一状态树 single source of truth
            "只用一个store"
          - Getters使用 - 类似computed 计算属性
            "一。定义Getter中方法
            -------------------------------------
            getters:{
              powerCounter(state){
                return state.counter * state.counter;
              }
            },
            
            二。使用
            ----------------------------------------
            $store.getters.powerCounter"
          - Getters 传参数 - 返回函数
            "getters:{
              powerCounter(state){
                return state.counter * state.counter;
              },
              showSelf(){
                return function (obj) {
                  return obj;
                }
              }
            },
            
            
            使用
            -----------------------
            <h2>{{$store.getters.showSelf('xxxx')}}</h2>"
          - mutations - 函数传参
            "函数第二个参数，即传参
            ----------------------------
            mutations:{
              //定义方法
              counter_incrementBy(state,num){
                state.counter+=num;
              }
            },
            
            使用 (函数名 + 传参)
            --------------------
            this.$store.commit('counter_incrementBy',5);
            
            第一个参数是state 可以方便的拿到变量
            第二个参数，可以传参
            函数名 叫做 事件类型
            函数体 叫做 回调函数"
          - mutations - 传参二 payload
          - mutations - 函数名 在第三方固定
            "[INCREMRNT](){
            //
            }
            
            就是字符串
            -----------------
            ['functionName'](){}"
          - 相应规则 - 怎么强行响应渲染 Vue.set/delete
            "事先定义的mutations的变量，是响应式的
            
            Vue.set(state.XXX,'key','val')
            Vue.delete(state.XXX,'key','val')"
          - actions 同步方法
            "因为若mutations中的方法是异步改变数据
            调试工具中无法记录
            
            一。在index.js中的actions加入异步方法
            注意异步方法接受参数context 即store本身
            注意异步方法中不要直接修改变量，利用commit
            --------------------
            actions:{
              counter_increment_async_actions(context){
                setTimeout(()=>{
                  return context.commit('counter_increment');
                },1000);
              }
            },
            
            
            
            使用actions中的异步方法
            dispatch(‘异步方法名’)
            -----------------------
            this.$store.dispatch('counter_increment_async_actions');"
          - modules 模块划分 里面又是store
            "modules:{
              aModules:{
                state:{name:'aaa'},
                mutations:{},
                actions:{},
                getters:{}
              },
              bModules:{
                state:{},
                mutations:{},
                actions:{},
                getters:{}
              }
            }
            
            使用
            -----------------------
            $store.state.aModules.name
            $store.commit('函数名')//会自己查找"
          - 重构 把state mutations ... 提出来变成js文件然后倒入
      - 网络模块封装 (141
        - Vue中发送网络请求有很多方式
          "不用传统的ajax 难以配置
          一般直接使用jQuery-Ajax
          但是Vue中不用JQuery
          Vue-resource 可惜不更新了
          选择axios
          jsonp"
        - 简单使用axios
          "支持多种方式
          request
          get
          delete"
          - 安装 npm install axios --save
          - 简单使用
            "axios({/*请求*/}).then((res)=>{获得结果})
            
            实例
            -----------------------------------
            //导入
            import axios from 'axios'
            
            //默认发送get请求
            axios({
              url:'http://123.207.32.32:8000/home/multidata'
            }).then(res=>{
              console.log("axios访问http://123.207.32.32:8000/home/multidata")
              console.log(res);
            });"
          - {url:'请求地址'}
          - {method:'get/post...请求方法'}
          - {params:{name:value...请求参数}} // for get 请求
          - {data:{key:value...}} //for post请求
          - {timeout:5} 超时时间
          - ⭐ JSON数据格式headers: {'Content-Type': 'application/json'}
          - 并发请求 axios.all([axios(),axios()]).then(res=>{res为数组})
          - 全局配置
            - url重复的前缀
              "axios.default.baseURL = 'http://123.207.32.32:8000'"
            - 超时时间5s 也是重复代码
          - 例子
            - 一
              "ajax(){
                axios({
                  url:'http://123.207.32.32:8000/home/data',
                  method:'get',
                  params:{
                    type:'pop',
                    page:1
                  }
                }).then(res=>{
                  console.log("axios访问http://123.207.32.32:8000/home/data");
                  console.log(res);
                });"
            - 二 并发同步请求
              "axios.all([
                axios({url:'http://123.207.32.32:8000/home/multidata'}),
                axios({url:'http://123.207.32.32:8000/home/data'})
              ]).then(res=>{
                console.log(res);
              });"
        - axios实例
          - 分布式服务器 nginx 代理服务器
          - 实例
            "const instance = axios.create({
              baseURL:'',
              timeout:5000
            });
            
            instance.get({})
            
            instance({})"
        - Vue封装axios
          - 为什么要封装？不封装，每个Vue文件中，对第三方依赖太强，如果要换，很困难
          - 封装代码
            "import axios from 'axios';
            
            export function request(config){
              const instance = axios.create({
                baseURL: '',
                timeout: 5000
              });
            
              //发送网络请求
              return  instance(config);
            }
            
            
            //-----------------方法二
            // export function request(config) {
            //   return new Promise(((resolve, reject) => {
            //     //创建axios实例
            //     const instance = axios.create({
            //       baseURL: '',
            //       timeout: 5000
            //     });
            //
            //     //发送网络请求
            //     instance(config)
            //       .then(res => {
            //         resolve(res);
            //       })
            //       .catch(e => {
            //         reject(e);
            //       });
            //   }));
            // } "
        - 拦截器
          - 拦截请求过程
            "查看有没有某个请求头
            
            显示动画
            
            请求拦截
            响应拦截"
          - 代码
            "//拦截器
            //拦截请求
            instance.interceptors.request.use(config => {
                //拦截成功请求
                console.log(config);
            
                //可以修改config
            
                //显示动画
            
                return config;
              },
              error => {
                //拦截失败请求
                console.log(error);
              }
            );
            
            //拦截响应
            instance.interceptors.response.use(res => {
              //可以修改结果等
              return res;
            }, error => {
              
              return error;
            });"
        - 附录 jsonp.js
          "//Jsonp(JSON with Padding) 是 json 的一种"使用模式"，
          // 可以让网页从别的域名（网站）那获取资料，即跨域读取数据。
          // 为什么我们从不同的域（网站）访问数据需要一个特殊的技术( JSONP )呢？
          // 这是因为同源策略。
          // 同源策略，它是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。
          
          
          let count = 1;
          export default function originPJSONP(option) {
            //提取url
            const url = option.url;
          
            //在body中创造script标签
            const body = document.getElementsByTagName('body')[0];
            const script = document.createElement('script');
          
            //内部产生不重复的callback
            const callback = 'jsonp' + count++;
          
            //监听window 上的jsonp 调用
            return new Promise(((resolve, reject) => {
              try {
                window[callback] = function (result) {
                  body.removeChild(script);
                  resolve(result);
                }
                const params = handleParam(option.date);
                script.src = url + "?callback=" + callback + params;
                body.appendChild(script);
              } catch (e) {
                body.removeChild(script);
                reject(e);
              }
            }));
          }
          
          function handleParam(data) {
            let url = '';
            for (let key in data) {
              let value = data[key] !== undefined ? data[key] : '';
              url += `&${key}=${encodeURIComponent(value)}`;
            }
          
            return url;
          }"
      - 小Tip
        - 在vue的<style>中引入css文件@import 
          "<style>
            @import "./assets/css/base.css";
          </style>"
      - 练习
        - TabBar
          - 原代码
            - TabBar.vue
              "<template>
                <div id="tab-bar">
                  <slot></slot>
              
              <!--    <div class="tab-bar-item">-->
              <!--      <img src="../../assets/img/tabbar/home.gif" alt="home">-->
              <!--      <div>首页</div>-->
              <!--    </div>-->
              <!--    <div class="tab-bar-item">-->
              <!--      <img src="../../assets/img/tabbar/catalogue.gif" alt="catalogue">-->
              <!--      <div>分类</div>-->
              <!--    </div>-->
              <!--    <div class="tab-bar-item">-->
              <!--      <img src="../../assets/img/tabbar/shopcart.gif" alt="shop-cart">-->
              <!--      <div>购物车</div>-->
              <!--    </div>-->
              <!--    <div class="tab-bar-item">-->
              <!--      <img src="../../assets/img/tabbar/profile.gif" alt="profile">-->
              <!--      <div>我的</div>-->
              <!--    </div>-->
                </div>
              </template>
              
              <script>
                export default {
                  name: "TabBar"
                }
              </script>
              
              <style scoped>
              
                #tab-bar {
                  display: flex;
                  /*display:flex 是一种布局方式。
                  它即可以应用于容器中，也可以应用于行内元素。
                  是W3C提出的一种新的方案，可以简便、完整、
                  响应式地实现各种页面布局。目前，它已经得到
                  了所有浏览器的支持。*/
                  /*背景颜色*/
                  background-color: #f6f6f6;
                  background-color: white;
              
                  position: fixed;
                  left: 0;
                  right: 0;
                  bottom: 0;
              
                  box-shadow: 0 -1px 1px rgba(100, 100, 100, 0.1);
                }
              </style>"
            - TabBarItem.vue
              "<template>
                <div>
                  <TabBar>
                    <TabBarItem path="/home" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/home.gif" alt="home">
                      <img slot="item-icon-active" src="../assets/img/tabbar/home_active.gif" alt="home_active">
                      <div slot="item-text">首页</div>
                    </TabBarItem>
                    <TabBarItem path="/catalogue" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/catalogue.gif" alt="catalogue">
                      <img slot="item-icon-active" src="../assets/img/tabbar/catalogue_active.gif" alt="catalogue">
                      <div slot="item-text">分类</div>
                    </TabBarItem>
                    <TabBarItem path="/shopcart" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/shopcart.gif" alt="shopcart">
                      <img slot="item-icon-active" src="../assets/img/tabbar/shopcart_activate.gif" alt="shopcart_active">
                      <div slot="item-text">购物车</div>
                    </TabBarItem>
                    <TabBarItem path="/profile" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/profile.gif" alt="profile">
                      <img slot="item-icon-active" src="../assets/img/tabbar/profile_active.gif" alt="profile_active">
                      <div slot="item-text">我的</div>
                    </TabBarItem>
                  </TabBar>
                </div>
              </template>
              
              <script>
                import TabBar from "./tabbar/TabBar";
                import TabBarItem from "./tabbar/TabBarItem";
                export default {
                  name: "MainTabBar",
                  components: {TabBarItem, TabBar},
                  comments:{
                    TabBar,
                    TabBarItem
                  }
                }
              </script>
              
              <style scoped>
                /*引入外部CSS文件*/
                @import "../assets/css/base.css";
              </style>"
            - 用法MainTabBar.vue
              "<template>
                <div>
                  <TabBar>
                    <TabBarItem path="/home" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/home.gif" alt="home">
                      <img slot="item-icon-active" src="../assets/img/tabbar/home_active.gif" alt="home_active">
                      <div slot="item-text">首页</div>
                    </TabBarItem>
                    <TabBarItem path="/catalogue" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/catalogue.gif" alt="catalogue">
                      <img slot="item-icon-active" src="../assets/img/tabbar/catalogue_active.gif" alt="catalogue">
                      <div slot="item-text">分类</div>
                    </TabBarItem>
                    <TabBarItem path="/shopcart" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/shopcart.gif" alt="shopcart">
                      <img slot="item-icon-active" src="../assets/img/tabbar/shopcart_activate.gif" alt="shopcart_active">
                      <div slot="item-text">购物车</div>
                    </TabBarItem>
                    <TabBarItem path="/profile" activeColor="pink">
                      <img slot="item-icon" src="../assets/img/tabbar/profile.gif" alt="profile">
                      <img slot="item-icon-active" src="../assets/img/tabbar/profile_active.gif" alt="profile_active">
                      <div slot="item-text">我的</div>
                    </TabBarItem>
                  </TabBar>
                </div>
              </template>
              
              <script>
                import TabBar from "./tabbar/TabBar";
                import TabBarItem from "./tabbar/TabBarItem";
                export default {
                  name: "MainTabBar",
                  components: {TabBarItem, TabBar},
                  comments:{
                    TabBar,
                    TabBarItem
                  }
                }
              </script>
              
              <style scoped>
                /*引入外部CSS文件*/
                @import "../assets/css/base.css";
              </style>"
          - TabBer TabBerItem(img+info)
            "props{link}"
          - tabbaritem 活跃判断，利用$route.path
            "return this.$route.path.indexOf(this.path)!==-1;"
          - 文件夹取别名 @ = src
            "webpack.base.config.js
            -----------------
            alias: {
              '@': resolve('src'),
            }"
        - 项目逻辑
          - 使用脚手架3
            "vue create supermall"
          - 划分目录结果
          - 引入两个CSS文件
            "https://github.com/coderwhy/supermall/blob/master/src/assets/css/base.css
            https://github.com/necolas/normalize.css"
          - 配置别名
            "vue.config.js
            ---------------------------
            module.exports = {
              configureWebpack:{
                resolve:{
                  alias:{
                    'assets':'@/assets',
                    'common':'@/common',
                    'components':'@/components',
                    'network':'@/network',
                    'views':'@/views',
                  }
                }
              }
            };"
          - .editorconfig 代码风格文件
    - supermall项目 作废
      - 创建项目 vue create supermall
        "选择features
        - 只是用Babel (主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法)
        - Where do you prefer placing config for Babel, ESLint, etc.? 放在独立文件夹
        "
    - 学习笔记二（边学边背诵）
      - Vue 概述
        "2014-2 发布
        Vue /view/
        渐进式 ：
        	声明式渲染 - 组件系统 - 客户端路由 - 集中状态该案例Vuew - 构建
          可以用其中的几个
        js框架 - 提供基础服务
        虚拟DOM  - 高翔更新一部分内容"
        - MVVM设计思想
          "页面view显示数据
          数据来自model(JS中的对象)
          但是页面和js对象不直接交互
          借助Vue，即viewModel进行交互"
      - 使用Vue
        - 非组件形式
          "1. 要渲染的<div>写在js代码的前面!
          2. <div>定义id属性
          3.0 导入Vue: <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
          3. new Vue({})传入JSON
          3. el:'#id'
          4. data{key-valuve}"
        - NPM安装
          "# 最新稳定版
          $ npm install vue"
        - 脚手架 - 方便单应用开发
          "Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。更多详情可查阅 Vue CLI 的文档。"
        - 完整版？编译器？运行时？
          "完整版：同时包含编译器和运行时的版本。
          
          编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。
          
          运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。
          
          当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。"
      - 数据渲染
        - 渲染到页面(DOM文本)
          - 胡子语法 {{msg}}
        - 渲染到html标签的属性
          - <div v-bind:属性名="msg">
          - 解决闪烁问题 v-clock
            "CSS：
            [v-cloak] {
              display: none;
            }
            HTML：
            <div v-cloak>
              {{ message }}
            </div>"
          - 绑定到class属性的简答方法 -> 样式绑定
            "CSS：
            .spancolor{
                color: red;
            }
            
            html：
            <div>
                <span :class="{spancolor:isRed}">文字颜色</span>
                <button @click="isRed=!isRed">X</button>
            </div>
            
            vue：
            data: isRed:true"
        - 过滤器 用于格式化数据
      - 指令(带有 v- 前缀的特殊 attribute)
        - v-bind 绑定到html标签的属性 (简写:)
        - v-if="bool" 元素是否渲染
        - v-for='(e,id) in arr' 列表渲染
          "<li v-for="todo in todos">{{ todo.text }}</li>"
          - :key='id' 帮助Vue区分不同元素，提高性能。一般和v-for连用
          - for内部的(e,id)也可以用在属性绑定中，这样可以一同创建多个函数
        - v-show 即display=none 是否显示
        - v-on 事件监听 (简写@)
          - 点击事件 v-on:click="fun"
            "<span v-text="num"></span>
            <button @click="num++">+</button>"
          - 按键事件 v-on:keyup.enter='fun'
            ".delete 按删除键
            .65  -> 按键 a
             等等..."
            - 可以自定义按键修饰符Vue.config.keyCodes.a=65
          - 函数传参($event)
        - 事件修饰符
          - v-click.stop 阻止冒泡
            "父组件和子组件都定义了行为
            但是子组件处理了行为后不想传递给父组件，那就阻止冒泡"
          - v-click.prevent 阻止默认行为
        - v-model 双向绑定(指的是在页面上可以控制数据)
          "<div id="app">
            <p>{{ message }}</p>
            <input v-model="message">
          </div>"
          - 绑定checkbox，图片是H图吗
            "<body>
            <div id="app">
                <input type="checkbox" name="isEro" v-model="isEro"> H
                <div>{{isEro}}</div>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            <script>
                const app = new Vue({
                    el:'#app',
                    data:function () {
                        return{
                            isEro:true
                        };
                    }
                });
            </script>
            </body>"
          - 绑定textarea
            "<textarea name="desc" id="desc01" cols="30" rows="10" v-model="desc"></textarea>
            <div>{{desc}}</div>"
        - v-clock 这个指令保持在元素上直到关联实例结束编译
          "可以用于渲染前的控制，如不显示
          示例：
          CSS：
          [v-cloak] {
            display: none;
          }
          HTML：
          <div v-cloak>
            {{ message }}
          </div>"
        - v-text 代替{{}}
          "<div>{{msg}}</div>
          等于
          <div v-text='msg'></div>"
        - v-html 类似 v-text，但是作为HTML文本 ，有安全隐患 @Deprecated 
        - v-pre 不渲染，直接显示
          "<div v-pre>{{msg}}</div>
          显示原始信息
          {{msg}}"
        - v-once 没有响应式，只渲染一次
        - 自定义指令Vue.directive('name',{inserted:function(el){拿到指令所在元素}}) 等等
      - Vue({传入的JSON属性})
        - el: '#app'
        - data:
        - methods:{name:fun()}
        - computed 计算属性
          "内传函数"
        - components{} 组件
        - watch 监听属性 一般用于异步方法/开销大
          "<div id="app">
              <input type="text" v-model="name">
              <div>{{name}}</div>
              <div>{{length}}</div>
          </div>
          <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
          <script>
              const app = new Vue({
                  el:'#app',
                  data:function () {
                      return {
                          name:"aaa",
                          length:3
                      };
                  },
                  watch:{
                      name:function (val) {
                          this.length = val.length;
                      }
                  }
              });
          </script>"
          - 案例：注册时验证用户名是否已经存在
            "注意控制触发：失去焦点时才触发"
        - filter 过滤器
          - 外部定义 (全局)
            "1. 定义过滤器 名字+方法
            Vue.filter("filter_name",function (val) {
                return val.charAt(0).toUpperCase() + val.slice(1);
            })
            //注意：方法接受的参数就是要过滤的值，返回值就是处理后的参数
            ---------------------------------------------------------
            
            2. 使用过滤器 类似Linux
            <input type="text" v-model="inputValue">
            <div></div>
            {{inputValue | filter_name}}
            如上可以将用户输入首字母大写
            
            一下为全部内容
            --------------------------------------------------------------
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>05-过滤器</title>
            </head>
            <body>
            <div id="app">
                <div>{{message}}</div>
                <input type="text" v-model="inputValue">
                <div></div>
                {{inputValue | filter_name}}
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            <script>
                Vue.filter("filter_name",function (val) {
                    return val.charAt(0).toUpperCase() + val.slice(1);
                })
            
                const app = new Vue({
                    el:'#app',
                    data:function () {
                        return{
                            message:"学习过滤器",
                            inputValue:''
                        };
                    }
                });
            </script>
            </body>
            </html>"
          - 内部定义 filters:{name:fun()}
            "示例：
            ----------------------
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>05-过滤器</title>
            </head>
            <body>
            <div id="app">
                <div>{{message}}</div>
                <input type="text" v-model="inputValue">
                <div></div>
                {{inputValue | addOne}}
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            <script>
                const app = new Vue({
                    el: '#app',
                    data: function () {
                        return {
                            message: "学习过滤器",
                            inputValue: ''
                        };
                    },
                    filters: {
                        addOne: function (num) {
                            return ++num;
                        }
                    }
                });
            </script>
            </body>
            </html>"
        - 生命周期
          - 创建/挂载
            - beforeCreate
            - created
            - beforeMount
            - mounted
          - 更新
            - beforeUpdate
            - updated
          - 销毁
            - beforeDestory
            - destroyed
      - 内置属性/方法
        - vm.$watch 监视某个data的变化
          "一 v-model.lazy 失去焦点再绑定
          二 watch用于异步验证
          
          <div id="app">
              用户名：<input type="text" name="name" v-model.lazy="name">{{msg}}
              <div>{{name}}</div>
          </div>
          <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
          <script>
              const app = new Vue({
                  el: '#app',
                  data: function () {
                      return {
                          name: "aaa",
                          msg: ''
                      };
                  },
                  watch: {
                      name: function (val) {
                          var that = this;
                          setTimeout(function () {
                              if(val ==='admin'){
                                  that.msg="用户名已存在";
                              }else {
                                  that.msg="用户名可以使用";
                              }
                          },1000)
          
                          this.msg ="正在验证...";
                      }
                  }
              });
          </script>"
      - 组件
        - 非脚手架使用组件@Deprecated 
          - 使用方法 - 全局组件
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>组件</title>
            </head>
            <body>
            <div id="app">
                <cnt></cnt>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            <script>
                Vue.component('cnt',{
                    data:function () {
                        return{
                            cmsg:'hello, cnt'
                        };
                    },
                    template:'<div>{{cmsg}}</div>'
                });
            
                const app = new Vue({
                    el:'#app',
                });
            </script>
            </body>
            </html>"
          - 使用方法 - 局部组件
          - 组件模板必须是单根的
          - JS知识：模板字符串
            "反引号 `` 可以换行
            Java也来一个吧"
        - 组件的名字 hello-world / 不要用驼峰式
        - 数据传递
          - 父传子(自定义html标签的属性)
            "1. 子组件 props:['attri']
            2. 使用时绑定 v-bind:attri="msg"
            3. 父组件有msg数据即可
            
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>组件</title>
            </head>
            <body>
            <div id="app">
                <cnt :getmassage="fromfather"></cnt>
                <cnt :getmassage="fromfather"></cnt>
                <cnt></cnt>
                <cnt></cnt>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            <script>
                Vue.component('cnt',{
                    data:function () {
                        return{
                            cmsg:'hello, cnt'
                        };
                    },
                    props:['getmassage'],
                    template:'<div>{{getmassage}}</div>'
                });
            
                const app = new Vue({
                    el:'#app',
                    data:function () {
                        return{
                            fromfather:'来自父组件'
                        };
                    }
                });
            </script>
            </body>
            </html>"
          - 子传父 自定义事件@click='$emit'
          - 兄弟组件传值
            "利用 事件中心
            使用一个Vue作为事件中心"
        - 插槽 slot
          "template 里面 slot"
          - 匿名插槽 默认内容 
            "1. template 里面 <slot>
            2. 使用时直接写在html内容中 <cnt>内容到插槽</cnt>
            
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>插槽 slot</title>
            </head>
            <body>
            <div id="app">
                <cnt>信息</cnt>
                <cnt></cnt>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            <script>
                Vue.component('cnt',{
                    template:`<div>
            <strong>BUG:</strong>
            <slot>默认</slot>
            </div>`
                })
                const app = new Vue({
                    el:'#app',
                });
            </script>
            </body>
            </html>"
          - 具名插槽
            "1. template 里面 <slot name='取名字'>
            2. 使用 <h1 slot="foot">结尾</h1>
            
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>插槽 slot</title>
            </head>
            <body>
            <div id="app">
                <cnt></cnt>
                <hr>
                <cnt>
            <!--        顺序可以变-->
                    <h1 slot="foot">结尾</h1>
                    <h1>内容</h1>
                    <h1 slot="head">标题</h1>
                </cnt>
            </div>
            <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            <script>
                Vue.component('cnt',{
                    template:`<div>
            <header><slot name="head">无标题</slot></header>
            <slot>默认内容</slot>
            <footer><slot name="foot">无结尾</slot></header>
            </div>`
                })
                const app = new Vue({
                    el:'#app',
                });
            </script>
            </body>
            </html>"
          - 作用域插槽 父组件加工子组件数据
      - ajax相关 异步请求  axios async await
        - 复习 promise
          "promise 承诺"
          - 简单使用
            "new Promise(((resolve, reject) => {
                setTimeout(()=>{
                    resolve('aaaaaa')
                },1000);
            })).then(function (data) {
                console.log(data);
            });"
          - 实例方法
            "p.catch()
            p.then()
            p.finally"
          - 对象方法
            "P.all() //并发处理多个任务，所有完成才下一步
            P.race() // 一个完成就下一步"
        - fetch 学习
          - 基本使用
            "fetch("http://192.168.2.10:8070/test/json/time")
            .then(function (data) {
                return data.text();
            }).then(function (data) {
                console.log(data);
            })"
          - 发送请求
          - 返回JSON格式
            "fetch('http://192.168.2.10:8070/test/json/repeat/zrx',{
                method:'get'
            })
            .then(function (data) {
                console.log(data);
                return data.json();
            }).then(function (data) {
                console.log(data);
                console.log(data.date);
                console.log(data.data);
            })"
        - axios 学习
          - 简单例子
            "axios.get('/aaa')
            .then(ret=>{
            log(ret.data);
            })"
          - get/post/put/delete
          - params:{id:12}
          - 发送json
            "axios.post("http://192.168.2.10:8070/test/json/post/person",{
                name:'zrx',
                age:12
            }).then(ret=>{
                console.log(ret);
            })"
          - 全局设置
            - 全局设置超时时间 axios.defaults.timeout = 3000
            - 全局设置url头 axios.defaults.baseURL = '/aaa'
            - 全局设置请求头
          - 拦截器
            - 请求拦截器 在请求前设置一些信息
            - 响应拦截器
        - async/await 学习
          "ES7 新引入"
          - async 定义函数
          - await 在 async 函数中拿到异步结果
          - 简单示例
            "axios.defaults.baseURL = 'http://192.168.2.10:8070/test';
            
            async function query(name,age) {
                return await axios.post("/json/post/person",{
                    name:name,
                    age:age
                })
            }
            
            query("mdk",13).then(ret=>{
                console.log(ret);
            })
            
            query("zrx",15).then(ret=>{
                console.log(ret);
            })
            
            query("miao",11).then(ret=>{
                console.log(ret);
            })"
          - 多步请求示例
            "async function query2(name,age) {
                const person = await axios.post("/json/post/person",{
                    name:name,
                    age:age
                })
            
                return await axios.get("/json/repeat/" + person.data.data.name);
            }
            
            query2("twice",99).then(data=>{
                console.log(data);
            })"
      - 前端路由 Vue router
        - 简单使用 无cli
          - ①HTML 中的 <router-link>(a链接) <router-view>(占位处)
            "<div id="app">
                <p>router-link 标签 默认渲染为 a 标签</p>
                <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                <router-link to="/user">User</router-link>
                <router-link to="/register">Register</router-link>
            
                <hr>
                <p>router-view 路由占位符</p>
                <p>将来渲染到router-view 所在位置</p>
                <router-view></router-view>
            </div>"
          - ②创建组件 (路由后需要显示的内容)
            "// 创建两个路由到的组件
            const User = {
                template: '<h1>User</h1>'
            };
            
            const Register = {
                template: '<h1>Register</h1>'
            };"
          - ③创建路由对象 VueRouter
            "1. new VueRouter
            2. routes 数组，注意不要写错了
            3. 数组中的json (path 和 component)
            
            const router = new VueRouter({
                // routes 数组，内部为json，每个json 由 path 和 component 组成
                routes: [
                    {
                        path: '/user',
                        component: User
                    },
                    {
                        path: '/register',
                        component: Register
                    }
                ]
            });"
          - ④在Vue根实例中引入路由对象
            "const app = new Vue({
                el: '#app',
                // router 挂载到 Vue 根实例中
                router
            });"
          - 小tip：json中当键和值相同时，可以简写
          - 总结 全部代码 可以运行
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>router</title>
            </head>
            <body>
            <div id="app">
                <p>router-link 标签 默认渲染为 a 标签</p>
                <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                <router-link to="/user">User</router-link>
                <router-link to="/register">Register</router-link>
            
                <hr>
                <p>router-view 路由占位符</p>
                <p>将来渲染到router-view 所在位置</p>
                <router-view></router-view>
            </div>
            <script src="https://unpkg.com/vue/dist/vue.js"></script>
            <!--导入路由-->
            <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
            <script>
                // 创建两个路由到的组件
                const User = {
                    template: '<h1>User</h1>'
                };
            
                const Register = {
                    template: '<h1>Register</h1>'
                };
            
                const router = new VueRouter({
                    // routers 数组，内部为json，每个json 由 path 和 component 组成
                    routes: [
                        {
                            path: '/user',
                            component: User
                        },
                        {
                            path: '/register',
                            component: Register
                        }
                    ]
                });
            
                const app = new Vue({
                    el: '#app',
                    // router 挂载到 Vue 根实例中
                    router
                });
            </script>
            </body>
            </html>"
        - 路由重定向
          "用处：用户访问首页时，就像展现第一个路由结果"
          - 通过路由规则 redirect 实现
            "在路由示例 中的 routes 数组中
            新增：
            {
                path:'/',
                redirect:'/user'
            }"
          - 示例代码 可运行
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>router</title>
            </head>
            <body>
            <div id="app">
                <p>router-link 标签 默认渲染为 a 标签</p>
                <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                <router-link to="/user">User</router-link>
                <router-link to="/register">Register</router-link>
            
                <hr>
                <p>router-view 路由占位符</p>
                <p>将来渲染到router-view 所在位置</p>
                <router-view></router-view>
            </div>
            <script src="https://unpkg.com/vue/dist/vue.js"></script>
            <!--导入路由-->
            <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
            <script>
                // 创建两个路由到的组件
                const User = {
                    template: '<h1>User</h1>'
                };
            
                const Register = {
                    template: '<h1>Register</h1>'
                };
            
                const router = new VueRouter({
                    // routers 数组，内部为json，每个json 由 path 和 component 组成
                    routes: [
                        {
                            //路由重定向
                            path:'/',
                            redirect:'/user'
                        },
                        {
                            path: '/user',
                            component: User
                        },
                        {
                            path: '/register',
                            component: Register
                        }
                    ]
                });
            
                const app = new Vue({
                    el: '#app',
                    // router 挂载到 Vue 根实例中
                    router
                });
            </script>
            </body>
            </html>"
        - 嵌套路由
          "路由显示的组件内部再有路由"
          - ①父组件template中加入<router-link>(a链接) <router-view>(占位处)
            "    const Register = {
                    template: `
                    <div>
                    <h1>Register</h1>
                    <p>路由组件内再放入 router-link router-view</p>
                    <router-link to="/register/tab1">tab1</router-link>
                    <router-link to="/register/tab2">tab2</router-link>
                    <router-view></router-view>
                    </div>
            `
                };"
          - ②编写子路由组件
            "const RegisterTab1 = {
                template: '<h2>tab1</h2>'
            }
            
            const RegisterTab2 = {
                template: '<h2>tab2</h2>'
            }"
          - ③路由对象中的routes 中的父路由加入 children属性
            "{
                path: '/register', component: Register, children: [
                    {path: '/register/tab1', component: RegisterTab1},
                    {path: '/register/tab2', component: RegisterTab2}
                ]
            }"
          - 示例 可运行
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>router</title>
            </head>
            <body>
            <div id="app">
                <p>router-link 标签 默认渲染为 a 标签</p>
                <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                <router-link to="/user">User</router-link>
                <router-link to="/register">Register</router-link>
            
                <hr>
                <p>router-view 路由占位符</p>
                <p>将来渲染到router-view 所在位置</p>
                <router-view></router-view>
            </div>
            <script src="https://unpkg.com/vue/dist/vue.js"></script>
            <!--导入路由-->
            <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
            <script>
                // 创建两个路由到的组件
                const User = {
                    template: '<h1>User</h1>'
                };
            
                const Register = {
                    template: `
                    <div>
                    <h1>Register</h1>
                    <p>路由组件内再放入 router-link router-view</p>
                    <router-link to="/register/tab1">tab1</router-link>
                    <router-link to="/register/tab2">tab2</router-link>
                    <router-view></router-view>
                    </div>
            `
                };
            
                const RegisterTab1 = {
                    template: '<h2>tab1</h2>'
                }
            
                const RegisterTab2 = {
                    template: '<h2>tab2</h2>'
                }
            
                const router = new VueRouter({
                    // routers 数组，内部为json，每个json 由 path 和 component 组成
                    routes: [
                        //路由重定向
                        {path: '/', redirect: '/user'},
                        {path: '/user', component: User},
                        {
                            path: '/register', component: Register, children: [
                                {path: '/register/tab1', component: RegisterTab1},
                                {path: '/register/tab2', component: RegisterTab2}
                            ]
                        },
                    ]
                });
            
                const app = new Vue({
                    el: '#app',
                    // router 挂载到 Vue 根实例中
                    router
                });
            </script>
            </body>
            </html>"
        - 动态路由匹配（路由参数:id）
          "路由地址事先不知道，如用户名"
          - 高耦合方法  $route.params.params // @Deprecated 
            - ①router-link to 地址存在未知参数 /user/233
              "<router-link to="/user/1">User1</router-link>
              <router-link to="/user/2">User2</router-link>
              <router-link to="/user/3">User3</router-link>
              <router-link to="/user/4">User4</router-link>"
            - ②routes数组中使用参数 :params
              "{path: '/user/:uid', component: User}"
            - ③组件中 $route.params.params 可以访问到参数值
              "const User = {
                  template: '<h1>{{$route.params.uid}}</h1>'
              };"
            - 示例 可以运行
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <title>router</title>
              </head>
              <body>
              <div id="app">
                  <p>router-link 标签 默认渲染为 a 标签</p>
                  <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                  <router-link to="/user/1">User1</router-link>
                  <router-link to="/user/2">User2</router-link>
                  <router-link to="/user/3">User3</router-link>
                  <router-link to="/user/4">User4</router-link>
                  <router-link to="/register">Register</router-link>
              
                  <hr>
                  <p>router-view 路由占位符</p>
                  <p>将来渲染到router-view 所在位置</p>
                  <router-view></router-view>
              </div>
              <script src="https://unpkg.com/vue/dist/vue.js"></script>
              <!--导入路由-->
              <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
              <script>
                  // 创建两个路由到的组件
                  const User = {
                      template: '<h1>{{$route.params.uid}}</h1>'
                  };
              
                  const Register = {
                      template: '<h1>Register</h1>'
                  };
              
                  const router = new VueRouter({
                      // routers 数组，内部为json，每个json 由 path 和 component 组成
                      routes: [
                          {path: '/user/:uid', component: User},
                          {path: '/register', component: Register}
                      ]
                  });
              
                  const app = new Vue({
                      el: '#app',
                      // router 挂载到 Vue 根实例中
                      router
                  });
              </script>
              </body>
              </html>"
          - 低耦合方法 props
            - ①router-link 路由路径未知
              "<router-link to="/user/nabfuiabc">User1</router-link>
              <router-link to="/user/156813165">User2</router-link>
              <router-link to="/user/safadf8ydbc">User3</router-link>
              <router-link to="/user/481dv6sv4fs">User4</router-link>"
            - ②routes使用参数路径 并开启props 传递这个参数到组件
              "{path: '/user/:uid', component: User, props: true}"
            - ③在组件中使用props拿到参数
            - 示例代码 可运行
              "<!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <title>router</title>
              </head>
              <body>
              <div id="app">
                  <p>router-link 标签 默认渲染为 a 标签</p>
                  <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                  <router-link to="/user/1">User1</router-link>
                  <router-link to="/user/2">User2</router-link>
                  <router-link to="/user/3">User3</router-link>
                  <router-link to="/user/4">User4</router-link>
                  <router-link to="/register">Register</router-link>
              
                  <hr>
                  <p>router-view 路由占位符</p>
                  <p>将来渲染到router-view 所在位置</p>
                  <router-view></router-view>
              </div>
              <script src="https://unpkg.com/vue/dist/vue.js"></script>
              <!--导入路由-->
              <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
              <script>
                  // 创建两个路由到的组件
                  const User = {
                      template: '<h1>{{uid}}</h1>',
                      props: ['uid']
                  };
              
                  const Register = {
                      template: '<h1>Register</h1>'
                  };
              
                  const router = new VueRouter({
                      // routers 数组，内部为json，每个json 由 path 和 component 组成
                      routes: [
                          {path: '/user/:uid', component: User, props: true},
                          {path: '/register', component: Register}
                      ]
                  });
              
                  const app = new Vue({
                      el: '#app',
                      // router 挂载到 Vue 根实例中
                      router
                  });
              </script>
              </body>
              </html>"
        - 命名路由（给每个路由起名字）
          - ①HTML 中的 <router-link> 中的 to 属性动态绑定
            "<router-link :to="{name:'user',params:{uid:3}}">User</router-link>"
          - ②在路由对象中加入name属性
            "{path:'/user',component:User,name:'user',props:true},"
          - 示例 可运行
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
            <div id="app">
                <p>router-link 标签 默认渲染为 a 标签</p>
                <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                p{命名路由，这样动态绑定to 使用json}
                <router-link :to="{name:'user',params:{uid:3}}">User</router-link>
                <router-link to="/register">Register</router-link>
            
                <hr>
                <p>router-view 路由占位符</p>
                <p>将来渲染到router-view 所在位置</p>
                <router-view></router-view>
            </div>
            <script src="https://unpkg.com/vue/dist/vue.js"></script>
            <!--导入路由-->
            <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
            <script>
                const User = {
                    template: `
                    <div>
                    <h1>User - {{uid}}</h1>
                    </div>
            `,
                    props:['uid']
                };
            
                const Register = {
                    template: `
                    <div>
                    <h1>Register</h1>
                    </div>
            `
                };
            
                const router = new VueRouter({
                    routes:[
                        {path:'/user',component:User,name:'user',props:true},
                        {path:'/register',component:Register}
                    ]
                });
            
                const app = new Vue({
                    el:'#app',
                    router
                });
            </script>
            </body>
            </html>"
        - 编程式导航 ( / 声明式导航) push/go
          "声明式 ：HTML 的 a 标签
          编程式：JS 代码实现跳转"
          - this.$router.push('path')
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
            <div id="app">
                <p>router-link 标签 默认渲染为 a 标签</p>
                <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                <p>命名路由，这样动态绑定to 使用json</p>
                <router-link :to="{name:'user',params:{uid:3}}">User</router-link>
                <router-link to="/register">Register</router-link>
                <hr>
                <p>编程式导航</p>
                <button @click="goRegister">编程式导航</button>
            
                <hr>
                <p>router-view 路由占位符</p>
                <p>将来渲染到router-view 所在位置</p>
                <router-view></router-view>
            </div>
            <script src="https://unpkg.com/vue/dist/vue.js"></script>
            <!--导入路由-->
            <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
            <script>
                const User = {
                    template: `
                    <div>
                    <h1>User - {{uid}}</h1>
                    </div>
            `,
                    props:['uid']
                };
            
                const Register = {
                    template: `
                    <div>
                    <h1>Register</h1>
                    </div>
            `
                };
            
                const router = new VueRouter({
                    routes:[
                        {path:'/user',component:User,name:'user',props:true},
                        {path:'/register',component:Register}
                    ]
                });
            
                const app = new Vue({
                    el:'#app',
                    router,
                    methods:{
                        //编程式导航
                        goRegister(){
                            this.$router.push('/register');
                        }
                    }
                });
            </script>
            </body>
            </html>"
          - this.$router.go(n) 历史记录前进后退 -1 表示后退
            "<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
            <div id="app">
                <p>router-link 标签 默认渲染为 a 标签</p>
                <p>to 属性渲染为 href 属性，默认为 # 开头的 hash 地址</p>
                <p>命名路由，这样动态绑定to 使用json</p>
                <router-link :to="{name:'user',params:{uid:3}}">User</router-link>
                <router-link to="/register">Register</router-link>
                <hr>
                <p>编程式导航</p>
                <button @click="goRegister">编程式导航</button>
            
                <hr>
                <p>router-view 路由占位符</p>
                <p>将来渲染到router-view 所在位置</p>
                <router-view></router-view>
            </div>
            <script src="https://unpkg.com/vue/dist/vue.js"></script>
            <!--导入路由-->
            <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
            <script>
                const User = {
                    template: `
                    <div>
                    <h1>User - {{uid}}</h1>
                    </div>
            `,
                    props:['uid']
                };
            
                const Register = {
                    template: `
                    <div>
                    <h1>Register</h1>
                    <button @click="back">后退</button>
                    </div>
            `,
                    methods: {
                        back(){
                            this.$router.go(-1);
                        }
                    }
                };
            
                const router = new VueRouter({
                    routes:[
                        {path:'/user',component:User,name:'user',props:true},
                        {path:'/register',component:Register}
                    ]
                });
            
                const app = new Vue({
                    el:'#app',
                    router,
                    methods:{
                        //编程式导航
                        goRegister(){
                            this.$router.push('/register');
                        }
                    }
                });
            </script>
            </body>
            </html>"
      - webpack
        - Vue 运行/打包
          - "serve": "vue-cli-service serve" 运行一个开发环境服务器
          - "build": "vue-cli-service build" 打包，得到一个生产环境可用的包
            "输出到dist文件夹"
        - Vue 脚手架
      - Element-UI Vue组件库 (方便你我他)
        - 网站 https://element.eleme.cn/#/zh-CN 
        - 安装 npm i element-ui -S
        - 使用 
          "//导入组件库
          import ElementUI from 'element-ui';
          //导入样式
          import 'element-ui/lib/theme-chalk/index.css';
          
          //使用
          Vue.use(ElementUI);
          
          //最后在网站中找相关组件就行了
          
          在main.js中使用
          --------------------------
          import Vue from 'vue'
          import ElementUI from "element-ui";
          import 'element-ui/lib/theme-chalk/index.css';
          import App from './App.vue'
          
          Vue.config.productionTip = false
          
          Vue.use(ElementUI);
          new Vue({
            render: h => h(App),
          }).$mount('#app')"
    - Vue 项目实战 电商后台管理系统 20200309~
      "功能：用户账号、商品分类、商品信息、订单、数据统计...
      
      前后端分离 前端：Vue SPA 项目"
      - 项目初始化 等
        "1. 安装 Vue 脚手架
        	npm install -g @vue/cli
        	安装的是 @vue/cli 4.2.3 版本
        2. 利用脚手架配置项目，使用web-GUI界面
        	vue ui
        3. 需要安装的功能
        	babel
        	router
        	Linter / Formmatter
        	使用独立的配置文件
        4. 不适用 history 模式的路由，因为兼容性不好/ linter 配置 standard config 模式 / 其他不变
        5. 创建项目! 进入项目仪表盘
        6. 安装插件 element-ui 组件库
        	在 插件中 添加新插件 vue-cli-plugin-element
        	配置创建 fully import -> on demand
        7.  安装依赖 axios 库 运行依赖
        8. 托管GIT
        
        -------------------
        其他
        让webstorm 识别vue cli3项目中的@路径别名
        在setting -> languages&frameworks -> webpack里选择配置文件路径为 node_modules/@vue/cli-service/webpack.config.js即可。"
      - 先不看了，学spring security...
        "https://www.bilibili.com/video/av75785188?p=156"
    - 新的API
      - render:h=>h(App)
  - 其他
    - three.js
      - 入门 旋转的立方体
        - doc
          "Creating a scene
          The goal of this section is to give a brief introduction to three.js. We will start by setting up a scene, with a spinning cube. A working example is provided at the bottom of the page in case you get stuck and need help.
          
          Before we start
          Before you can use three.js, you need somewhere to display it. Save the following HTML to a file on your computer, along with a copy of three.js in the js/ directory, and open it in your browser.
          
          <!DOCTYPE html>
          <html>
          	<head>
          		<meta charset="utf-8">
          		<title>My first three.js app</title>
          		<style>
          			body { margin: 0; }
          			canvas { width: 100%; height: 100% }
          		</style>
          	</head>
          	<body>
          		<script src="js/three.js"></script>
          		<script>
          			// Our Javascript will go here.
          		</script>
          	</body>
          </html>
          That's all. All the code below goes into the empty <script> tag.
          
          Creating the scene
          To actually be able to display anything with three.js, we need three things: scene, camera and renderer, so that we can render the scene with camera.
          
          var scene = new THREE.Scene();
          var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
          
          var renderer = new THREE.WebGLRenderer();
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );
          Let's take a moment to explain what's going on here. We have now set up the scene, our camera and the renderer.
          
          There are a few different cameras in three.js. For now, let's use a PerspectiveCamera.
          
          The first attribute is the field of view. FOV is the extent of the scene that is seen on the display at any given moment. The value is in degrees.
          
          The second one is the aspect ratio. You almost always want to use the width of the element divided by the height, or you'll get the same result as when you play old movies on a widescreen TV - the image looks squished.
          
          The next two attributes are the near and far clipping plane. What that means, is that objects further away from the camera than the value of far or closer than near won't be rendered. You don't have to worry about this now, but you may want to use other values in your apps to get better performance.
          
          Next up is the renderer. This is where the magic happens. In addition to the WebGLRenderer we use here, three.js comes with a few others, often used as fallbacks for users with older browsers or for those who don't have WebGL support for some reason.
          
          In addition to creating the renderer instance, we also need to set the size at which we want it to render our app. It's a good idea to use the width and height of the area we want to fill with our app - in this case, the width and height of the browser window. For performance intensive apps, you can also give setSize smaller values, like window.innerWidth/2 and window.innerHeight/2, which will make the app render at half size.
          
          If you wish to keep the size of your app but render it at a lower resolution, you can do so by calling setSize with false as updateStyle (the third argument). For example, setSize(window.innerWidth/2, window.innerHeight/2, false) will render your app at half resolution, given that your <canvas> has 100% width and height.
          
          Last but not least, we add the renderer element to our HTML document. This is a <canvas> element the renderer uses to display the scene to us.
          
          "That's all good, but where's that cube you promised?" Let's add it now.
          
          var geometry = new THREE.BoxGeometry( 1, 1, 1 );
          var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          var cube = new THREE.Mesh( geometry, material );
          scene.add( cube );
          
          camera.position.z = 5;
          To create a cube, we need a BoxGeometry. This is an object that contains all the points (vertices) and fill (faces) of the cube. We'll explore this more in the future.
          
          In addition to the geometry, we need a material to color it. Three.js comes with several materials, but we'll stick to the MeshBasicMaterial for now. All materials take an object of properties which will be applied to them. To keep things very simple, we only supply a color attribute of 0x00ff00, which is green. This works the same way that colors work in CSS or Photoshop (hex colors).
          
          The third thing we need is a Mesh. A mesh is an object that takes a geometry, and applies a material to it, which we then can insert to our scene, and move freely around.
          
          By default, when we call scene.add(), the thing we add will be added to the coordinates (0,0,0). This would cause both the camera and the cube to be inside each other. To avoid this, we simply move the camera out a bit.
          
          Rendering the scene
          If you copied the code from above into the HTML file we created earlier, you wouldn't be able to see anything. This is because we're not actually rendering anything yet. For that, we need what's called a render or animate loop.
          
          function animate() {
          	requestAnimationFrame( animate );
          	renderer.render( scene, camera );
          }
          animate();
          This will create a loop that causes the renderer to draw the scene every time the screen is refreshed (on a typical screen this means 60 times per second). If you're new to writing games in the browser, you might say "why don't we just create a setInterval ?" The thing is - we could, but requestAnimationFrame has a number of advantages. Perhaps the most important one is that it pauses when the user navigates to another browser tab, hence not wasting their precious processing power and battery life.
          
          Animating the cube
          If you insert all the code above into the file you created before we began, you should see a green box. Let's make it all a little more interesting by rotating it.
          
          Add the following right above the renderer.render call in your animate function:
          
          cube.rotation.x += 0.01;
          cube.rotation.y += 0.01;
          This will be run every frame (normally 60 times per second), and give the cube a nice rotation animation. Basically, anything you want to move or change while the app is running has to go through the animate loop. You can of course call other functions from there, so that you don't end up with a animate function that's hundreds of lines.
          
          The result
          Congratulations! You have now completed your first three.js application. It's simple, you have to start somewhere.
          
          The full code is available below and as an editable live example. Play around with it to get a better understanding of how it works.
          
          <html>
          	<head>
          		<title>My first three.js app</title>
          		<style>
          			body { margin: 0; }
          			canvas { width: 100%; height: 100% }
          		</style>
          	</head>
          	<body>
          		<script src="js/three.js"></script>
          		<script>
          			var scene = new THREE.Scene();
          			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
          
          			var renderer = new THREE.WebGLRenderer();
          			renderer.setSize( window.innerWidth, window.innerHeight );
          			document.body.appendChild( renderer.domElement );
          
          			var geometry = new THREE.BoxGeometry( 1, 1, 1 );
          			var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          			var cube = new THREE.Mesh( geometry, material );
          			scene.add( cube );
          
          			camera.position.z = 5;
          
          			var animate = function () {
          				requestAnimationFrame( animate );
          
          				cube.rotation.x += 0.01;
          				cube.rotation.y += 0.01;
          
          				renderer.render( scene, camera );
          			};
          
          			animate();
          		</script>
          	</body>
          </html>"
        - code
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>spinning cube</title>
            <style>
              body {
                margin: 0;
              }
          
              canvas {
                width: 100%;
                height: 100%
              }
            </style>
          </head>
          <body>
          <script src="js/three.js"></script>
          <script>
            // Our Javascript will go here.
            //We have now set up the scene, our camera and the renderer.
            const scene = new THREE.Scene();
          
            const camera = new THREE.PerspectiveCamera(
              //The first attribute is the field of view.
              // FOV is the extent of the scene that is seen
              // on the display at any given moment.
              // The value is in degrees.
              75,
              //The second one is the aspect ratio.
              // You almost always want to use the
              // width of the element divided by the height,
              // or you'll get the same result as when you
              // play old movies on a wide screen TV - the image looks squished.
              window.innerWidth / window.innerHeight,
              //The next two attributes are the near and far clipping plane.
              // What that means, is that objects further away from
              // the camera than the value of far or closer than
              // near won't be rendered. You don't have to worry about
              // this now, but you may want to use other values in your apps
              // to get better performance.
              0.1, 1000);
          
            //Next up is the renderer. This is where the magic happens.
            // In addition to the WebGLRenderer we use here,
            // three.js comes with a few others,
            // often used as fall-backs for users with older browsers
            // or for those who don't have WebGL support for some reason.
            const renderer = new THREE.WebGLRenderer();
          
            //In addition to creating the renderer instance,
            // we also need to set the size at which we want it to render our app.
            // It's a good idea to use the width and height of the area we want
            // to fill with our app - in this case, the width and height of
            // the browser window. For performance intensive apps, you can also
            // give setSize smaller values, like window.innerWidth/2 and
            // window.innerHeight/2, which will make the app render at half size.
            renderer.setSize(window.innerWidth, window.innerHeight);
          
            document.body.appendChild(renderer.domElement);
          
            //-----------------------add objects--------------------------
          
            //To create a cube, we need a BoxGeometry. This is an object that
            // contains all the points (vertices) and fill (faces) of the cube
            const geometry = new THREE.BoxGeometry( 1, 1, 1 );
          
            //In addition to the geometry, we need a material to color it.
            // Three.js comes with several materials,
            // but we'll stick to the MeshBasicMaterial for now.
            // All materials take an object of properties which will be applied to them.
            // To keep things very simple, we only supply a color attribute of 0x00ff00,
            // which is green. This works the same way that colors work in CSS or
            // Photoshop (hex colors).
            const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          
            //The third thing we need is a Mesh.
            // A mesh is an object that takes a geometry,
            // and applies a material to it, which we then can insert to our scene,
            // and move freely around.
            const cube = new THREE.Mesh( geometry, material );
          
            //By default, when we call scene.add(),
            // the thing we add will be added to the coordinates (0,0,0)
            scene.add( cube );
          
            camera.position.z = 5;
          
            //-------------------render------------------
            //we need what's called a render or animate loop.
            //This will create a loop that causes the renderer
            // to draw the scene every time the screen is refreshed
            // (on a typical screen this means 60 times per second).
            function animate() {
              requestAnimationFrame( animate );
              //some change
              cube.rotation.x += 0.01;
              cube.rotation.y += 0.01;
              renderer.render( scene, camera );
            }
            animate();
          </script>
          </body>
          </html>"
      - 画线
        - doc
          "Drawing lines
          Let's say you want to draw a line or a circle, not a wireframe Mesh. First we need to set up the renderer, scene and camera (see the Creating a scene page).
          
          Here is the code that we will use:
          
          var renderer = new THREE.WebGLRenderer();
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );
          
          var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
          camera.position.set( 0, 0, 100 );
          camera.lookAt( 0, 0, 0 );
          
          var scene = new THREE.Scene();
          Next thing we will do is define a material. For lines we have to use LineBasicMaterial or LineDashedMaterial.
          
          //create a blue LineBasicMaterial
          var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
          After material we will need a Geometry or BufferGeometry with some vertices (it's recommended to use a BufferGeometry as it's more performant, however for simplicity we'll use a Geometry here):
          
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3( -10, 0, 0) );
          geometry.vertices.push(new THREE.Vector3( 0, 10, 0) );
          geometry.vertices.push(new THREE.Vector3( 10, 0, 0) );
          Note that lines are drawn between each consecutive pair of vertices, but not between the first and last (the line is not closed.)
          
          Now that we have points for two lines and a material, we can put them together to form a line.
          
          var line = new THREE.Line( geometry, material );
          All that's left is to add it to the scene and call render.
          
          scene.add( line );
          renderer.render( scene, camera );
          You should now be seeing an arrow pointing upwards, made from two blue lines."
        - code
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Drawing lines</title>
          </head>
          <body>
          <script src="js/three.js"></script>
          <script>
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
          
            const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
            camera.position.set( 0, 0, 100 );
            camera.lookAt( 0, 0, 0 );
          
            const scene = new THREE.Scene();
          
            //-------------------------line--------------------
          
            //create a blue LineBasicMaterial
            const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
          
            //After material we will need a Geometry or BufferGeometry
            // with some vertices (it's recommended to use a BufferGeometry
            // as it's more perform-ant, however for simplicity we'll use a Geometry here):
            const geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3( -10, 0, 0) );
            geometry.vertices.push(new THREE.Vector3( 0, 10, 0) );
            geometry.vertices.push(new THREE.Vector3( 10, 0, 0) );
          
            const line = new THREE.Line( geometry, material );
          
            scene.add( line );
            renderer.render( scene, camera );
          </script>
          </body>
          </html>"
      - 说明文字
        - CSS绝对位置法
          "<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Drawing lines</title>
            <style>
              body {
                margin: 0;
              }
          
              canvas {
                width: 100%;
                height: 100%
              }
              #info {
                position: absolute;
                top: 10px;
                width: 100%;
                text-align: center;
                z-index: 100;
                display:block;
                color: white;
              }
            </style>
          </head>
          <body>
          <div id="info">Description</div>
          <script src="js/three.js"></script>
          <script>
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
          
            const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
            camera.position.set( 0, 0, 100 );
            camera.lookAt( 0, 0, 0 );
          
            const scene = new THREE.Scene();
          
            //-------------------------line--------------------
          
            //create a blue LineBasicMaterial
            const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
          
            //After material we will need a Geometry or BufferGeometry
            // with some vertices (it's recommended to use a BufferGeometry
            // as it's more perform-ant, however for simplicity we'll use a Geometry here):
            const geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3( -10, 0, 0) );
            geometry.vertices.push(new THREE.Vector3( 0, 10, 0) );
            geometry.vertices.push(new THREE.Vector3( 10, 0, 0) );
          
            const line = new THREE.Line( geometry, material );
          
            scene.add( line );
            renderer.render( scene, camera );
          </script>
          </body>
          </html>"
    - 测试ajax请求 https://httpbin.org/
    - favicon icon图标
      "<link rel='short icon' href='./a.ico /'>"
    - SEO 搜索引擎优化 & TDK 三大标签
      "title
      meta description
      meta keyword"
    - 免费服务器
      "http://free.3v.do/"
- python
  - 数组和矩阵基本计算--numpy
    - 叉乘cross
      "import numpy as np
      
      a = np.array([1, 2, 3])
      b = np.array([3, 4, 5])
      
      print(np.cross(a, b))
      # [-2  4 -2]"
    - 矢量长度np.linalg.norm
      "import numpy as np
      
      a = np.array([1, 2, 3])
      b = np.array([3, 4, 5])
      
      print(np.linalg.norm(a)**2)
      print(np.linalg.norm(b)**2)
      # 14.0
      # 50.00000000000001"
  - 数值积分--scipy
    "from scipy import integrate
    
    
    def f(x):
        return (1 - x ** 2) ** (1 / 2)
    
    
    w, err = integrate.quad(f, -1, 1)
    print(w, err)
    
    w, err = integrate.quad(lambda x: x * x, 0, 1)
    print(w, err)
    
    # 1.5707963267948983 1.0002354500215915e-09
    # 0.33333333333333337 3.700743415417189e-15"
  - python机器学习-中国大学mooc
    "机器学习：利用数据和经验进行学习
    监督学习：训练集由人工标注
    无监督学习：训练集没有人类标注结果
    深度学习：利用深层网络模型，抽象数据表示特征
    
    scikit-learn py机器学习工具集
    开源 可复用
    	分类 聚类 回归 降维
    
    目标
    	基本原理 算法
    	解决问题的能力
    	学会如何使用库，避免重复造车
    	不深度涉及算法 原理
    
    机器学习书籍推荐..."
    - 第一周 无监督学习
      - sklearn库的安装
        "提前安装numpy scipy matpoltlib √
        "
- 正则表达式
  - 空白串 \\s+
- 其他
  - GIT
    - 简介 / 特点 ANKIED
      - 版本控制——记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
      - VCS 版本控制系统
      - 变迁
        "本地版本控制系统
        
        集中化的版本控制系统
        
        分布式版本控制系统 —— 客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。"
      - 历史：为了支持 Linux 内核开源项目的开发
      - 如何记录版本差异的？
        "传统的 VCS （基于差异）：以文件变更列表的方式存储信息，将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 基于差异（delta-based） 的版本控制）
        
        GIT （快照流）：Git 更像是把数据看作是对小型文件系统的一系列快照。每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。
        
        Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS"
      - 完整性——文件的变化GIT一定能看到
        "Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 SHA-1 散列（hash，哈希）"
      - 一般只添加数据
        "你执行的 Git 操作，几乎只往 Git 数据库中 添加 数据"
      - 仓库文件只有2种状态 已跟踪 或 未跟踪Untracked
      - 已跟踪文件只存在三种状态
        "已提交（committed）、已修改（modified）(Changes not staged for commit:) 和 已暂存（staged）(Changes to be committed)
        
        已修改表示修改了文件，但还没保存到数据库中。
        
        已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。（就是一张表，记录下一次提交时，需要快照的文件）
        
        已提交表示数据已经安全地保存在本地数据库中。（文件快照到仓库）
        
        初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态"
    - 入门 ANKIED
      - 三层配置
        "system 全系统配置
        global 当前用户配置
        null 当前git仓库配置"
      - 录入用户信息
        "$ git config --global user.name "John Doe"
        $ git config --global user.email johndoe@example.com"
      - 仓库
        - 本地目录转为 git 仓库 git init
        - 克隆仓库 git clone url [name]
      - 查看仓库状态 git status
      - 将新建/已修改的文件 git add file
      - 查看差异 git diff
      - 提交跟新 git commit -m '信息'
      - 删除 git rm f 只是删除暂存区/工作区文件
      - 远程仓库
        - 添加 git remote add name url
          "!! 默认远程服务器名字为 origin"
        - git fetch [remote]  从远程仓库中获得数据，但是不合并
        - git pull [remote] 抓取后合并该远程分支到当前分支
        - git push [remote] [branch] 
          "!! 默认分支名字为 master
          
          当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。"
      - 标签 tag —— 给提交取名字 如 v1.8.5
    - 分支
