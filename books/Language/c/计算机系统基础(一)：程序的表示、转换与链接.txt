计算机系统基础(一)：程序的表示、转换与链接

- 第一周 计算机系统概述——2019年3月17日完成
  - 第零讲 引入
    "字面量的处理？大于号小于号的求解方法
    	-2147483648<2147483647 结果为false
    	{int i=-2147483648; i<2147483647;} 结果为true
    数组访问违例
    
    System.out.println(65535*65535);//-131071
    
    链接器的符号解析
    
    代码优化？
    	a /= -1
    	{b=-1; a/=b;}
    
    数组存放/cacha/访问局部性"
  - 第一讲 为什么要学习计算机基础
    "层次
    	操作系统--ISA指令集--微体系--电路
    目标
    	高级语言的真实执行
    "
  - 第二讲 计算机系统基本组成和基本功能
    "第一台计算机，十进制
    现代计算机雏形，封·诺伊曼。存储程序，输入输出、运算器、存储器、控制器
    
    通用寄存器（组）GPRs，标志寄存器
    IR MDR PC MAR ALU-----CPU
    取指令、译指令、取操作数、执行...
    操作数：立即数、寄存器编号、内存中
    目标操作数地址：寄存器、内存"
  - 第三讲 程序开发和执行过程简介
    "机器语言
    	打孔卡片
    	缺点：地址固定，增减指令不好更改
    汇编语言
    	符号表示，助记符表示操作
    	汇编程序转换为机器语言
    机器语言
    	操作数、操作码
    	缺点：1不可移植。2复杂，需要描述的细节很多
    高级语言
    	与具体机器无关
    	处理逻辑分为三种结构 顺序 选择 循环
    解释 编译 汇编
    	目标文件
    
    C语言
    	预处理--文本
    	编译--文本
    	汇编--二进制
    	链接--二进制
    
    高级语言开发的支撑
    	语言处理系统
    	语言的运行时环境、系统调用、指令集体系结构
    	硬件"
  - 第四讲 计算机系统层次结构
    "层次
    	硬件--指令集体系结构--操作系统--语言处理系统--应用程序
    
    语言处理系统
    	编译 汇编 链接 库函数 调试 优化
    
    层次二
    	应用--算法--编程--操作系统--指令集体系结构ISA--微体系结构--功能部件--电路器件
    
    指令集体系结构ISA
    	对硬件的抽象
    	软件和硬件的接口
    	instruction set architecture
    	规定软件怎么使用硬件
    	可执行的指令的集合、指令的格式等、大小端"
  - 第五讲 本课程的主要内容
    "后PC时代
    从程序员角度来认识计算机
    	IA-32 Linux C gcc
    
    描述程序执行的底层机制
    	如何生成和运行程序
    
    数据的表示 运算 转换 
    高级语言语句的汇编转换
    复杂数据的表示
    函数调用实现
    
    链接和加载
    指令的执行 存储器访问 缓存
    异常、中断处理
    系统调用 I/O 内核态 用户态
    
    表示、转换（本课程）、控制流
    "
- 第二周 数据的表示和存储——2019年3月20日完成
  - 第一讲 数制和编码 2019年3月18日
    "数值型数据：整数，有无符号 浮点数
    非数值型数据：逻辑数 字符...
    
    二进制原因：二态器件容易实现/计算规则简单/便于逻辑运算/算术运算也方便
    
    真值/机器数！！
    	真值有正负之分，机器数没有正负了
    
    数据三要素
    	进位计数制/定点、浮点/编码方案(有符号 无符号 原码 补码 反码 移码)
    进位计数制：十进制、二进制...
    
    十进制/二进制
    	基数：10 / 2
    	i位的权：10^i / 2^i
    
    引进八进制、十六进制的原因——阅读书写二进制方便
    
    R进制->十进制  按“权”展开
    十进制->R进制  长除法
    
    浮点数  (-1)^S * M * R^E
    	S表示符号，1负数，0正
    	M，尾数，即定点小数  1.xxxxxx
    	R基==2
    	E指数，阶
    	存储方式   |S|    E     |         M        |
    
    	"
  - 第二讲 定点数的编码表示
    "四种——原码 补码 移码 反码(少用)
    
    原码——第一位位符号位
    3	0011
    -3	1011
    	缺点：
    	0不唯一。
    	加减运算不唯一。
    	需要额外对符号位处理，硬件设计复杂。
    	a<b时，a-b计算复杂。
    	使用——浮点数的尾码用原码表示
    
    移码——真值+偏置常数bias
    	通常n位编码，偏置常数 = 2^(n-1) 或 2^(n-1)-1
    	使用——浮点数的阶数。目的：对阶操作(小阶向大阶看齐)
    
    补码：模运算，同余数相等
    	例子：时钟是模12系统，即13==1
    	模运算优点：减法当加法1-5=1+(12-5)=8
    	结论：负数的补码==模+负数
    			a-b==a+(b)补
    	例子：9828-1928=9828+(10000-1928)=9828+8072=17900=7900（模10000）
    	二进制：从原码开始，各位取反，末位加一，符号位不变
    			补码=2^n+真值
    	特殊数的补码 ：-2^(n-1)=[10000...00]补码
    					-1=[1111111...11]补码
    				0=+0=-0=[000....000]补码
    
    变形补码：4‘s complement
    	符号位两位
    	正数 补码为0xxxx，变形补码为00xxxx
    		0变形补码00+0000
    		正数2^(n-1)有变形补码：01+0000
    	负数 补码为1xxxx，变形补码为11xxxx
    		负数-2^(n-1)为11+0000
    	作用：存放运算中间结果
    "
  - 第三讲 C语言中的整数
    "char 8	short 16	int 32	long long 64	float 32	double 64
    unsigned 无符号
    	8位无符号数 max=255	1111 1111
    	8位有符号数 max=127	0111 1111
    	数字末尾+U表示无符号数
    	运算中同时存在有符号、无符号，则带符号数转化为无符号数——数不变，读取方式变
    		0==0U 对
    		-1<0 带符号数 对
    		-1<0U	-1强制转化为无符号，故1111..111<000...000 返回错
    		2147483647>-2147483647-1		带符号对
    		2147483647U>-2147483647-1	无符号数，错
    		2147483647>(int)2147483648U	
    			本是无符号数，转型后是int有符号，后者变为-2147483648，对
    		-1>-2	对
    		(unsigned)-1>-2 	对	1111>1001
    		
    例子：
    	int x = -1;
    	unsigned u = 2147483648;
    	printf("%u  %d",x,x);//4294969295	-1
    	printf("%u  %d",u,u);//2147483648	-2147483648		我算对了
    
    立即数的解释——C99结果 
    	0~2^31-1 ->int 
    	2^31~2^63-1  ->long long 
    	2^63~2^64-1  ->unsigned long long 
    	！！C90下，2^31~2^32-1  ->unsigned int
    
    实例：C90下，-2147483648<2147483647结果是false，why？ 
    		因为把2147483648当作了无符号int，然后就忽略符号，后面的2147483647也转化为了无符号数
    		 ！！若先定义int x = -2147483648，此时x<2147483647为true
    		 ！！若写成-2147483647-1<-2147483647，结果也是true，因为带符号数的范围
    		 ！！-2147483648-1<2147483647 结果为true，无符号数比较！！ 
    
    		C99下都是正确结果"
  - 第四讲 浮点数的表示
    "现在所有通用计算机都用IEEE754标准
    float 32位/double 64位
    
    float表示    ±1.xxx尾数Mxxx*2^阶码E
    		|S|        阶码E          |             尾数M                      |
    		|0|1      共8位        8|9           共23位                 31|
    S--符号位，1正数，0负数
    小数点前总是一个1，不写在尾数中
    阶码用移码表示，偏移量127(2^(8-1)-1)。阶码的全0，全1用来表示特殊值
    所以阶码范围是-126~127(01H/1~FEH/254)
    
    特点
    	表示范围关于原点对称，越大越稀疏
    	负上溢|  可表示的负数  |非规格化负数|0|非规格化正数|  可表示的正数  |正上溢
    	偏移量用127而非128，为的是能表示更大的数
    	最小的规格化数：2^-126
    特殊数
    	|S|        阶码E          |             尾数M                      |     表示的数
    	 0         全0                             全0                                    +0//0f默认为正零
    	 1         全0                             全0                                     -0
    	 0         全1                             全0                                     +INF//无穷大
    	 1         全1                             全0                                     -INF
    
     	 X         全1                         不全0                                      NaN//not a number如负数根号,0/0
    
    	 X         全0                         不全0                                     Denorms//非规格化数0.xxxxx...2^-126
    
    
    双精度符号位1，阶码11，尾数52
    偏置常数1023(2^(11-1)-1)
    
    
    小练习，做对了
    	BEE00000H的float的值？
    	1011 1110 1110 0000 0000....
    	符号1——负数
    	阶码——0111 1101——125——移码后-2
    	尾数——11——1.11
    	因此：-1.11*2^-2=-0.4375
    
    	int a = 0XBEE00000;
    	System.out.println(Float.intBitsToFloat(a));//-0.4375
    
    	还有一题
    	System.out.println(Float.intBitsToFloat(0b11000001010011000000000000000000));"
  - 第五讲 非数值数据的编码表示
    "1.逻辑数据
    	如x>0，真假。通常1--真，0--假
    2.西文字符
    	7/8位。ASCII码7位。'0'--30，‘A’--41，'a'--61，空格--20
    3.汉字和国际字符
    	输入码：对应按键输入码。西文没有输入码
    	内码：汉字的存储、查找、传输码。
    		DB2312-80，区位码..国标码..//16位
    4.多媒体信息表示
    	图形，图像，音频，视频。01表示
    	"
  - 第六讲 数据宽度和存储容量的单位
    "位bit	
    字节byte--8位--最小的可寻址单位
    	LSB--最低有效字节，MSB--最高有效字节
    字word--指令结构规定，16位/32位
    字长--数据通路的宽度，也是寄存器的大小，也是ALU一次计算的长度
    
    内存容量KB MB GB TB   !!这里是1024为基，B表示字节
    宽带大小kb/s Mb/s        !!这里是1000为基，b表示位"
  - 第七讲 数据存储时的字节排列-大小端
    "前提：一个字节一个地址
    提出问题
    	int x = -10，即FFFF FFF6h——最低有效字节F6，最高有效字节FF
    	如果说x存放地址位100，那么这是最大地址还是最小地址？
    	——答：最小地址，所以实际存放在100 101 102 103四个地址字节中
    	存放顺序如何？
    		大端--最先看到的是最高位，最高有效字节//IBM
    		小端--最先看到的是最低为，最低有效字节//INTEL
    	
    	小端       大端          地址编号
              FF           F6                103
              FF           FF                102
              FF           FF                101
              F6           FF                100
    
    "
- 第三周 运算电路基础——测试04-02
  - 第一讲 数字逻辑电路基础
    "布尔代数——0/1代表假/真
    	与/·/^/半椭圆
    	或/+/v/双椭圆、内凹半椭圆
    	非/-/圈
    	异或/圈+/XOR/进位加
    真值表——输入和输出的关系
    逻辑门电路
    n位逻辑门电路：标上位数
    
    组合逻辑电路：无存储，输出=当前输入
    时序逻辑电路：有存储，输出=当前输入+存储
    	实现方法：真值表
    
    多路选择器MUX，输入端n个，控制端s选择一个输入
    一位加法器(全加器FA)：低位进位Cin、加数AB，输出F，高位进位Cout
    	F=A XOR B XOR Cin
    n位加法器(符号类似ALU)：n个FA串联实现
    	所有算术运算部件都是由加法器和逻辑运算实现
    n位带标志加法器：标志用来减法判断大小、溢出
    	OF：溢出标志
    	SF：符号标志Fn-1，最高位的值
    	ZF：零标志F=0时为0
    	CF：进位/借位标志。Cout XOR Cin(Cin=Sub)。加法时CF=Cout，减法时CF=~Cout
    n位整数加减运算器：补码运算
    	加法：直接输入
    	减法：首先被减数取反，然后Cin设为1。因为[A]补和[-A]补的关系是全位取反加一
    算术逻辑部件ALU：无符号、带符号加减、逻辑运算
    "
  - 第二讲 从C表达式到逻辑电路
    "关系运算符在底层由减法实现
    C语言
    	y = (x>>2) + k 
    汇编
    	sarw $x, %ax
    	addw %bx, %ax"
  - 第三讲 C语言中各类运算
    "算术运算
    按位运算
    	掩码与实现取位
    	^ 异或
    	~ 取反
    移位运算>> <<
    	乘除2整数倍
    	操作数类型决定是逻辑移位还是算术移位
    	溢出和有效数字丢书
    
    举例：n位变量(二进制)(n>=8，n=16/32/64)
    最高有效字节不变，其余各位全变为0
    	(x>>(n-8))<<(n-8)——对。因为最高有效字节就是8位的
    最低有效字节不变，其余各位全变为0
    	x & 0XFF——掩码
    最低有效字节全变为0，其余各位取反
    	((x ^  ~0XFF)>>8)<<8——对。对1的异或即取反，对1的异或不变。
    最低有效字节全变为1，其余不变
    	x | 0XFF
    
    按位与&  逻辑与&&
    按位或|  逻辑或||
    按位取反~  逻辑非!
    
    位扩展和位截断运算
    	类型转换
    	符号扩展，补0？补1？
    	截断运算——直接断开，正负变化可能
    	"
  - 第四讲 整数加减运算
    "无符号/有符号的运算都是用整数加减运算部件实现
    本身不管数是否有符号
    
    计算也产生各种标志FLAG，会保存在标志寄存器EFLAGS中
    	OF：溢出标志
    	SF：符号标志Fn-1，最高位的值
    	ZF：零标志。结果为0是，为1，否则为0
    	CF：进位/借位标志。Cout XOR Cin(Cin=Sub)。加法时CF=Cout，减法时CF=~Cout
    n位整数加减运算器：补码运算
    
    	无符号加溢出：CF=1
    	带符号加溢出：OF=1
    	无符号减溢出：CF=1，此时CF=~Cout，所以计算溢出则实际上没有溢出
    
    无符号减法
    	x-y+2^n  (x<y)
    
    无符号加溢出判断 sum<x
    带符号加溢出判断 (xy>0 and sum<0) or (xy<0 and sum>0)
    
    
    "
- 第四周 乘除运算即浮点数运算--2019年4月3日完成(还行)
  - 第一讲 整数乘法运算
    "两个n位数相乘，只取低n位的结果。但是硬件电路中能得到2n位的结果(分别放在两个寄存器里面)，但是自己不处理溢出(没有溢出标志)。
    因此x*x>=0不一定成立（但是浮点数则一定成立）
    判断没溢出的方法：
    	x*y=z
    	if(x==0||z/x==y)则没有溢出，是正确结果
    编译器判断：——乘指令有无符号和带符号的两种
    	无符号。高n位数 !=0
    	有符号。高n位应该全0或全1，且与低n位的最高为相同。
    
    底层。x*y=(高n位Ph，低n位P)
    	运算由移位和加法实现"
  - 第二讲 整数除法运算
    "唯一会发生的溢出：-2^(n-1)/(-1)——因为最小负数绝对值>最大正数
    	Java中(-2147483648/-1) = -2147483648(0X8000 0000，-2^31)
    
    舍入方法：朝0舍入，就是截断。
    	7/2=3	-7/2=-3
    
    /0错误：操作系统会调出错误处理程序
    
    /-1的优化：编译器优化为取负指令neg，即数值位取反加一。
    	所以a=-2147483648;a=a/-1;不会报错
    	但是a=-2147483648,b=-1;a=a/b;编译器不优化，div除法指令。可能报错——floating point exception浮点异常
    	为什么是整数出现了浮点异常，第七章才能知道答案。喵的~
    
    /2^n的优化：右移n位
    	！！！！
    	正数是直接右移n位，扔掉移出去的
    	负数是加上偏移量(2^n-1)再右移！不然-7/2=-4
    		例子：-7即1000，若除4，即右移2位，则变成1110，这是-2。不符合截断规则
    			应该是-7+(偏移量2^2-1)=-4，即1100，然后右移2位，为1111，是-1。正确
    		附录：取符号位的方法：int s = (x>>31)&0X1;
    
    运算过程
    	比较复杂，不能用流水线方式(乘法可以)实现，一次除法需要大约30个时钟周期。比乘法慢。
    	不能用流水线方式(乘法可以)实现——因为要根据每一步的结果确定下一步是加法还是减法
    	因此尽量不要用除法
    "
  - 第三讲 浮点数运算
    "加减
    	对阶。小阶看齐大阶，右移|i-j|位。一。注意隐形的1右移要出现。二，此时不能舍入
    	运算。
    	规范化。注意可能的上下溢出。
    乘除
    	阶码加减
    	尾数乘除
    
    特殊情况
    	阶码上下溢出INF 0
    	尾数上溢出，有规，结果不一定溢出
    	非规格化，即最高位0，左规
    	最后才做舍入
    
    五种异常情况
    无效运算
    	+/- inf、0*inf、inf/inf
    	NaN操作、0/0..
    除0 == inf
    数太大
    数太小
    结果不精确 1/3
    -------------------------
    附加位
    	在对阶中，附加位数，最后才舍入，减少精度损失
    	规定必须保留2个附加位，分别是保护位guard和舍入位round	
    	舍入时多种方式--默认就近舍入，01舍，11入，10中间值强迫为偶数
    	float只能精确7位十进制，int->float可能舍入
    
    f == -(-f)  永远true
    float最大3.4*10^38
    double最大1.8*10^308
    
    浮点数加法结合律不正确
    	大数吃小数
    ------------------------------
    Ariana火箭爆炸
    	原因64位double转化为16位带符号整数发生了溢出。因为新火箭速度快。
    爱国者导弹定位错误
    	浮点精度问题，时钟0.1s计数一次，但是0.1二进制是循环小数
    "
- 第五周 IA-32指令系统概述--完成
  - 第一讲 程序转换概述
    "指令结构 OP + ADDR
    ADDR = 源操作数(立即数、寄存器编号、内存地址) / 目的操作数地址(寄存器编号、内存地址)
    
    指令：微指令(硬件范畴，更低级)、机器指令、伪(宏)指令(多个机器指令的序列，软件范畴)
    	机器指令和汇编指令一一对应
    
    语言
    	机器语言 01代码，由若干字段组成
    	汇编语言 助记符，不同机器格式不同
    	RTL寄存器传送语言：前者通用化。R寄存器，M存储器
    
    预处理：处理高级语言宏，#include
    编译：文本的汇编语言
    汇编：可重定位的二进制程序
    连接：可执行的二进制程序
    
    例子：
    两个源程序main.c和test.c，后者中一个函数int add(int i,int j)。
    gcc -O1 main.c test.c -0 test//-O1表示一级优化，o指出输出文件名
    -E预处理结构
    -S汇编
    -c可重定位二进制
    objdump程序 -d 反汇编（可以看到可重定位的程序的反汇编，起始地址都是0开始）
    两种目标文件 可重定位/可执行
    	反汇编后，只有地址不一样。后者地址不再是0，实际上是虚拟地址
    
    ISA指令集体系结构
    	规定怎么使用硬件：如有无乘法操作/寄存器编制方式/大小端。
    	对硬件的抽象。没有ISA软件无法使用硬件
    	同一套ISA可以有不同的硬件体系——只要能完成相应功能就行"
  - 第二讲 IA-32指令系统概述
    "支持的数据类型/通用寄存器组织/标志寄存器/寻址方式/指令格式
    
    X86——Inter开发的一类处理器体系结构的泛称
    	因为包括8086、80286、i386、i486故名
    IA-32——Inter对32位x86结构的正式名
    	IA：inter architecture
    64位化——ADM64、inter64，都兼容IA-32
    	IA-64是全新的64结构，不支持IA-32
    
    IA-32架构
    	寄存器：8个GPR通用寄存器0~7，专用：一个EFLADs标志寄存器，指令计数器为EIP。6段寄存器(代码段、堆栈段、数据段、附加段*3)
    		8位寄存器AL AH...
    		16位寄存器AX BX...  SP BP...
    		32位寄存器....64位/128位都有(都是复用的)
    		标志寄存器：6个条件标志，即前面说的OF SF ZF... / 3个控制标志 DF方向 IF中断允许 TF陷阱(用于调试程序)
    	指令格式，操作码都可变长，若干字段
    
    	支持的数据类型：整形/浮点型，指针32位。long double 80位，4B对齐实际存储96位
    		w字=16位，l(L)双字=32位。因为IA-32由IA-16发展而来
    		char类型，汇编指令后缀b
    		short类型，汇编指令后缀w
    		int类型，汇编指令后缀l(小写的L)"
  - 第二讲(2) 寻址方式
    "寻址方式——两种工作模式：实地址模式、保护模式
    	实地址寻址：寻1mb(20位==(CS)<<4 + (IP))空间，兼容8086
    	保护模式：4GB，32位。地址分段：段基址+段内偏移量
    	立即寻址：指令中
    	寄存器寻址：寄存器中
    	其他寻址(下详述)：存储器中——位移，基址，比例变址，相对寻址
    
    其他寻址方式——分段虚拟管理方式
    	字母 LA线性地址。
    	(X)X的内容。
    	SR段寄存器-段基址6个（代码段、堆栈段、数据段、附加段*3）。
    	PC程序计数器。R寄存器。A地址偏移量。B基址寄存器。
    	(I变址寄存器。S比例系数)用于数组寻址，首地址+变址*比例系数
    	：：泛化  LA = (SR) + 有效地址(偏移量) (具体计算方式多种)
    	位移：LA=(段寄存器SR)+偏移量A
    	基址寻址：LA=(SR)+(基址寄存器B)
    	基址加位移：LA=(SR)+(B)+A
    	比例变址加位移：LA=(SR)+(变址寄存器I)*S+A
    	基址加变址加位移：LA=(SR)+(B)+(I)+A
    	基址加比例变址加位移...
    	相对寻址LA=(PC)+A
    
    double变量
    	Linux 4B对齐   B--字节
    	windows 8B对齐
    	对齐，即double变量的地址一定是4/8B的倍数"
  - 第二讲(3)IA-32机器指令格式——CISC复杂指令集
    "指令长度可变，有操作吗绝对长度
    
    操作码1/2字节。W寄存器位数，D操作方向
    寻址方式0/1字节
    SIB(存储器操作数SS比例因子2位、index变址寄存器编号、base基址寄存器编号)(因为上寄存器是通用寄存器)2字节
    位移1、2、4字节
    直接数据1、2、4字节"
- 第六周 IA-32指令类型 AT&T描述--2019年4月9日完成
  - 第一讲 传送指令
    "概述：MOV PUSH/POP LEA IN/OUT PUSHF/POPF
    下面讲的都是AT&T格式
    
    传送指令分类
    -通用数据传送指令
    	MOV：一般等长传送，movb、movw、movl（注b-8位char，w-16位short，l-(小写的L)32位int）
    	MOVS：符号扩展传送，如movsbw（8位扩展到16位，带符号数扩展）、movswl（16->32位）
    	MOVZ：零扩展传送，用于unsigned，如movzwl（前面补0）
    	XCHG：数据交换
    	PUSH/POP：入栈/出栈，如pushl、popw
    -地址传送指令
    	LEA：加载有效地址load effective address，如"leal(%edx,%eax),%eax"，表示基址寄存器edx内容加变址寄存器内容eax，求和送到eax中。用来实现求和求差
    -输入输出指令
    	IN/OUT：I/O端口和寄存器交换
    -标志传送指令
    	PUSHF：将EFLAG压栈
    	POPF：栈顶内容送至EFLAG
    
    “栈”详述
    	目的：嵌套过程调用。高地址向低地址增长，栈底在高地址。
    	"pushw %aw"：两步完成，①栈顶指针sp-=2，②寄存器aw中数据入栈，先入AH，再入AL（小端）
    	"popw %ax"：①出栈，②栈顶指针+=2
    
    实例
    	mov %esp,%ebp，将寄存器esp内容放到ebp里面
    	mov 0xc(%ebp),%eax，按照ebp寄存器内容+12，到内存寻址，把指定的内容送到eax中
    	mov %eax,-0x4(%ebp)，把eax内容送到内存，具体地址是ebp-4"
  - 第二讲 定点算术运算指令
    "加减运算（影响标志，不区分符号/无符号数）
    	ADD：addb、addw、addl
    	SUB：subb，subw，subl
    加1减1运算（影响除CF-进位/借位标志以外的标志，不区分有无符号）
    	INC：incb、incw、incl
    	DEC：decb、decw、decl
    取负运算（影响标志，对0取负，结果为0，CF清0，否则CF置1）
    	NEG：negb、negw、negl
    比较运算（做减法得到标志信息，不区分无/带符号。运算结果不影响寄存器内容，只影响标志信息）
    	CMP：cmpd、cmpw、cmpl
    
    乘除运算（不影响标志信息，区分有无符号）
    	MUL：无符号乘
    	IMUL：有符号乘
    	DIV：无符号除
    	IDIV：带符号除
    
    乘法指令的操作数
    	一个操作数SRC，则还有一个操作数隐含在AL8位/AX16位/EAX32位中(其中一个)，n位数*n位数，将得到2n位数，都存在寄存器中。16位结果AX中，32位结果DX-AX中，64位结果EDX-EAX中
    	二个操作数DST和SRC，第一个绝不是立即数，结果存在第一个操作数DST中。这里截去了高n位。
    	三个操作数REG，SRC，IMM立即数。表示REG=SRC*IMM，同样截去高n位。
    
    除法指令：只明显给出除数，被除数事先放在专门的寄存器中，不显式指定
    	8位除数。则16位的被除数事先放在AX寄存器中，运算的商在AL，余数在AH
    	16位除数。则32位的被除数事先放在DX-AX寄存器中，运算的商在AX，余数在DX
    	32位除数。则64位的被除数事先放在EDX-EAX寄存器中，运算的商在EAX，余数在EDX
    
    ALU：没有乘除器
    	要么用独立的乘法器，除法器
    	要么用加减移位计算
    	带符号和无符号的乘除分别是是独立的部件
    
    实例1(加法)：R[AX]=FFFAH，R[BX]=FFF0H，执行addw %bx,%ax
    	那么，bx不变，ax为两数和FFEAH。（ax是目的操作数地址）
    	标志位CF进位借位=1	OF溢出=0	ZF零标志=0	SF符号标志=1
    结果的解释
    	无符号数。有CF=1，得知其溢出
    	有符号数。有OF=0，得知无溢出
    
    实例2(乘法)：R[EAX]=0000 00B4H，R[EBX]=0000 0011H，内存M[0000 00F8H]=0000 00A0H
    (1)指令mulb %bl，指令imulb %bl。结果是什么，寄存器中的数会怎么变
    	解：一个操作数，8位运算，所以有隐含的操作数在AL寄存器中。
    		同时，运算结果将存放在AX中。
    		--mulb无符号运算：
    		已知R[BL]=11H，R[AL]=B4H，结果0BF4H，存在R[AX]中
    		则R[EAX]=0000 0BF4H，R[EBX]不变
    		--imulb有符号运算：
    		R[BL]=(17)d，R[AL]=(-76)d
    		运算结果-1292，是R[AX]=FAF4，那么R[EAX]=0000 FAF4H
    (2)指令imull $-16,(%eax,%ebx,4),%eax，执行后的变化
    	解：$-16是立即数，
    		(%eax,%ebx,4)是存储器操作数。基址eax+变址ebx*比例4
    		%eax是目的操作数地址，这时应当发生了截断
    		-16=-10FH，乘上0000 00A0H，结果为FFFF FFFF FFFF F600 H
    		存放在R[EAX]=FFFF F600H
    		
    -------------
    备忘
    b-8位char，w-16位short，l-(小写的L)32位int
    
    AL AH 8位
    AX 16位
    DX-AX 32位
    EDX EAX 32位
    EDX-EAX 64位
    
    OF：溢出标志
    SF：符号标志Fn-1，最高位的值
    ZF：零标志。结果为0时，为1，否则为0
    CF：进位/借位标志。Cout XOR Cin(Cin=Sub)。加法时CF=Cout，减法时CF=~Cout"
  - 第三讲 按位运算指令
    "逻辑运算(都需要加上 b w l)
    	NOT：非
    	AND：与
    	OR：或
    	XOR：异或
    	TEST：“与"测试操作，仅影响标志
    	标志：仅NOT不影响标志，其他指令OF=CF=0，ZF全零标志、SF符号标志根据结果
    
    移位运算(左/右移时，最高/最低位送CF)(都需要加上 b w l)
    	SHL/SHR：逻辑左右移
    	SAL/SAR：算术左右移。左移会判断溢出(移位前后的SF符号变了，则溢出OF=1)，右移高位补符号。
    	ROL/ROR：小循环左右移。
    	RCL/RCR：大循环左右移，即带上CF进位标志。√
    	操作数：要移动的位数，被操作数。结果放在被操作数中。如果移动1位，则第一个操作数省略。
    
    实例
    	notw %aw——ax内容16位，取反
    	andl %eax,(%ecx)——寄存器eax的值和ecx指向的内存值，做与运算，结果放到ecx指向的内存中。32位运算
    	orb 4(%ecx),%al——ecx指向内存后4位，做或运算，结果到al中。
    	xorw %ax,4(%ecx)——异或，结果到ecx指向内存后4位。16位，即低2位
    	testl %eax,%ecx——只产生标志信息。
    
    实例2
    	有一个short变量在ax中，即R[AX]=FF80H，以下操作
    	movw %ax,%dx——ax寄存器值放到dx中
    	salw $2,%ax——算术左移2位，R[AX]=FE00H，没有溢出OF=0
    	addl %dx,%ax——加法，结果放到R[AX]=FD80H
    	sarw %ax——算术右移1位，R[AX]=FEC0H √
    	二进制：1111 1110 1100 0000
    	真值：-320
    	做的运算：5*x/2
    	
    
    -------------
    备忘
    b-8位char，w-16位short，l-(小写的L)32位int
    
    AL AH 8位
    AX 16位
    DX-AX 32位
    EDX EAX 32位
    EDX-EAX 64位
    
    OF：溢出标志
    SF：符号标志Fn-1，最高位的值
    ZF：零标志。结果为0时，为1，否则为0
    CF：进位/借位标志。Cout XOR Cin(Cin=Sub)。加法时CF=Cout，减法时CF=~Cout"
  - 第四讲 控制转移指令
    "无条件转移指令
    	JMP DST：无条件转移到DST处
    条件转移指令
    	Jcc DST：cc为条件码，满足条件才转移，否则顺序执行
    条件设置
    	SET cc DST：按条件码cc判断的结果(满足条件1，不满足0)保存在DST，DST是一个8位寄存器
    调用和返回指令
    	CALL DST：返回地址RA会入栈，然后跳转至DST
    	RET：出栈得到RA，然后跳到RA
    中断指令：也是跳转指令，详见7、8章
    
    标志寄存器中相关量
    	CF：判断无符号数的大小，做减法实现
    	OF：判断符号数的大小，做减法实现
    
    条件码jcc
    	jc：CF=1转移
    	jnc：CF=0转移
    	js：SF=1转移
    	ja：无符号数A>B。CF=0 AND ZF=0
    	jg：带符号数A>B。SF=OF AND ZF=0
    	jne：不等于
    	…… ……
    	A（above）大于，B（below）小于，E（equal）等于，用于比较无符号数
    	G（great）大于，L（less than）小于， E（equal）等于，用于比较带符号数
    
    实例
    	数组求和函数，输入int* a和unsigned length，主要代码for(i=0;i<=length-1;i++){}
    	当输入length=0时，本应该返回0，但是却出现存储器异常
    原因：查看汇编
    	两个movl，把i和length的值存到eax和edx寄存器
    	subl $1,%edx，减法，这导致R[EDX]=FFFF FFFF H
    	cmpl %edx,%eax，比较运算，实际是减法，改变了标志信息
    	jbe .L3，无符号大小比较
    		(因为当有一个数是无符号数时，编译器认为整个运算是无符号的，所以编译为jbe指令
    		这时比较结果为真，跳转到了for循环内部。而且即使i++，for循环也一直为真，直到超出能访问的界限
    解决：把unsigned length改为int length，则jbe会变为jle，带符号大小比较
    
    实例2 求粗体处表达式值
    	unsigned int a = 1 ;
    	unsigned short b = 1 ;
    	char c = -1 ;
    	(a > c) ? 1 : 0 ;//输出0
    	(b > c) ? 1 : 0 ;//输出1
    前提知识：无符号char和short在运算时会变成int
    (a > c) ? 1 : 0 ;——按照无符号int比较
    	汇编为cmp和setb
    (b > c) ? 1 : 0 ;——按照有符号int比较
    	汇编为cmp和setg"
  - 第五讲 x87浮点处理指令
    "IA-32的浮点处理架构有两种
    	(1)gcc默认的，x87FPU指令集
    	(2)x86-64架构的SSE指令
    IA-32中可处理的浮点数
    	float / double / long double80位
    	long double的独特之处：①数值首位的1不隐藏，②内存存储为96为，其中高16位无意义(对齐)
    
    早期的浮点处理器作为CPU的外置协处理器
    	8087/80187....
    现在和CPU做在一起
    
    x87FPU指令集
    	浮点寄存器采用栈结构。深度8，宽度80，即8个80位寄存器
    	寄存器名称ST(0)到ST(7)，栈顶为0
    	所有的浮点运算时都是扩展到80位进行（long double）
    	因此寄存器和内存交换时，会转换位数大小
    
    -----------------------------
    
    指令
    装入
    	FLD：浮点load，内存->寄存器
    	FILD：把数组按照int型转化为80位浮点，存入寄存器
    存储（x含义：x=s时，存为单精度，x=d时，存为双精度）（P表示出栈，这样ST(1)->ST(0)）
    	FSTx：将ST(0)，即栈顶的浮点数存入内存
    	FSTPx：弹出栈顶元素，其他FSTx功能相同
    	FISTx：先转化为int再存储
    	FISTPx：弹出，其次和FISTx同
    交换
    	FXCH：交换栈顶和次栈顶，ST(0)<>ST(1)
    常数装入指令
    	FLD1：装入1.0
    	FLDZ：0.0
    	FLDPI：pi
    	FLDL2E：log(2)e
    	FLDL2T：log(2)10
    	PLDG2：log(10)2
    	FLDLN2：log(e)2
    算术（不带操作数时，默认为ST(0) AND ST(1)）
    	FADD/FADDP：栈顶和次栈顶相加，再变成栈顶。P-运算后弹出
    	FIADD：转换为int后相加
    
    	FSUB/FSUBP：栈顶减去次栈顶。弹出
    	FSUBR/FSUBRP：R-反过来，次栈顶减去栈顶
    	FISUB/FISUBR：I-转为int型
    
    	FMUL/FMULP：乘法
    	FIMUL：int乘
    
    	FDIV/FDIVP：除
    	FDIVR/FDIVRP：反除
    	FIDIV/FIDIVR：int除
    
    ---------------------------------------------------
    
    实例：
    	下面两个代码，差别为粗体，老版本gcc -O2编译时，前者输出0，后者输出1。why？
    ///////////////代码一
    double f(int x){return 1.0/x;}
    void main(){
    	double a,b;
    	int i;
    	a = f(10);
    	b = f(10);
    	i = a==b;
    	printf("%d\n",i);
    }
    ///////////////代码一
    double f(int x){return 1.0/x;}
    void main(){
    	double a,b,c;
    	int i;
    	a = f(10);
    	b = f(10);
    	c = f(10);
    	i = a==b;
    	printf("%d\n",i);
    }
    
    原因：
    	代码一：
    	a = f(10);//计算结果放回了内存FSTPL，本是80位，舍去到了64位
    	b = f(10);//计算结果没有放回内存，没有舍入
    	a = a==b;//这时把内存中的a读回寄存器，64->80位。因此比较是 (double)a==(long double)b
    	0.1二进制是无限循环小数，所以不相等
    
    	代码二：
    	a和b都回到内存一次，所以都舍入了（80->64），所以是想得的。
    	
    
    "
  - 第六讲 MMX(多媒体扩展)及SSE指令集——SIMD
    "MMX
    	MMX指令使用8个64位寄存器MM0-MM7
    	实际是借用了用于浮点的ST0-ST7(80位中64位尾数)
    	所以一个MMX可以同时处理8个char字节，4个字short，2个双字w-int，一个64位long数据
    	称为SIMD技术——单指令，多数据技术
    
    SSE
    	MMX指令没有带来3D游戏性能提升
    	所以又推出了SSE指令，以及之后的SSE2 SSE3 SSE4
    	都是采用SIMD技术
    	统称SSE指令集
    
    SSE指令集
    	将ST浮点寄存器扩展到128位，名字XMM0-XMM7
    	可以同时处理的数据量相对MMX翻倍
    
    SSE2
    	支持128位整数运算
    	还可以两个double数据并行处理
    
    SIMD指令
    	指令并行，速度得到了很大提升
    	paddx——并行加指令
    		x=b/w/l——同时完成16个char相加，8个short相加，4个int相加
    	movdqa——移动双四字（128数据）a对齐
    	movdqu——u不对齐
    
    --------------
    总结
    	64位寄存器MM0-MM7
    	80位浮点寄存器ST0-ST7
    	128位寄存器XMM0-XMM7
    	都是复用"
- 第七周 C语言语句的机器级表示
  - 第一讲 过程（函数）调用（1）——提出问题
    "考虑下面代码
    ----------------------------------------
    int add(int x, int y){return x+y;}//被调用函数
    int main(){//调用函数
    	int t1 = 125; int t2 = 80;
    	int sum = add(t1, t2);
    	return sum;
    }
    ----------------------------------------
    问题：参数如何传递，结果如何返回
    所以“调用函数”需要先存放参数，然后“被调用函数”需要取出参数
    	参数存放在“栈”中
    	“栈”是在程序执行中动态生成，大小变化。不同于固定的代码段、数据段
    	栈底位于高地址，栈顶向低地址方向增长
    	栈顶地址存放在ESP中
    	（注：“栈”！=“堆”，后者由malloc生成）
    	（地址从低到高，依次是 代码段、数据段、堆、栈、内核）
    
    问题：整个过程（设P位调用者，Q位被调用者）
    	1.P将参数放到栈中
    	2.P保存返回地址RA，P将控制转给Q——CALL指令
    	3.Q保存P的现场（即P用到的寄存器内容）
    	4.Q为自己的非静态局部变量分配空间
    	5.Q执行函数体
    	6.Q恢复P的现场，释放局部变量
    	7.Q取出返回地址，将控制转移要给P——RET指令
    
    寄存器使用约定
    	调用者P一定会保存寄存器EAX、EDX、ECX（保存到栈中）（如果Q返回P后，P自己不要用这些寄存器的值，那就不保存）
    	因此Q可以直接使用（尽量只使用这三个）
    	被调用者Q如果还要用EBX、ESI、EDI，必须自己完成保存工作
    
    	另外EBP保存栈底部地址，ESP保存栈顶部地址
    
    栈具体内容--从底部(高位)开始
    	首先调用者P依次存入三个东西：
    		1.调用者P保存的寄存器EAX、EDX、ECX（必要时）
    		2.传递的参数1、2、3...
    		3.返回地址RA
    	被调用者Q再依次存入3个东西
    		4.EBP的旧值
    		5.Q保存的寄存器EBX、ESI、EDI（如果不需要使用就不存入）
    		6.自己的非静态局部变量
    
    ---------------------------------
    备忘
    调用和返回指令
    	CALL DST：返回地址RA会入栈，然后跳转至DST
    	RET：出栈得到RA，然后跳到RA
    "
  - 第一讲 过程（函数）调用（2）——准备阶段和结束阶段(开栈和退栈)
    "总结（过程/函数的执行）
    准备阶段
    	push和mov指令，形成新的栈底。
    	sub指令，形成新的栈顶。
    	如有需要，保存现场。
    过程体
    	分配局部变量
    	如果有函数调用——准备参数，并call	
    	本函数的返回参数，存在eax中
    结束阶段
    	leave和pop，退栈
    
    C源代码
    ------------------------------
    |	int add(int x, int y){return x+y;}
    |	int caller(){
    |		int t1 = 125; int t2 = 80;
    |		int sum = add(t1,t2);
    |		return sum;
    |	}
    ------------------------------
    caller对应的汇编
    ------------------------------
    |	pushl %ebp	//ebp栈底。老的栈底指针入栈
    |	movl %esp,%ebp	//esp栈顶。把栈顶指针赋值给ebp栈底。即把栈顶移到了栈底（当然保存了旧栈顶）
    |	subl $24,%esp	//栈顶外移24字节，6个int空间
    |	//前三是准备阶段
    |
    |	movl $125,-12(%ebp)
    |	movl $80,-8(%ebp)	//语句“int t1 = 125; int t2 = 80;”执行。即“分配局部变量”
    |
    |	movl -8(%ebp),%eax
    |	movl %eax,4(%esp)
    |	movl -12(%ebp),%eax
    |	movl %eax,(%esp) 	//这四条语句，复制了t1 t2。目的是准备add函数的参数
    |	//此时栈中情况见下表①
    |
    |
    |	call add	//返回参数总是在eax中
    |	movl %eax,-4(%ebp)	//把eax放到栈。就是“int sum = add(t1,t2);”中sum==-4(%ebp)
    |	movl -4(%ebp),%eax	//对应“return sum;”，还是“返回参数总是在eax中”
    |
    |	//最后两条是结束
    |	leave	
    |	//退栈指令。实际是movl %ebp,%esp	popl %ebp
    |	//即旧cellar的栈底指针，放到esp(栈顶R)。这时ebp和esp都指向相对位置0——见表①
    |	//然后栈pop出，即0位置存到ebp，然后栈退一位。退到仿佛caller函数没有执行。仅仅是eax寄存器变了
    |	ret
    |	
    ------------------------------
    
    表①栈中情况
    ------------------------------
    |-4		其他数据
    |0		旧ebp栈底指针<-R[ebp]栈底指向这里
    |-4	
    |-8		80	//
    |-12		125	//这两个是，调用函数中t1和t2变量。“分配局部变量”
    |-16
    |-20	80
    |-24	125-<R[esp]栈顶指向这里	//这两个是，被调函数add的参数，由调用函数准备。
    ------------------------------
    
    add函数对应的汇编
    ***call指令还有把esp下移的操作，详见（3）
    ------------------------------
    |	pushl %ebp
    |	movl %esp,%ebp	//头两句和celler一模一样！！
    |	
    |
    |	
    ------------------------------
    
    add指令时，栈结构。表②
    ------------------------------
    |4		其他数据
    |0		caller中旧ebp栈底指针<-R[ebp]栈底指向这里
    |-4	
    |-8		80	//
    |-12		125	//这两个是，调用函数中t1和t2变量。“分配局部变量”
    |-16
    |-20	80
    |-24	125-<R[esp]栈顶指向这里	//这两个是，被调函数add的参数，由调用函数准备。
    |-28	放返回地址
    |-32	add中旧ebp栈底指针(即位置0)<-R[ebp]指向这里
    |-36	add函数所用的栈从这里开始
    ------------------------------
    
    
    ------------------------------
    l-(小写的L)32位int
    
    EBP保存栈底部地址，ESP保存栈顶部地址
    
    esp是栈指针，是cpu机制决定的，push、pop指令会自动调整esp的值；
    ebp只是存取某时刻的esp，这个时刻就是进入一个函数内后，cpu会将esp的值赋给ebp，此时就可以通过ebp对栈进行操作，比如获取函数参数，局部变量等，实际上使用esp也可以；"
  - 第一讲 过程（函数）调用（3）——参数传递(传值/传地址)以及call的准备
    "入口参数的位置
    	从新开辟的esp栈顶开始放置，往高位走，如下表-20和-24位置就是入口参数。
    	具体位置，-24是第一个参数，-20是第二个参数。即add(125,80)
    ------------------------------
    |4		其他数据
    |0		旧ebp栈底指针<-R[ebp]栈底指向这里
    |-4	
    |-8		80	//
    |-12		125	//这两个是，调用函数中t1和t2变量。“分配局部变量”
    |-16
    |-20	80
    |-24	125-<R[esp]栈顶指向这里	//这两个是，被调函数add的参数，由调用函数准备。
    |-28	add指令的返回地址	//见下“call操作具体行为”。esp下移4位，并存上了返回地址
    ------------------------------
    
    call操作具体行为，见上表-28
    ------------------------------
    |	movl (%esp)-4,%esp
    |	movl 返回地址,M(R[esp])
    |	movl add函数首地址,R[eip]——eip寄存器：存放call指令对应的过程的地址
    ------------------------------
    
    执行add过程
    	详见（2）。
    	第一步，把ebp栈底(当前值0)的值push入栈，即地址-32的值位原ebp值(即0)
    	！！！push指令，副作用是esp值变化为新的栈顶(-28变成-32)
    	第二步，让ebp(当前0)等于esp，即两个寄存器都等于(-32)
    
    	之后add函数需要寻找传来的参数
    		ebp->旧ebp值
    		ebp+4->返回地址
    		ebp+8->第一参数——找到了~
    		ebp+12->第二个参数
    
    esp变化总结
    	caller函数，第一步，旧ebp入栈。此时esp值从原来的-4，变成0
    	esp->ebp，值不变。
    	subl $24,%esp。esp从0变成-24（这是caller过程中的栈顶，在celler中调用add函数的第一个参数即放在-24）
    	调用call指令，esp从-24变成-28。-28用于存在返回地址
    
    	此后进入add过程，首先push旧ebp入栈，即ebp的值存到-32位置，同时esp=-32
    
    传地址——swap(&a,&b){交换ab值}
    	主调函数中，假设a和b局部参数放在栈的-4和-8位置
    	那么准备参数的指令为
    |		leal -8(%ebp),%eax	//这是地址传递指令，和movl没区别
    |		movl %eax,4(%esp)
    |		leal -4(%ebp),%eax
    |		movl %eax,(%esp)
    |		call swap
    	
    	call准备好返回地址后，栈结构为(以ebp为相对地址)
    		0--ebp栈底
    		-4--a的值
    		-8--b的值
    		esp--返回地址	(假设esp=-100)
    		esp+4--(地址-4，即a的地址)	//-96
    		esp+8--(地址-8，即b的地址)	//-92
    
    	再看swap指令
    |	pushl %ebp
    |	movl %esp,%ebp	//朴实无华的建栈过程。esp=-104，ebp=-104
    |
    |	pushl %ebx	//被调者保存ebx寄存器的值。esp=-108
    |
    |	movl 8(%ebp),%edx	//M[-96]->edx，即a的地址(-4)
    |	movl (%edx),%ecx	//ecx存放a的值
    |	movl 12(%ebp),%eax	//M[-92]->eax，即b的地址(-8)
    |	movl (%eax),%ebx	//ebx存放b的值
    |	movl %ebx,(%edx)	//b的值存放到M[-4]，这里原来是a的值
    |	mocl %ecx,(%eax)	//a的值放到M[-8]，这里原来存放b的值
    |		恭喜完成交换
    
    	问题，如果是swap(a,b)，会怎样？
    	答：交换-96和-92地址的值，而-4和-8地址的值不变。所以无法完成交换功能
    	"
  - 第一讲 过程（函数）调用（4）——例题(关于传值/传地址)
    "函数如下
    |	void test(int x,int *ptr){
    |		if(x>0&&*ptr>0) *ptr+=x;
    |	}
    |	void caller(int a,int y){
    |		int x = a>0 ? a : a+100;
    |		test(x,&y)
    |	}
    问题：调用caller的过程为P，P中给出形参a和y，实参分别是100和200，画出栈状态，并回答
    	（1）test的形参是按值传递还是按地址传递？test的形参ptr对应的实参是什么类型？
    	（2）test中被改变的*ptr的结果如何返回给它的调用过程caller？
    	（3）caller中被改变的y的结果能否返回给P？为什么？
    
    答：
    -----------------------------------
    |4		上个函数的返回地址
    |0		上个函数的栈底<-ebp
    |-4		y的值200//局部变量
    |-8		a的值100//局部变量
    |....
    |-100	y的值200	//仅仅假设地址为-100
    |-104	a的值100<-esp		//准备给caller的参数
    -----------------------------------
    调用caller后
    -----------------------------------
    |4		上个函数的返回地址
    |0		上个函数的栈底<-ebp
    |-4		y的值200//局部变量
    |-8		a的值100//局部变量
    |....
    |-100	y的值200	//仅仅假设地址为-100
    |-104	a的值100<-esp
    |-108	P过程返回地址
    |-112	P的栈顶，即M[0]-<ebp,esp
    |....
    |-200	y的地址-100		//仅仅假设地址为-200
    |-204	x值100			//这两个是caller为test准备的形参
    |-208	caller的返回地址
    -----------------------------------
    
    （1）test的形参是按值传递还是按地址传递？test的形参ptr对应的实参是什么类型？
    	test(int x,int *ptr)
    	x--值传递，ptr--地址传递。test的形参ptr对应的实参是一个地址。
    （2）test中被改变的*ptr的结果如何返回给它的调用过程caller？
    	存在了caller形参y的地址中，即M[-100]中。此时从200到了300
    （3）caller中被改变的y的结果能否返回给P？为什么？
    	不能，因为改变的是M[-100]的值，而P过程的局部变量y在M[-4]中
    
    附：调用test后
    -----------------------------------
    |4		上个函数的返回地址
    |0		上个函数的栈底<-ebp（P）
    |-4		y的值200//局部变量
    |-8		a的值100//局部变量
    |....
    |-100	y的值300	//仅仅假设地址为-100	//！！！此时值被test改变
    |-104	a的值100<-esp
    |-108	P过程返回地址
    |-112	P的栈顶，即M[0]-<ebp,esp（caller）
    |....
    |-200	y的地址-100		//仅仅假设地址为-200
    |-204	x值100			//这两个是caller为test准备的形参
    |-208	caller的返回地址
    |-212	caller的栈顶-112-<ebp,esp（test）
    |...
    -----------------------------------
    "
  - 第一讲 过程（函数）调用（5）——递归调用
    "实例
    --------------------------------
    int nn_sum(int n){
    	int result;
    	if(n<=0) return 0;
    	else result = n + nn_sum(n-1);
    	return result;
    }
    --------------------------------
    汇编
    --------------------------------
    00 pushl %ebp
    01 mowl %esp,%ebp
    02 pushl %ebx
    03 subl $4,%esp			//下移一个int
    04 movl 8(%ebp),%ebx	//取传来的参数n
    05 movl $0,%eax;		//result = 0
    06 cmpl $0,%ebx		//if(n<=0)
    07 jle .L2				//成立则跳到.L2
    08 leal -1(%ebx),%eax	//eax=n-1
    09 movl %eax,(%esp)		//压栈
    10 call nn_sum			//递归
    11 addl %ebx,%eax		//最后求和n+nn_sum(n-1)
    .L2
    12 addl $4,%esp		//
    13 popl %ebx
    14 popl %ebp		//退栈出ebx eax
    15 ret				//实际return到11号语句
    --------------------------------
    ⭐⭐——递归00-10反复进行，当n=0时，11-15反复进行
    
    
    栈，假设P调用nn_sum(n)
    --------------------------------
    .....
    P栈				n
    P栈				返回地址1
    nn_sum(n)栈	P中EBP值
    nn_sum(n)栈	P中EBX值
    nn_sum(n)栈	n-1
    nn_sum(n)栈	返回地址2
    nn_sum(n-1)栈	nn_sum(n)栈中EBP值
    nn_sum(n-1)栈	nn_sum(n)栈中EBX值
    nn_sum(n-1)栈	n-2
    nn_sum(n-1)栈	返回地址3
    ....
    --------------------------------
    
    
    
    
    备忘
    --------------------------------
    EBP保存栈底部地址，ESP保存栈顶部地址
    8(%ebp)--永远是传来的第一个参数——记好了，很重要
    "
  - 第一讲 过程（函数）调用（6）——例题
    "奇怪的返回值
    -------------------------------
    double fun(int i){
    	volatile double d[1] = {3.14}
    	volatile int a[2];
    	a[i] = 1073741824;	//十六进制 4000 0000
    	return d[0];
    }
    -------------------------------
    返回值如下
    	i	fun(n)
    	0	3.14
    	1	3.14
    	2	3.1399998664856
    	3	2.00000061035156
    	4	3.14，且存储保护错
    
    
    汇编
    -------------------------------
    push %ebp
    mov %esp,%ebp
    sub $0X10,%esp
    fldl 0X8048518		//把数组按照int型转化为80位浮点，存入寄存器
    fstpl -0X8(%ebp)	//弹出栈，将ST(0)，即栈顶的浮点数存入内存
    mov 0X8(ebp),%eax
    movl $0X4000 0000,-0X10(%ebp,%eax,4)
    fldl -0X8(%ebp)		//返回的double，放在ST(0)中
    leave	//退栈
    ret		//返回
    -------------------------------
    栈
    -------------------------------
    8	i
    4	返回地址
    0	BP旧值
    -4	d7...d4	//a[3]
    -8	d3...d0	//a[2]	//3.14
    -12	a[1]
    -16	a[0]	<-esp
    -------------------------------
    i=2时，冲掉了3.14的尾码最后
    i=3时，冲了更多
    "
  - 第二讲 选择和循环语句的机器级表示（1）——if-else语句
    "需要由一个条件跳转指令和一个无条件跳转指令组成
    
    C语言
    ----------------------------
    int get_cont(int *p1,int *p2){	//栈中。p1和p2实参存在8(%ebp)和12(%ebp)中。很重要
    	if(p1>p2) return *p2;
    	else return *p1;			//比较结果存放在eax中
    }
    ----------------------------
    汇编
    ----------------------------
    movl 8(%ebp),%eax		//eax=p1
    movl 12(%ebp),%edx		//edx=p2
    cmpl %edx,%eax			//求p1-p2得到标志位
    jbe .L1					//若p1<=p2，条件跳转
    movl (%edx),%eax		//eax=*p2
    jmp .L2					//无条件跳转
    .L1
    movl (%eax),%eax		//eax=*p1
    .L2
    leave
    ret
    ----------------------------"
  - 第二讲 选择和循环语句的机器级表示（2）——switch-case语言
    "C语言
    ------------------------------
    int sw_test(int a,int b,int c){
    	int result;
    	switch(a){
    		case 15: c=b&0X0f;
    		case 10: result=c+50;break;
    		case 12: case 17: result=b+50;break; 
    		case 14: result=b;break;
    		default: result=a;
    	}
    	return result;
    }
    ------------------------------
    汇编
    ------------------------------
    	movl 8(%ebp),%eax		//eax=a
    	subl $10,%eax			//eax=a-10				//因为case最小为10 sub(min(case))
    	cmpl $7,%eax			//7和a-10比较
    	ja .L5					//无符号数比较if(a-10>7)，即a>17跳L5(default)
    							//当a<10时，a-10为一负数，无符号解释为一个巨大的数
    							//一定大于7。所以也跳L5
    	jmp *.L8(,%eax,4)								//跳 .L8+4*(a-10)，L8开始为跳转表
    .L1:													//case 15
    	mocl 12(%ebp),%eax		//eax=b	
    	andl $15,%eax			//eax=15&eax->result
    	movl %eax,16(%ebp)		//eax->c
    .L2:													//case 10
    	movl 16(%ebp),%eax		//eax=c	
    	addl $50,%eax			//eax=c+50->result
    	jmp .L7					//break
    .L3:													//case 12 case 17
    	movl 12(%ebp),%eax		//eax=b	
    	addl $50,%eax			//eax=b+50->result
    	jmp .L7					//break
    .L4:													//case 14
    	movl 12(%ebp),%eax		//eax=b->result
    	jmp .L7					//break
    .L5													//default
    	addl $10,%eax			//eax=a-10+10->result=a	
    .L7:
    ------------------------------
    跳转表——存储Ln的值，即相应代码的地址。可执行目标文件
    ------------------------------
    	.section .rodate			//rodate只读数据节
    	.align 4					//对齐方式：4字节。正好为一个地址
    .L8
    	.long	.L2				//a=10					//a-10=0
    	.long	.L5				//a=11					//a-10=1
    	.long	.L3				//a=12					//a-10=2
    	.long	.L5				//a=13					//a-10=3
    	.long	.L4				//a=14					//a-10=4
    	.long	.L1				//a=15					//a-10=5
    	.long	.L5				//a=16					//a-10=6
    	.long	.L3				//a=17					//a-10=7
    	//long表示4字节
    ------------------------------
    注：若case的值差异很大，就不采用跳转表，而是if-else结构
    
    "
  - 第二讲 选择和循环语句的机器级表示（3）——循环结构
    "概述——循环用if-goto表示
    	do-while
    		loop:
    		循环体
    		c=条件表达式
    		if(c) goto loop
    
    	for(e1;e2;e3)
    		e1
    		c=e2
    		loop:
    		循环体
    		e3
    		c=e2
    		if(c) goto loop
    		done:
    
    	while
    		c=条件表达式
    		if(!c) goto done
    		loop:
    		循环体
    		c=条件表达式
    		if(c) goto loop
    		done:
    
    举例
    -------------------------
    int nn_sum(int n){
    	int i; int result = 0 ;
    	for(i=1;i<=n;i++) result+=i;
    	return result;
    }
    -------------------------
    汇编
    -------------------------
    	movl 8(%ebp),%ecx		//n						//因为是简单变量
    	movl $0,%eax			//result					//所以直接放在了寄存器中
    	movl $1,%edx			//i						//否则，一般都是放在栈中
    	cmpl %ecx,%edx			//比较n i
    	jg .L2					//出循环
    .L1
    	addl %edx,%eax			//eax(result)=eax+edx(i)
    	add $1,%edx				//i++
    	cmpl %ecx,%edx			//比较n i
    	jle .L1					//继续循环
    .L2
    -------------------------"
  - 第二讲 选择和循环语句的机器级表示（4）——逆向工程
    "汇编
    -------------------------
    	movl 8(%ebp),%ebx		//fun(unsigned int b)
    	movl $0,%eax			//int a=0
    	movl $0,%ecx			//int c=0
    .L12
    	leal (%eax,%eax),%edx	//int d=a+a=2*a=a<<1
    	movl %ebx,%eax			//a=b
    	andl $1,%eax			//a=1&a=1&b
    	orl %edx,%eax			//a=d|a=d|(1&b)=(a<<1)|(1&b)
    	shrl %ebx				//b=b>>1		//无符号右移
    	addl $1,%ecx			//c++
    	cmpl $32,%ecx
    	jne .L12					//if(c!=32) goto L12
    -------------------------
    发生变化的量 d a b c
    
    源代码
    -------------------------
    fun(int b){
    	int a=0,c;
    	for(c=0;c!=32;c++){
    		a=(a<<1)|(1&b);
    		b>>=1;
    	}
    	return a;
    }
    -------------------------"
- 第八周 复杂数据类型的机器数表示
  - 第一讲 数组和指针类型的分配和访问（1）——数组
    "static short A[4] 访问 A[i]
    	地址计算公式为：&A[0] + 2*i
    	如果当前操作有数组，那么数组首地址一定在EDX中(错，仅全局/静态数组如此)，索引/下表一定在ECX中
    	A[i]->ax的汇编—— movw (%edx,%ecx,2),%ax
    	括号为edx+ecx*2
    
    auto数组(函数中定义的普通数组)
    	分配在栈中
    	首地址通过ebp定位
    	A[0]分配在ebp-8，则A[1]分配在ebp-4。汇编：movl $12,-8(%ebp)
    
    知识点/补遗
    ------------------------------
    w-双字节 16位
    ECX-变址寄存器/索引寄存器，在循环体中增量
    静态区——在函数外定义的变量，链接后，出现在可执行文件的数据段"
  - 第一讲 数组和指针类型的分配和访问（2）——数组和指针
    "小端方式
    	地址0X08048A00	01H
    					1	23H
    					2	45H
    					3	67H
    	若0X08048A00存放了一个int，则值位67452301H
    
    int A[8]，已知A首地址存放在ecx中，i存放在edx中，表达式结果存放在eax中，求下面表达式的汇编
    	A				leal (%ecx),%eax					//因为是对地址操作
    	A[0]			movl (%ecx),%eax				//lea和mov的区别出现了
    	A[i]				movl (%eax,%edx,4),%eax
    	&A[3]			leal 12(%ecx),%eax		
    	&A[i]-A			movl %edx,%eax					//!! p1-p2==(p1算术减p2)/sizeof(*p1)
    	*(A+i)			movl (%eax,%edx,4),%eax
    	*(&A[0]+i-1)	movl -4(%eax,%edx,4),%eax
    	A+i				leal (%eax,%edx,4),%eax"
  - 第一讲 数组和指针类型的分配和访问（3）——指针数组和多维数组
    "指针数组 int *a[8]
    多维数组 int a[8][8]，*a[i]还是个指针
    
    多维数组存放——行优先
    	char c[2][2]={{1,2},{3,4}}
    	char *p[2] = {c[0],c[1]}
    存储
    	0X12345678		01			//**c , *c[0] , c[0][0]
    	0X12345679		02			// c[0][1]
    	0X1234567A	03			//*c[1] , &c[1][0]
    	0X1234567B	04			//c[1][1]
    	0X1234567C-F	78 56 34 12	//P[0] , C[0]
    	Ox12345680-3	A7 56 34 12	//P[1] , C[1] "
  - 第二讲 结构体和联合体的分配与访问（1）——结构体
    "分配
    	auto型			分配在栈中，有ebp/esp定位
    	static/全局变量	分配在静态数据区
    
    访问（寻址）
    	结构体存在一个首地址（基址），利用 基址+偏移量 寻址
    
    举例
    -------------------------------
    struct cont_info{
    	char id[8];				//id，偏移量0
    	char name[12];			//name，偏移量8
    	unsigned post;			//post，偏移量8+12=20
    	char address[100];		//address，偏移量20+4=24
    	char phone[20];			//phone，偏移量24+100=124
    }
    -------------------------------
    struct cont_info x = {....};
    	&x = &(x.id)
    	&(x.phone) = &x + 124
    
    unsigned xpost = x.post	汇编为	movl 20(%edx),%eax		//edx存基址
    
    传地址和传值
    	传值时所有结构成员复制到参数区，增大时间空间开销，而且无法修改数据
    	所以使用传地址。
    		//x->name
    		movl 8(%ebp),%edx 	//取结构体地址
    		leal 8(%edx),%eax	//找到其中的name变量的地址
    "
  - 第二讲 结构体和联合体的分配与访问（2）——联合体
    "成员共享存储空间，按最大成员分配空间
    	优点：若有两个变量的使用时互斥的，就可以使用联合体，节省空间
    	缺点：编程复杂
    
    举例
    ------------------------------------
    unsigned float2unsigned(float t){
    	union{float t; , unsigned u;}tmp;
    	tmp.f = f;
    	return tmp.u;
    }
    ------------------------------------
    
    汇编片段
    ------------------------------------
    movl 8(%ebp),%eax			//tmp.f=f;
    movl %eax,-4(%ebp)			//???
    movl -4(%ebp),%eax			//return tmp.u;
    ------------------------------------
    
    
    联合体实现链表
    	疯了"
  - 第三讲 数据的对齐存放（1）——知识点
    "原因：机器字长32/64位，主存按照一个传送单位进行存取。
    	若传送单位32位，即每次最多读写32位，如0-3字节，4-7字节
    	若一个数据位于3、4字节，就要读两次
    	因此对齐即数据存放在4i-4i+3单元
    
    对齐方法——
    字数据地址(32位int)，放在4倍数位置
    半字地址(16位short)，放在2的倍数位置
    字地址(8位char)，任意放置
    	windows对齐：数组多长，就怎么对齐，double 8字节对齐
    	Linus对齐：数据大于等于4字节的，也按照4字节对齐
    
    举例一。下面数据int short double char short依次存放
    	0	1	2	3
    00	*	*	*	*		00-03放int
    04 	*	*	/	/		04-05放short，因此double对齐4，所以不放06 07
    08	*	*	*	*		08-15放double
    12	*	*	*	*		
    16	*	/	*	*		16放char	17不放short，放18 19
    
    举例二。结构体struct CD{int short char double}
    	!——首先结构体的首地址一般是4字节对齐。
    	int		0-3
    	shourt	4-5
    	char	5
    	double	8-15	即67没用
    
    举例三。结构体数组。struct CD[]{int int char}
    	CD[0]	int(0-3) int(4-7) char(8)
    	CD[1]	int(12-15) int(16-19) char(20)
    	即，9 10 11被浪费"
  - 第三讲 数据的对齐存放（2）——C语言中对齐方式的设定
    "#pragma pack(n)
    	告知编译器对结构体/类的成员变量对齐方式
    	当自然边界对齐方式>n时，按照n字节对齐。
    	如double原本为8字节，若n=4，就改为4字节对齐。
    __attribute__((aligned(m)))
    	告知编译器对结构体/类、以及单独变量的对齐方式
    	m必须是2的幂次，同时其占用的空间也是m的整数倍，以保证在申请连续存储空间时各元素也按照m字节对齐
    __attribute__((packed))
    	不对齐，即#pragma pack(1)
    
    -----------------------------------------------------------------
    举例。
    	#pragma pack(4)，结构体int char char int double，__attribute__((aligned(1024)))
    	int		0-3
    	char	4
    	char	5
    	int		8-11
    	double	12-开始，4字节对齐
    	!——同时siozeof(结构体) = 1024 ，因为__attribute__((aligned(1024)))"
  - 第四讲 越界访问和缓冲器溢出攻击
    "回忆一道例题——奇怪的返回值
    -------------------------------
    double fun(int i){
    	volatile double d[1] = {3.14}
    	volatile int a[2];
    	a[i] = 1073741824;	//十六进制 4000 0000
    	return d[0];
    }
    -------------------------------
    返回值如下
    	i	fun(n)
    	0	3.14
    	1	3.14
    	2	3.1399998664856
    	3	2.00000061035156
    	4	3.14，然后存储保护错
    
    原因：数组访问越界
    	4	栈数据	/ a[4]
    	3	d7...d4 / a[3]
    	2	d3...d0 / a[2]
    	1	a[1]
    	0	a[0]
    
    C语言中，超出数组界限的操作，不会进行越界检查。
    缓冲区溢出：写入数组时，超过数组范围。
    
    
    攻击：利用溢出时程序转到自己的hacker中运行
    -------------------------
    void outputs(char *str){
    	char buffer[16];
    	strcpy(buffer,str);
    	printf("%s\n",buffer);
    }
    void hacker(void){
    	printf("being hacker\n");
    }
    int main(int argc,char* argv[]){
    	outputs(argv[1]);		//是1不是0，因为argv[0]=“./test” argv[1]="参数" argv[3]=“\0”
    	return 0;
    }
    -------------------------
    栈状态
    -------------------------
    main栈		...
    		命令行参数首地址		//给outputs的参数
    			返回地址
    outputs栈	EBP旧值
    			buffer[15]-[12]
    			....
    			buffer[3]-[0]		//分配的局部变量buffer
    			M[R[ebp]+8]		//取str地址
    			R[ebp]-16			//buffer地址		这两个作为strcpy参数
    			返回地址
    strcpy栈
    -------------------------
    若命令行字符超过25个，使用strvpy会时buffer溢出，并破坏返回地址。
    若25字符，后4个为hacker地址，就会执行hacker代码
    
    segmentation error 段错误"
- 第九周 x86-64指令系统--2019年5月2日
  - 第一讲 概述
    "和IA-32最大不同之处：过程调用时参数传递不同
    
    Intel最先退出的64位架构——IA-64和IA-32不兼容。结果没有市场
    2003年。AMD公司推出兼容IA-32的x86-64架构，后更名为AMS64
    2004年。Intel推出兼容x86-64的IA32-EM64T。后更名为Intel64
    
    IA-32汇编指令长度后缀
    	整数b8    w16    l32
    	浮点数s32-float    l64-double    t80(实际长度)/96(为了4B对齐)
    	long为32位
    	地址32位
    
    
    x86-64汇编指令长度后缀
    	整数多出  q64位
    	浮点数  t变为80/128
    	long为64位
    	地址64位
    
    
    新增寄存器
    	8个64位通用寄存器（整数）——R8~R15
    	可作为8 16 32 位寄存器使用，如R8B R8W R8D
    	
    	以前的EAX EBX ECX EDX EBP ESP ESI EDI 8个E开头的32位寄存器，扩展为R开头的64位
    	同时新增EBP ESP ESI EDI的低8位BPL SPL SIL DIL
    	AH BH CH DH继续兼容
    	总结：每个通用寄存器都可以当8 16 32 64使用——SIL SI ESI RSI
    
    	总结：8 16 32 64位寄存器共8(以前的)+8(R8~15)=16个
    
    	变化：因为寄存器很多。通过寄存器可以传递参数，所以很多过程不需要访问栈，故RBP可以当作普通寄存器。
    		程序计数器变为64位，RIP。"
  - 第二讲 x86-64基本指令（1）——传送指令
    "movabsq $10,R 把64位立即数送到R寄存器
    movq 传送64位数据
    movsbq  movswq  movslq  表示将b8，w16，l32的数符号扩展到64位，再传送
    movzbq  movzwq  表示0扩展
    
    pushq S 压栈，栈下移8字节
    popq D  退栈
    
    举例：强制类型转换
    原类型			目标类型		指令
    char			long			movsbq %dil,%rax
    int				long			movslq %edi,%rax
    long			long			movq %rdi,%rax
    long			int				movl %edi,%eax
    unsigned int		unsigned long	movl %edi,%rax
    unsigned long	unsigned int		movl %edi,%eax
    unsigned char	unsigned long	movzbq %dil,%rax	//零扩展
    
    
    
    -------------
    q-64位"
  - 第二讲 x86-64基本指令（2）——算术逻辑指令 比较测试指令
    "新增：addq   subq   incq   decq   imulq   orq   salq   leaq
    	解释：inc加1   dec减1   imul带符号乘   or或   sal算术左移   lea传送地址
    
    cltq clto将eax扩展为64位/128位。
    128位数据总是放在RDX-RAX中
    若用隐含的操作数，总在RAX中
    
    举例。汇编指令
    ---------------------------------------
    movslq %ecx,%rcx		//(int)c->(long)c
    imulq %rdx,%rcx			//(long)d*(long)c->c
    movsbl %sil,%esi			//(char)s->(int)s
    imull %edi,%esi			//(int)d*(int)s->s
    movslq %esi,%rsi		//(int)s->(long)s
    leap (%rcx,%rsi),%rax	//(all long)c+s->a
    ---------------------------------------
    
    简写：
    add a,b
    moc b,c
    简写为 lea (a,b),c
    
    比较 测试指令
    	cmpq a,b	a-b
    	test a,b		a^b
    	产生标志位"
  - 第二讲 x86-64基本指令（3）——逆向工程举例
    "已知x86-64汇编代码如下
    -----------------------------------------
    	movl $0,%ecx		//l-32位
    	movl $0,%edx		//ecx=edx=0
    	movabsq $72340172838076673,%rsi		//把64位立即数送到R寄存器--rsi
    				//72340172838076673=2^56+2^48+2^40...32..24..16..8..0
    				//0X0101010101010101
    .L1
    	movq %rdi,%rax		//q-64位。rax=rdi
    	andq %rsi,%rax		//rax&=rsi
    	addq %rax,%rcx		//rcx+=rax
    	shrq %rdi			//shr-逻辑右移	rdi>>>1
    	addl $1,%edx		//edx++
    	cmpl $8,%edx		//
    	jne .L1				//不等于 if(edx!=8) goto .L1
    	movq %rcx,%rax		//rax=rcx
    	sarq $32,%rax		//sar-算数右移 rax>>32
    	addq %rcx,%rax		//rax+=rcx
    	movq %rax,%rdx		//rdx=rax
    	sarq $16,%rdx		//rdx>>16
    	addq %rax,%rdx		//rdx+=rax
    	movq %rdx,%rax		//rax=rdx
    	sarq $8,%rax		//rax>>8
    	addq $rdx,%rax		//rax+=rdx
    	andl $255,%eax		//eax&=255
    	ret
    -----------------------------------------
    
    原C语句
    -----------------------------------------
    long test(unsigned long x){		//传参放到rdi
    	long val = 0;					//放在32位的ecx
    	int i;						//edx
    	for(i=0;i!=8;i++){			//
    		val+=x&0X0101010101010101;		//每个字节1的个数
    		x>>=1;
    	}
    	val+=(val>>32);
    	val+=(val>>16);
    	val+=(val>>8);
    	return val&0XFF;
    }
    -----------------------------------------
    功能unsigned long x的1的个数"
  - 第三讲 x86-64的过程调用（1）——参数传递方式，寄存器使用约定
    "C源代码
    -----------------------------------
    long int sample(long int* xp,long int y){
    	long int t = *xp + y;
    	*xp = t;
    	return t;
    }
    -----------------------------------
    IA-32汇编代码（在x86-32上，运用gcc -O1 -S -m32 sample.c  获得和IA-32兼容的汇编代码）
    -----------------------------------
    pushl %ebp
    movl %esp,%ebp
    movl 8(%ebp),%edx		//*xp  32位
    movl 12(%ebp),%eax		//y
    addl (%edx),%eax		//y=*xp+y
    movl %eax,(%edx)		//*xp=y
    popl %ebp
    ret
    -----------------------------------
    x86-64汇编代码（在x86-32上，运用gcc -O1 -S [-m64] sample.c  获得和x86-64的汇编代码）
    -----------------------------------
    movq %rsi,%rax			//y  64位
    addq (%rdi),%rax		//y=*xp+y
    movq %rax,(%rdi)		//*xp=y
    ret
    -----------------------------------
    不同之处，后者使用寄存器传递参数，后者64位long和地址
    
    只有当参数超过6个整型/指针时，才使用栈
    寄存器使用约定——
    	参数1	rdi
     	参数2	rsi
    	参数3	rdx
    	参数4	rcx
    	参数5	r8
    	参数6	r9
    	返回值	rax
    注：以上为64位参数。
    	32位为相应的e**,e8d
    	16位为相应的**,r8w
    	8位为相应的dil,DL,r8b
    
    参数超过6个的，后面的参数通过栈传递
    栈中传递的参数，若是基本类型，都被分配为8个字节（IA-32是都分配4字节）
    call/callq将64位返回地址保存在栈里，先执行rsp-8分配空间
    
    IA-32中，EBP/ESP栈指针，EAX ECX EDX为主调函数保存，故先使用。EBX ESI EDI为被调用者保存，后使用，最后恢复
    x86-64中，RSP栈指针，RAX R10 R11为主调函数保存，RBX RBP R12 R13 R14 R15需要先保存后使用，最后还要恢复"
  - 第三讲 x86-64的过程调用（2.1）——举例--caller函数call前
    "C源代码
    -----------------------------------------
    long caller(){
    	char a=1;	short b=2;
    	int c=3;		long d=4;
    	test(a, &a, b, &b, c, &c, d, &d);
    	return a*b+c*d;
    }
    void test(char a,char *ap,short b,short* bp,int c,int* cp,long d,long* pd){//8个参数
    	*ap+=a;
    	*bp+=b;
    	*cp+=c;
    	*dp+=d;
    }
    -----------------------------------------
    caller汇编
    -----------------------------------------
    subq $32,%rsp		//栈顶外移32
    movb $1,16(%rsp)	//a=1
    movw $2,18(rsp)		//b=2
    movl $3,20(%rsp)	//c=3
    movq $4,24(%rsp)	//d=4
    leap 24(%rsp),%rax
    movq %rax,8(%rsp)	//&d传参 参数8
    movq $4,(%rsp)		//d传参    参数7
    leap 20(%rsp),%r9	//参数6 &c
    movl $3,%r8d		//参数5 c
    leap 18(%rsp),%rcx	//参数4 &b
    movw $2,%dx		//参数3 b
    leap 16(%rsp),%rsi	//参数2 &a
    movb $1,%dil		//参数1 a
    call test
    -----------------------------------------
    执行到caller的call质指令之前，栈中状态
    	局部变量a b c d在栈中，8个参数的后2个也在栈里面
    -----------------------------------------
    24		d=4				//64位
    16	c=3 | b=2 |  | a=1		//32|16|8空|8		//因为short-b对齐2字节，故空位
    8		&d(24)			//64位，下同
    0		d				<-RSP
    -----------------------------------------
    执行到caller的call质指令之前，寄存器状态
    dil=a	rsi=&a	dx=b	rcx=&b	r8d=c	r9=&c"
  - 第三讲 x86-64的过程调用（2.2）——举例--被调函数
    "C源码
    -----------------------------------------
    void test(char a,char *ap,short b,short* bp,int c,int* cp,long d,long* pd){//8个参数
    	*ap+=a;
    	*bp+=b;
    	*cp+=c;
    	*dp+=d;
    }
    -----------------------------------------
    汇编
    已知
    dil-a	rsi-&a	dx-b	rcx-&b
    r8d-c	r9-&c	(rsp)-d	8(rsp)-&d
    RAX R10 R11寄存器可任意使用
    -----------------------------------------
    movq 16(%rsp),%r10		//r10=&d
    addb %dil,(%rsi)			//*ap+=a;
    addw %dx,(%rcx)		//*bp+=b;
    addl %r8d,(%r9)			//*cp+=c;
    movq 8(%rsp),%rax		//rax=d
    addq %rax,(%r10)		//*dp+=d;
    ret
    -----------------------------------------"
  - 第三讲 x86-64的过程调用（2.3）——举例--caller函数call后
    "C源码
    -----------------------------------
    long caller(){	
    	char a=1;	short b=2;
    	int c=3;		long d=4;
    	test(a, &a, b, &b, c, &c, d, &d);
    	return a*b+c*d;}
    -----------------------------------
    汇编之call test之后
    -----------------------------------
    movslq 20(%rsp),%rcx		//slq-l32的数符号扩展到64位，再传送		//rcx=c
    movq 24(%rsp),%rdx													//rdx=d	
    imulq %rdx,%rcx				//有符号乘								//dcx=c*d
    movsbw 16(%rsp),%ax		//sbw-8到16位							//ax=a
    movw 18(%rsp),%dx													//dx=b
    imulw %dx,%ax														//ax=a*b
    movswq %ax,%rax			//swq-16位到64位						//rax=ax
    leap (%rax,%rcx),%rax												//rax+=rcx
    addq $32,%rsp														//rsp+32退？
    ret
    -----------------------------------
    
    
    附录
    执行到caller的call质指令之前，栈中状态	局部变量a b c d在栈中，8个参数的后2个也在栈里面
    -----------------------------------------
    24		d=4				//64位
    16	c=3 | b=2 |  | a=1		//32|16|8空|8		//因为short-b对齐2字节，故空位
    8		&d(24)			//64位，下同
    0		d				<-RSP
    -----------------------------------------"
  - 第三讲 x86-64的过程调用（3）——和IA-32的比较
    "C语言
    -------------------------------------
    #include<stdioh>
    main(){
    	double a = 10;
    	printf("a=%d\n",a);
    }
    -------------------------------------
    在IA-32上运行时，打印a=0
    在x86-64上运行时，打印值不确定
    
    解答：
    (double)10=10101B=1.01*2^3
    阶码3+1023=10000000010B
    所以10double=0 10000000010 0100....0B
    即4024 0000 0000 0000H
    
    fldl		局部变量区->ST(0)		//f-浮点数  ld-load装入  l-double数据
    fstpl	ST(0)->参数区(栈)		//st-store
    
    执行call printf前的栈
    -------------------------------------
    16	参数2	40H 24H 00H 00H
    12	参数2	00H 00H 00H 00H
    8	参数1	字符串"a=%d\n"指针
    4				返回地址
    (0				EBP旧值)
    -------------------------------------
    所以printf会取12单元中的00000000，解释为0
    
    引申
    在IA-32中若a位=为float变量，结果一样。
    汇编代码是flds和fstpl，首先将32位float存入80位浮点寄存器，再转为64位送到栈中
    
    
    ------------------------------------------------------------------------------------
    x86-64中的浮点数
    long double型为80位(10B)，但分配空间从12B到了16B，即16B对齐。（只用低10位）
    128位XMM寄存器从8个增加到16个
    浮点指令集采用基于SSE的面向XMM寄存器，不采用x87 FPU指令集
    浮点操作数放在XMM中
    
    c源码的x86-64汇编
    -------------------------------------
    .LC1:
    	.string "a=%d\n"
    ....
    movsd .LC0(%rip),%xmm0		//a送xmm0
    movl $.LC1,%edi					//RDI高32位为零
    movl $1,%eax
    call printf
    addq $8,%rsp
    ret
    ....
    .LC0:
    	.long 0						//00000000H
    	.long 1076101120				//40240000H
    -------------------------------------
    
    因为浮点数a存放在xmm中，没有在栈里。
    而printf第二个参数a，会被当作第二个参数，放在约定的ESI中，这是一个不确定的数。"
- 第十周 链接概述和目标文件格式
  - 第一讲 可执行文件生成概述（1）——可执行文件生产过程
    "总论：链接，可重定位目标文件，可执行目标文件，共享库文件
    
             CPP                  cc1                     as                      ld
    .c------------->.i------------->.s------------->.o------------->可执行文件
    	.c源程序文件（文本）
    	CPP预处理
    	.i预处理文件（还是文本文件）
    	cc1编译
    	.s汇编语言源程序（文本）
    	as汇编
    	.o可重定位目标程序（二进制）
    	ld链接（如hello.c+printf.o）
    
    预处理CPP
    	单独命令gcc -E a.c a.i 或 cpp a.c>a.i	//a为文件名
    	1.删除#define，展开其中的宏
    	2.处理条件预编译指令，如#if、#ifdef、#endif
    	3.插入头文件到#include处，递归完成
    	4.删除注释
    	5.添加行号和文件名标识，以便编译器编译时产生调试信息
    	6.保留所有编译指令#pragma，因为编译器需要使用
    
    编译compiler
    	单独命令gcc -S a.i -o a.s 或gcc -S a.c -o a.s 或者cc1 a.c	//即从.i/.c都可以到.s，-o指定输出
    	词法分析，语法分析，语义分析并优化，最终生成汇编代码文本文件
    
    汇编
    	汇编指令和机器指令一一对应，前者符号表示，都输入机器级指令
    	命令gcc -c a.s -o a.o 或 gcc -c a.c -o a.o 或 as a.s -o a.o
    
    链接
    	预处理，编译，汇编。都是针对一个模块（一个.c文件）处理，得到.o文件
    	多个相关的.o文件链接合并，得到可执行文件
    	命令 gcc -static -o myproc main.o test.o //-o指定输出 myproc指定输出文件名称，默认a.out 后面两个.o文件为要链接的文件
    	命令二 ld -static -o myproc main.o test.o  //专门程序
    	
    	"
  - 第一讲 可执行文件生成概述（2）——链接器的由来
    "原始的链接概念在高级语言出现前就已经存在
    	最初没有重定位，在jmp 0100的jmp和0100指令间新增一条指令，就需要吧0100改为0101
    	后来利用符号jmp L0表示需要跳转的位置
    	确定L0具体位置——先确定L0具体地址，然后jmp后面改为该地址（最原始的链接）
    	再后来，多个模块合并，确定地址，就称为链接
    
    链接步骤
    	1.确定符号引用关系
    
    
    举例
    P0.o
    ----------------------------------------------------
    P0:	add B
    	jmp L0
    	call P1
    L0:	sub C	//以上程序段
    B:	10
    C:	20		//以上数据段
    ----------------------------------------------------
    P1.o
    ----------------------------------------------------
    P1:	add A
    	sub B	//以上程序段
    A:	30		//以上数据段
    ----------------------------------------------------
    首先把P0.o和P1.o程序段和数据段分别合并
    ----------------------------------------------------
    P0:	add B
    	jmp L0
    	call P1
    L0:	sub C
    P1:	add A
    	sub B	//以上程序段
    A:	30
    B:	10
    C:	20		//以上数据段
    ----------------------------------------------------"
  - 第二讲 目标文教格式概述（1）——总述
    "主要介绍Linux下elf文件格式
    
    每个模块有自己的代码、数据（初始化全局变量、未初始化局部变量、静态变量、局部变量）
    	局部变量分配在栈中，不会在过程外被调用，因此布什符号定义。
    不同模块分别预处理、编译、汇编，得到单独的可重定位.o文件，再链接一起成为一个单个的可执行文件文件
    
    实例，两个模块
    ------------------------------
    //main.c
    int buf[2] = {1,2};		//全部变量，已初始化，放到data段
    void swap();
    
    int main(){				//代码段
    	swap();
    	return 0;
    }
    ------------------------------
    //swap.c
    extern int buf[];
    
    int *bufp0 = &buf[0];	//全局变量
    static int *bufp1;			//静态局部变量			//未初始化 bss段
    
    void swap(){
    	int temp;			//局部变量
    	bufp1 = &buf[1];
    	temp = *bufp0;
    	*bufp0 = *bufp1;
    	*bufp1 = temp;
    }
    ------------------------------
    
    生成的可重定位文件(地址从0开始)
    	main.o text代码段 data数据段
    	swap.o text代码段 data数据段 bss段
    	系统本身有自己的一些 text代码段 data数据段
    最后链接为可执行文件(地址从0X0804 8000开始，虚存地址)(.xxx为不同的节)
    	FLE头
    	程序段头表(描述怎么映射到每一段)
    	整个代码段  .init   .test  .rodata(只读数据)
    	整个数据段  .data   .bss
    	.systab   .debug   .line   .strtab
    
    
    Linux虚存空间结构(32位 共4G)
    ----------------------------------
    0XC000 0000 内核虚存区
      往				用户栈User stack(向小地址生长↓)
      下
      减				共享库区域
      小
    				堆heap，由mallc生成(向高地址生长↑)
    				读写数据段  .data  .bss ↑
    0X0804 8000	只读数据段 .init  .test.  .rodata ↑
    0X0000 0000	未使用区域
    ----------------------------------
    
    
    
    资料：
    ----------------------------------
    可执行程序包括BSS段、数据段、代码段（也称文本段）。
    BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。
    数据段包括初始化的数据和未初始化的数据（BSS）两部分 。BSS段存放的是未初始化的全局变量和静态变量
    
    "
  - 第二讲 目标文教格式概述（2）——详述
    "三类目标文件
    	可重定位目标文件 .o/.obj
    		每个.o由一个.c生成，地址从0开始
    	可执行目标文件 .out/.exe
    		代码和数据复制到内存即可执行，地址位虚拟空间地址
    	共享的目标文件 .so/.dll
    		特殊的可重定位文件，动态链接——装入内存时链接
    
    目标文件格式
    	DOS中的 .com 文件，只有代码、数据，不用虚拟地址
    	UNIX coff格式除了代码、数据，还有重定位信息、调试信息、符号表等
    	Windows PE格式(COFF变种) PE-可执行可移植
    	Linux ELF格式(COFF变种) RLF-可执行可链接
    
    ELF文件——可执行、可链接文件，分为两个视图
    	链接视图——即可重定位目标文件、共享目标文件，扩展名.o
    			为了能够链接，还提供符号表、重定位信息等其他节
    			!!只有节，没有段的概念
    	执行视图——可执行目标文件
    			!!段，多个节。如data节+bss节==可读可写段
    			
    
    节——ELF文件中，具有相同属性的最小可处理单位
    段——一个段可以包含多个节。只在可执行文件中才有段的概念"
  - 第三讲 ELF可重定位文件(链接视图、ELF头、节头表)
    "重点：ELF头、节头表
    
    可重定位文件格式
    	ELF头：16字节标识信息、文件类型、机器类型、节头表的偏移(指针)、节头表的表项大小个数
    	.text节:代码部分。可执行
    	.rodata节：只读数据。如printf中的格式串、switch跳转表。只读
    	.data节：已初始化的全局变量(仅仅是全局变量，局部变量没有，后者在栈中自动生成)。读写
    	.bss节：未初始化的局部变量，仅仅是占位符，不占任何硬盘存储，仅仅在节头表中记录变量长度。
    		（区分初始化和未初始化是为了节约空间效率，因为默认值为0）。读写
    		（bss名字：block started by symbol 最初是某汇编程序的一个伪指令，用于为符号预留空间）
    	.symtab节：函数名和全局变量信息
    	.rel.text节：text节的重定位信息，在链接中使用
    	.rel.data节：data节的重定位信息，在链接中使用
    	.debug节：调使用符号表(gcc -g)
    	.strtab节：包含symtab和debug节中的符号即节名
    	节头表Section header table：存储每个节的指针和大小。说明bss节占用多大空间
    
    ELF头--是一个struct结构(共52字节=34H)
    	位于ELF文件开始，包含文件结构说明信息。由32位/64位不同版本
    	ELF魔数、版本、大小端、操作系统平台、目标文件格式、机器结构、程序入口、段头表、节头表..
    	魔数：linux a.out 01H07H / PE模式 4DH 5AH（用来确认文件类型和是否正确）
    		可重定位文件的ELF头 7F 45 4C 46
    	readelf -h main.o 读eld信息
    		可以看出可重定位文件中，没有程序头表
    		15个表项，每个40字节。15*40B
    
    节头表（有多个表项组成）
    	描述每个节的名字、偏移offset、大小size、访问属性、对齐方式...
    	每个表项40B（也是struct结构）
    	readeld -S test.o 读节头表信息
    		可以看到虚拟地址都是0
    
    分配存储空间的四个节
    	执行：.text
    	读写：.data   .bss
    	只读：.rodata
    
    "
  - 第四讲 ELF可执行文件概述(执行视图)
    "结构（段-相同的访问属性，所以合并）
    	只读(代码)段：ELF头/程序头表/.init/.text/.rodata
    	读写(数据)段：.data/.bss
    	无需装入内存的信息：.symtab/.debug./.strtab/.line/节头表
    
    不同之处
    	e_entry：位于ELF头中，给出程序执行的第一条指令的地址，在可重定位文件中为0
    	程序头表/段头表：结构数组，说明节和段的关系，即映射信息。可执行文件独有
    	.init节：处于定义_init()函数，完成执行前的初始化工作
    	少了两个.rel节：用于重定位的，所以可执行文件中不需要
    	地址不再是0，而是虚拟地址
    	符号已经重定位
    
    ELF头信息  52字节
    	readelf -h main  指令
    	魔数：7F 45 4C 46  (ELF的ASCII码)
    	入口地址：x8048580
    	29个表项。长度29*40B
    
    程序头表PHFR  8个表项,每项32字节，size=0X00
    	readelf -l main
    	说明节与段的映射关系，所以称为段头表
    	每个表项32字节，说明虚拟空间中一个连续的段或者一个特殊的节
    	load 可装入段（两个）
    		第一个load：装入只读代码段
    			文件中0x00000~0x004d3，包括ELF头/程序头表/.init/.text/.rodata
    			装入到虚拟空间0x8048000开始的地方，按照0x100即4k对齐
    			权限：只读
    		第二个load，装入读写数据段
    			文件中0x000f0c开始到0x108开始的.data数据
    			映射到虚拟空间0x8049f0c开始的0x110字节的区域(到0x8050000)
    			可是看到0x108时.data数据。之后的8字节，对应.bss节，初始化为0
    			4k对齐
    			权限：读写
    	
    	
    
    
    
    备忘
    ---------------------------------------
    Linux虚存空间结构(32位 共4G)
    ----------------------------------
    0XC000 0000 内核虚存区
      往				用户栈User stack(向小地址生长↓)
      下
      减				共享库区域
      小
    				堆heap，由mallc生成(向高地址生长↑)
    				读写数据段  .data  .bss  ↑
    0X0804 8000	只读数据段 .init  .test.  .rodata  ↑
    0X0000 0000	未使用区域
    ----------------------------------
    	
    "
- 第十一周 符号及符号解析
  - 第一讲 符号及符号表（1）（简述符号解析、符号分类、符号表、重定位）
    "回顾：链接即合并多个可重定位文件(.o)。（下文详述）
    	第一步：符号解析--确定符号引用关系
    		下面二至四步称为重定位
    	第二步：合并.o文件
    		代码与代码合并，数据与数据合并，这时每条代码、每个变量都有唯一的地址(从0开始)
    		正是因为确定了地址，每个符号的地址自然就知道了
    	第三步：确定符号地址
    	第四步：在指令中填入新地址
    
    符号解析symbol resolution
    	第一步：解析源代码
    		void swap(..){...}	//定义符号swap
    		swap();			//引用了符号
    		int* xp = &x;	//定义符号xp，引用符号x
    	第二步：①将定义的符号存放至符号表symbol table
    		即.symtab节，是一个struct数组。内容：符号名、长度、位置等（下文详述）
    			②将引用的符号存放在重定位节
    		即.rel.text/.rel.data中
    	至此，建立起了符号的定义和引用之间的关系
    
    符号分类——对应某个特定模块内的符号，有以下三种
    	全局符号global symbol：不带static的全局变量/函数
    	外部符号external symbol：本模块中使用，但是定义于其他模块
    	局部符号local symbol：static的全局变量和函数
    
    符号表symtab——每个表项大小16B
    	name符号名（字符串）
    	Ot对应节中的偏移量（即虚拟地址）
    	size字节长度（若符号为函数，则是整个函数代码的长度）
    	type符号类型：数据？函数？源文件？节？未知？
    	bind绑定属性：全局符号？局部符号？弱符号？
    	Ndx符号所在的节：用节头表里的节序号表示。
    		ABS-不重定位。UND--未定义。COM-未初始化(.bss节)。
    至此.bss节全部弄懂——节头表说明其大小，符号表说明其中每个变量的大小、位置
    
    重定位
    	第一步：多个.o文件的代码段和数据段合并位单独的代码段/数据段。
    	第二步：确定每个定义符号在虚拟地址的绝对地址。
    	第三步：将符号引用处的地址修改为重定位后的地址。
    
    实例
    -------------------------------------
    //main.c文件
    int buf[2] = {1,2};//全局变量定义
    void swap();//弱符号/外部符号。定义在外部，这里只是说明将要使用这个外部符号
    
    int main()/*main函数是 符号定义*/{
    	swap: //引用
    	return;
    }
    -------------------------------------
    //swap.c文件
    extern int buf[];//弱符号/外部符号
    int *bufp0 = &buf[0];//定义
    static int* bufp1;//局部符号定义
    
    void swap()/*定义*/{
    	int temp;//局部变量，不是符号
    	bufp1/*引用*/ = &buf[1]/*引用*/;
    	temp = *bufp0/*引用*/;
    	*bufp0/*引用*/ = *bufp1/*引用*/;
    	*bufp1/*引用*/ = temp;
    }
    -------------------------------------
    
    main.o文件符号表（部分）
    -------------------------------------
    Num	value	size	type	bind	Ot	Ndx	name
    8:		0		8	Data	Global	0	3		buf
    9:		0		33	Func	Global	0	1		main
    10:		0		0	Notype	Global	0	UND	swap
    -------------------------------------
    说明：
    	num--编号
    	size--大小，如buf为int[2]，所以大小8
    	type--类型，数据、函数，未知符号(因为swap在外部定义，所以不知道具体是什么类型，大小也不知道)
    	bind--绑定属性，这里的三个都是全局变量
    	Ot--所在节的偏移量，都是0
    	Ndx--节序号。3--.data节，1--.text节。UND--未定义。COM--未初始化.bss"
  - 第一讲 符号及符号表（2）（详述符号解析、强弱符号）
    "符号解析/又称为符号绑定
    	目的：将符号引用和符号定义建立关联。这样在重定位时，引用符号的地址就可以修改为定义符号的地址。
    	"定义符号"的值即其首地址
    
    局部符号因为定义和引用都在本模块，所以解析很简单，下面只考虑全局符号
    
    全局符号的强、弱（只有定义全局符号才有强弱之分，引用无强弱，局部符号也没有）
    	强符号：所有函数名、已初始化的全局变量
    	弱符号：未初始化的全局变量
    		如void swap();只有函数声明，其定义在其他模块中。extern int buf[];也是只有声明。
    	规则：
    		!!!多个模块中，强符号定义只能出现一次，否则链接错误
    		若一个符号有一次强定义、多次弱定义，以强定义为准
    		若只有弱定义，没有强定义，任选一个。gcc -fno -common链接会输出警告信息
    		目的：每个符号只占用一处存储空间"
  - 第一讲 符号及符号表（3）（多重定义符号的解析的3个例子）
    "C源代码(以下程序链接时会出错吗？)
    ----------------------------------------
    //main.c
    int x = 10;
    int p1(void);//弱定义
    int main(){x = p1();	return x;}
    ----------------------------------------
    //p1.c
    int x = 20;
    int p1(){return x;}
    ----------------------------------------
    分析：
    	main()，一次定义，且是强定义
    	p1()，一次强定义，一次弱定义
    	x两次强定义，所以链接器会输出出错信息，无法链接
    
    
    下一题。
    ----------------------------------------
    //main.c
    #include<stdio.h>
    int y = 100;//强定义		int z;//弱定义	void p1(void);//弱定义
    int main(){z = 1000; p1() ;printf("%d,%d",y,z); return 0;}
    ----------------------------------------
    //p1.c
    int y,z;//这里的y、z都是弱定义
    void p1(){y = 200; z = 2000;}
    ----------------------------------------
    分析：没有多次强定义，所以链接不会有问题。打印为y=200, z=2000
    
    
    第三题
    ----------------------------------------
    //mian.c
    #include<stdio.h>
    int d = 100, x =200;		void p1(void);
    int main(){p1();  printf("%d %d",d,x); return 0;}
    ----------------------------------------
    //p1.c
    double d;//这是搞事啊
    void p1(){d = 1.0;}
    ----------------------------------------
    分析：d一次强定义，一次弱定义，没有链接错误。
    汇编分析：《d = 1.0;》语句，汇编代码
    	FLD1	//将常数1.0装入ST(0)
    	FSTPI &d	//将ST(0)n内容存入d位置
    	相对而言，d地址在低地址，x在高地址。而(1.0)double = (3FF0 0000 0000 0000)H
    	所以存放方式为
    		高地址	x	00	00	F0	3F		(小端方式)
    		低地址	d	00	00	00	00		(下划线是地址最低位，斜体为地址最高位)
    	因此打印为 x = 3FF0 0000 H = 1072693248, d=0
    
    
    结论
    	应避免使用模块间的全局变量，使用static全局变量要好些
    	全局变量尽量赋初值，使其成为强符号，这样在链接时易查错
    	弱定义时使用extern，以表明其定义在其他模块"
  - 第二讲 静态链接和符号解析（1）（静态库文件及其制作）
    "回顾：	链接 = 符号解析 + 重定位
    		符号解析 = 建立 符号引用 和 符号定义 的关联
    
    静态链接的对象：
    	可重定位目标模块(.o文件) + 静态库(标准库和自定义库)(.a文件，其中包含多个.o模块)
    	库包含可以使用的，共享的函数。如数学库sin() cos()，输入输出库，printf() scanf()
    	自定义模块编写规则：
    		1.不要所有函数放在一个源文件中。//这样修改一个函数就要全部重编译，另外执行时效率不高
    		2.不要一个函数写一个源文件。//虽然执行效率高，但是不利于维护，而且需要显式链接
    
    静态库(.a文件，即archive file存档文件)
    	一个库里面包含多个.o模块，编译时只会附上用到的模块
    	制作方法：
    		多个.c文件，如atio.c, printf.c, random.c，预处理/编译/汇编为相应的.0文件
    		然后命令 ar rs libc.c atoi.o printf.o random.o..... 就得到了库文件libc.a （ar 归档器）
    
    库文件制作举例
    	gcc -c p1.c p2.c			//p1.c p2.c是将要归档的源文件，此命令获得两个可重定位文件.o
    	ar rcs mylib.a p1.o p2.0	//将两个.o打包为mylab.a库文件
    库文件使用举例
    	gcc -c main.c			//某程序，其中使用了mylab.a库中的函数(没有include，只有弱定义)
    	gcc -static -o myproc main.o ./mylib.a	//-static静态链接mylab.a库，生成myproc可执行文件
    默认库libc.a库无需显式指定"
  - 第二讲 静态链接和符号解析（2）（符号解析过程）
    "过程命令 gcc -static -o myproc main.o ./mylib.a
    	main() -> fun1() -> printf()
    	mian()定义于main.o
    	fun1()定义于fun1.0，打包到mylib.a，这个静态库中还有fun2()，但是未使用
    	printf()定于于printf.o，打包到libc.a，这个库默认包含，所以无需显式说明
    
    解析时所用集合
    	E 所有目标文件集合(.o)，它们将被合并为可执行程序。需要慢慢找到放进来
    	U 所有未解析的引用符号。在解析完成时，U应该为空
    	D 所有的定义符号
    
    算法
    	按照命令的顺序扫描.o&.a文件
    	将未解析的 符号引用 放入U集合
    	遇到 符号定义 时，除非U集合中有对应符号，不然不会放入D&E集合
    	若扫描到最后 U 不为空，说明还有未解析的符号，这时链接出错
    
    过程举例
    	开始时 E U D 均为空集
    	首先扫描 main.o
    		main.o - > E
    		main -> D
    		fun1 -> U
    	然后扫描 ./mylib.a
    		U 中未定义符号与 mylib.a 中符号匹配，发现fun1
    		U 中取出fun1 -> D，同时fun1.0 -> E
    		但是 fun1 中出现了新的未定义符号 printf
    		printf -> U
    	继续扫描，扫描 libc.a 于是printf -> D 和 printf.o -> E
    	如果 printf 中还有未知符号，继续扫描新
    
    	!!在扫描mylib.a时，未解析集合U中只有fun1，没有fun2，所以 mylib.a 中的fun2.o不会加入 D中
    
    命令换次序 gcc -static -o myproc ./mylib.a main.o
    	这时，首先扫描 mylib.a ，因为U集合为空，所以什么都不会加入 E D集合
    	再扫描main.o ，无法得到 fun1 符号的解析，于是链接失败
    
    结论
    	应该按照调用顺序，来排序命令中的模块和静态库。顺序错误会出错
    
    库文件交叉调用时，写两次
    	gcc -static -o ......... libx.a liby.a libx.a"
  - 总结：符号解析 同节合并 确定地址 修改引用(后三步即重定位)
- 第十二周 重定位和动态链接--2019年6月11日
  - 第一讲 符号的重定位（1）——重定位的基本概念、重定位信息、重定位条目
    "回顾：链接=符号解析+重定位
    	符号解析：得到 ED 集合(E-将要合并的.o文件的集合，D定义符号集合)
    	重定位=同节合并 确定定义符号的地址 修改引用符号的地址
    	根据.rel_data和.rel_text节的重定位信息修改data和text节的引用的地址
    
    重定位信息
    	汇编器(汇编语言->机器码)遇到一个引用，生成一个重定位条目
    	例如汇编器遇到add B，会翻译成05 00000000，05表示add，B因为不知道地址，所以全0
    	然后会生成重定位条目，告诉链接器这里需要改为B的真正地址
    
    重定位条目 格式
    typedef struct{int offset/*节内偏移*/;  int symbol:24/*所绑定符号*/, type:8/*重定位类型*/;} Elf32_Rel
    	offset：节类偏移。即需要重定位的(如符号B)在节内的地址
    	symbol：给出具体是哪个符号，如上文的 B
    	type：重定位类型，两种
    		绝对地址：R_386_32
    		PC相对地址：R_326_PC32  (一般出现在函数跳转中L0)
    
    readelf -r main.0可以查看该模块中的重定位条目
    "
  - 第一讲 符号的重定位（2）——data节的PC相对地址重定位
    "实例
    -------------------------------------
    //main.c文件
    int buf[2] = {1,2};//全局变量定义
    void swap();//弱符号/外部符号。定义在外部，这里只是说明将要使用这个外部符号
    
    int main()/*main函数是 符号定义*/{
        swap: //引用
        return 0;
    }
    -------------------------------------
    //swap.c文件
    extern int buf[];//弱符号/外部符号
    int *bufp0 = &buf[0];//定义，buf为引用
    static int* bufp1;//局部符号定义
    
    void swap()/*定义*/{
        int temp;//局部变量，不是符号
        bufp1/*引用*/ = &buf[1]/*引用*/;
        temp = *bufp0/*引用*/;
        *bufp0/*引用*/ = *bufp1/*引用*/;
        *bufp1/*引用*/ = temp;
    }
    -------------------------------------
    
    反编译mian.o的代码段text得到（第一列为指令地址，从0开始，十六进制）
    -------------------------------------------------------------
    0		push %ebp			//存旧栈顶
    1		mov %esp,%dbp		//把栈底->栈顶指针
    3		and $0xffffff0,%esp	//esp栈底外移，这样子是对齐
    6		call 7<main+0x7>	//call swap
    b		mov $0x0,%eax		//返回0
    10		leave
    11		ret
    -------------------------------------------------------------
    
    反编译main.o的数据段.data，得到，即int buf[2] = {1,2};
    0	01 00 00 00 02 00 00 00
    
    第一步，符号解析
    	E集合：有mian.o swap.o两个模块
    	D集合：有所有定义的符号
    	重定位信息：符号引用的位置、符号名、重定位类型
    
    第二步，重定位
    同节合并，地址当然是虚拟地址。
    	从0x08048000往高位，依次是只读代码段，读写代码段，堆(↑)，共享库区域，用户栈(↓)，内核虚存区
    	只读代码段：.text .rodata
    	读写数据段：.data .bss
    
    	合并时。可以看到call swap，变为6: e8 fc ff ff ff 
    		6表示这条指令地址   e8表示call指令  地址ff ff ff fc 小端还原为-4
    	同时生成swap重定位表项 offset=7  symbol=10  type=R_386_PC32
    	7表示ff ff ff fc的地址为7（即在text节中的偏移，因为main.o时第一个，所有偏移7）
    	10表示第10个符号，即swap，符号表中swap就是第10（第11周第一讲(1)中可见）
    
    	最后，可以看到main.o代码段，长度0x12，即mian符号的长度为18
    
    PC相对地址重定位——指的是PC程序计数器应道+？=所定义的定义符号地址
    	假设main()函数起始地址为0x8048380
    	如果swap紧跟起后，则地址为0x8048380+0x12 = 0x8048392
    	再加上4字节边界对其：0x8048394->即swap地址
    
    	而e8 fc ff ff ff 这条指令的偏移地址为0x6，虚拟地址为0x8048380+0x6
    	当call指令执行时，此时PC==下一条指令地址，即0x8048380+0xb(见上文)
    	所以 PC相对地址 为 0x8048394-0x804838b = 0x9
    
    	所以e8 fc ff ff ff 在重定位后，改为 e8 09 00 00 00
    
    	关于 fc ff ff ff (-4)的意义。因为链接器计算PC相对地址的方式为
    		swap虚拟地址 - (  text节虚拟地址 + 当前引用swap地址的地址/偏移  -   重定位前swap处地址 )
    		ADDR(r_sym) - ((ADDR(.text) + r_offset) - init)
    	swap虚拟地址  == 0x8048392  ，在同节合并后即可知道
    	text节虚拟地址  ==  0x8048380  ，因为main.o模块为text节第一个模块，所以即main地址
    	当前引用swap地址的地址  ==  即fc ff ff ff 的地址，或者说在text节内的偏移，为0x7
    		0x7即e8 fc ff ff ff指令地址0x6+1，因为e8占一个字节
    	重定位前swap处地址  == fc ff ff ff  ，即十进制的-4
    	
    
    	
    "
  - 第一讲 符号的重定位（3）——data节的绝对地址定位
    "同样里例子——研究buf符号
    -------------------------------------
    //main.c文件
    int buf[2] = {1,2};//全局变量定义
    ....
    -------------------------------------
    //swap.c文件
    extern int buf[];//弱符号/外部符号
    int *bufp0 = &buf[0];//定义，buf为引用
    ....
    -------------------------------------
    
    main.o模块的.data节
    -------------------------------------
    0000 0000 <buf>:
    	0: 01 00 00 00 02 00 00 00
    //从本节偏移地址0开始，定义了一个数据，大小8字节。可以看到是int {1,2}，小端方式
    -------------------------------------
    
    swap.o模块的.data节
    -------------------------------------
    0000 0000 <buf>:
        0: 00 00 00 00		//因为需要重定位，所以值为0
    -------------------------------------
    
    swap.o模块的.rel.data节
    -------------------------------------
    0x0 R386_32 9
    //0  表名需要重定位的符号位于data节偏移量0处
    //R386_32  说明是绝对地址重定位
    //9  说明这个符号是符号表的第9个，即buf
    -------------------------------------
    
    开始重定位
    	假定同节合并后，buf地址为0x8049620
    	那么，因为bufp0的地址紧接其后，所以是0x8049620+0x8 = 0x8049628 （因为buf长8）
    	绝对地址重定位：bufp0的值就是buf地址，所以为 20 96 04 08 //小端
    
    综上，可执行目标文件中.data节内容
    -------------------------------------
    08049620 <buf>:
    	8049620:	01 00 00 00 02 00 00 00
    08049628 <buf0>:
    	8049628:	20 96 04 08
    -------------------------------------
    "
  - 第一讲 符号的重定位（4）——text节的绝对地址重定位
    "同样的例子
    -------------------------------------
    //swap.c文件
    extern int buf[];//弱符号/外部符号
    int *bufp0 = &buf[0];//定义，buf为引用
    static int* bufp1;//局部符号定义
    
    void swap()/*定义*/{
        int temp;//局部变量，不是符号
        bufp1/*引用*/ = &buf[1]/*引用*/;
        temp = *bufp0/*引用*/;
        *bufp0/*引用*/ = *bufp1/*引用*/;
        *bufp1/*引用*/ = temp;
    }
    -------------------------------------
    
    
    代码 【bufp1/*引用*/ = &buf[1]/*引用*/;】的可重定位机器/汇编代码为
    -------------------------------------
    6:	c7 05 00 00 00 00		movl $0x4,$0x0		//一条movl翻译成6、c开头的两条机器指令
    c:	04 00 00 00								//0x4表示数组下标[1] 已经考虑在内
    					8: R_386_32	.bss		//8表示8开始的代码00 00 00 00 需要重定位
    					c:R_386_32	buf			//c开始的04 00 00 00 也要重定位
    -------------------------------------
    第一列为代码地址	movl为反汇编代码
    
    开始合并
    	c处为buf[1]，即0x8049620+0x4=0x804964 ，可见编译/汇编时，已经把[1]考虑在内
    	8处为bss节首地址，bufp1
    		假设是0x8049700，那么直接把00 00 00 00 改为 00 97 04 08
    	可见绝对引用就是 重定位地址+原来的值
    
    空指令 nop 
    	现在知道用途了。用于代码段的对齐。"
  - 第二讲 可执行文件的加载——可执行文件的存储器映像、加载execve函数
    "在存储器中的可执行文件：
    	Headers
    	系统代码
    	.text
    	.data/.bss	
    
    可执行文件的存储器映像——指的是虚拟的存储空间(虚存)即下面的图
    ---------------------------------------
    Linux虚存空间结构(32位 共4G)
    ----------------------------------
    0XC000 0000 内核虚存区
      往				用户栈User stack(向小地址生长↓)
      下
      减				共享库区域
      小
    				堆heap，由mallc生成(向高地址生长↑)
    				读写数据段  .data  .bss  ↑
    0X0804 8000	只读数据段 .init  .test.  .rodata  ↑
    0X0000 0000	未使用区域
    ----------------------------------
    
    execve函数调用加载器loader
    	加载器：根据程序头表的信息把程序从磁盘拷贝(只是映射)到存储器映像(虚存)
    		加载完成后，将PC设定到entry_point/_start，最终执行main函数
    	注：不是真正的拷贝，只是建立映射
    
    linux中的int execve(char* filename,char* argv[],*envp[])
    	若执行成功，就不返回，把控制权抓到main
    	main函数的argc argv envp参数都是通过execve传递过来的
    
    实例：hello程序的加载过程
    	1  shell命令行敲入./hello
    	2  命令行解释器会构造argv envp，其中argv[0]="./hello"
    	3  shell调用fork()函数，创建子进程，但此时这个子进程和父进程一模一样
    	4  调用execve()函数，这个函数把子进程的虚存空间修改为hello程序的空间（即加载器的工作）
    		调用顺序 _start -> _libc_init_first -> _init -> atexit -> main ....-> _exit(最终总会执行)
    	5  main函数执行
    
    
    "
  - 第三讲 共享库和动态链接（1）——怎么编写使用共享库、加载时链接&运行时链接
    "使用静态库(.a文件)的缺点：
    	-静态库函数(如printf)包含在每个进程中，这样并发运行多个进程中，造成内存浪费
    	-同样，每个代码文件，如果都包含同样的静态库函数(如printf)，存储器资源浪费
    	-程序员需要关注静态库的更新，每次有新版本需要重新下载编译链接
    
    解决方案：使用共享库shared lib
    	win下为dll文件 动态链接库dynamic link lib
    	Linux下为so文件 动态共享对象dynamic shared objects
    	--共享库是包含目标模块的文件，模块中包含代码和数据
    	--磁盘和硬盘中都只有一个备份，所有进程共享
    	--共享库升级时，可以自动的加载到内存，并和程序链接(无需显示编译链接)
    	--第三方共享库，可以作为程序插件，实现功能扩展
    	--可以在装入时或运行时动态的加载并链接
    
    动态链接方式
    	--在程序第一次加载时进行(load-time linking)
    		Linux中通过动态链接器进行（ld-linux.so 其本身也是个动态库）
    		标准C库(libc.so)通常就是这个方式进行链接
    	--在已经开始后进行(run-time linking)
    		在Linux中通过调用dlopen()接口实现
    		目的：分发软件包、构建高性能web服务器
    
    自己写共享库
    	1. 写源代码a.c 编译汇编为 a.o (可重定位文件)
    	2. gcc -shared -fPIC -0 mylib.so a.o 输出为mylib.so共享库文件
    		PIC--position independent code 位置无关代码
    			保证共享库代码位置可以是不确定的
    			即使长度发生变化，也不会影响调用它的程序
    	3. 使用自己写的共享库 gcc -o hello hello.o ./mylib.so 
    
     gcc -o hello hello.o ./mylib.so 
    	hello不是完全的可执行文件，还有so库的重定位信息
    	说明：静态链接的过程中，会把共享库so文件的重定位信息、符号表信息加载到可执行文件中
    			不过，so库的代码、数据不会复制过去
    
    加载时动态链接
    	执行时，execve加载器，调用ld-linux.so，它负责动态链接库的链接，这时候才重定位
    	重定位发生在内存，和硬盘无关，重定位完成后才开始执行程序（加载时动态链接）
    
    	.interp段，其中就包含动态链接器ld-linux.so的路径
    
    运行时动态链接--通过动态链接接口
    	#include<dlfcn.h>
    	handle = dlopen("./mylib.so",RTLD_LAZY);
    	func = dlsym(handle,"myfunc1");//mylib.so中有myfunc1函数
    	func();//执行动态共享库中的文件
    	dlclose(handle);//卸载"
  - 第三讲 共享库和动态链接（2）——模块内引用和模块间数据引用 PC相对寻址 GOT PLT
    "PIC--位置无关代码（由-发PIC生成）
    	--加载到内存位置不固定（可以加载到任意位置）
    	--即使共享库代码长度发生变化，也不影响调用它的程序
    
    共享库产生的引用问题（2种情况）
    	--库(模块)内的跳转、访问。使用PC相对寻址
    	--库(模块)外的跳转、访问。使用PIC代码
    
    库(模块)内——PC相对寻址（因为相对位置固定）
    	假设当前执行的指令，位置100，长度3，那么此时PC=103，因为指向的是下一条指令地址
    	需要跳转到位置50的指令
    	那么跳转命令中目标地址值写为 -53
    	这样PC+(-53)=50
    
    	访问静态数据类似。都是相对地址。
    
    库(模块)间——全局偏移表GOT（无法确定相对位置）
    	模块A中的函数访问模块B的一个数据。设B是共享库
    	模块A会在.data节中维护一个GOT，GOT是一个指针数组，每项指向B库中需要用到的数据
    	这样一旦AB模块都在内存，那么A模块的GOT内容也随之确定
    	
    	A模块编译时，已经知道需要用到哪些B模块的数据，但是不知道地址。比如10个数据
    	所以在.data节开辟长度10的GOT
    	生成可执行代码时，GOT在模块内的相对地址是确定的。
    	例如代码要找到B模块的第2个数据，同时GOT相对这条代码+100位置
    	那么此代码就填入99+1*4
    	这样访问的是GOT[1]，里面内容暂时是空的
    
    	动态链接时，再把GOT[1]的内容改为B中那个变量的地址
    	总之，这是一个间接寻址访问
    	
    	访问B中的函数(跳转)，类似。GOT还是放在A的.data节
    
    GOT表详解 全局偏移表
    	位于A模块的.data节
    	GOT[0]指向.dynamic节首地址。.dynamic节包含动态链接需要的基本信息
    	GOT[1]动态链接器的表示信息
    	GOT[2]动态延迟绑定代码的入口地址
    	GOT[3..]存放需要绑定的B模块的函数、数据
    
    PLT结构数组详解
    	存放于.text节，是一个结构数组，每项16B，实际上存放的是指令
    	PLT[0]用于聊转到GOT[2]动态延迟绑定代码的入口地址
    	PLT[1..]对应于一个要绑定的B模块的函数(跳转)
    
    延迟绑定技术——利用GOT 和 PLT(过程链接表 procedure linkage table) 跳无数次
    	等到A模块需要用到B模块的数据/函数时，才调用动态链接器修改GOT中需要用得到的项
    	跳转顺序：正常代码->PLT[1..]->GOT[3]->返回PLT[1..]->GOT[0]->GOT[2]->开始绑定
    
    	只有第一次是延迟绑定。之后就是间距访问了，和加载绑定一样。
    
    "
